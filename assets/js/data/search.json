[ { "title": "Never say never —— 致敬2021", "url": "/posts/never-say-never/", "categories": "NEWYEAR", "tags": "新年, 年终", "date": "2021-12-31 19:03:36 +0800", "snippet": " 無視道與理 是與非非 繼續往天飛 再去遁地 在煩亂之中找找氧氣 失意能否不提起当非常规已经逐渐变成常规的2021年，又是一年走到了最后。去年的最后，我们煎熬于疫苗出现之前的暗淡，想要看到最后的那一丝光明。一年过去，全世界已经有了疫苗，但是整个世界还是没有走出疫情。去年的最后，我们奢望于2021年可以恢复之前的正常生活，一年过去，我们还是没有办法正常跨境旅行，甚至连跨省都变成了一件麻烦的事情。去年的最后，我感受到了我在那一年中的变化。一年过去，我顺应了那一年的变化，一步一脚印走到了现在，得到了那时候甚至有些奢望的成果。365天真是一个说长不长，说短不短的循环。回望这一个年度，感觉贯穿全年的是找工作的尝试。这一个年度里，我是从应征，面试，失败的循环中走过来的。其实从去年的年末开始，我就有了想要离开当前工作岗位的想法，然后就带着尝试的想法逐渐开始了寻找工作的路程。其实从刚开始的就知道，在这个疫情的大环境之下，想要在国内寻找到一个跨境的工作应该并没有那么简单。所以也就这样一直安慰着自己走出每一次失败的阴霾。在上半年很多的失败之后，从直接投递官网到寻求linkedin猎头的帮助，其实也尝试了很多的路途，但开始都没有获得最终自己想要的结果。说实话那时候有点心灰意冷，开始投递了一些国内的“大厂“，准备了很多八股文的内容，但是最后都是无疾而终，有的是因为自己当时知识浅薄，有的还是差了最后的临门一脚，最终都是以失败告终。但是每一次失败之后都有其他部门的邀请，所以也就一直在以赛代练的继续往前前进。最后要非常感谢我能够找到现在的这一份工作，或许有时候也是一种缘分。自己的能力当然也还是需要继续的努力精进。其实当时已经是准备收工乖乖度过到下一个年份了，但是经过了几轮的面试之后，我成功得到了自己满意的offer，其实确实是当时一开始没有想到的，感觉也算是自己努力的一个成果，也是和现在的同事之间的一种缘分吧。回望这一个年度，除了面试生活也还是要继续向前。这一年的上半年，走过了祖国的很多地方，从东北黑土地到西南的山区丘陵，也走过了以前只在书里以及地图上看到的地名和景点。在纯朴的绿皮车上，感受了山区铁路的风景壮丽，感受了慢车的旅行情调。在漫长的旅途之中，也有因为帮助一位铁路工作人员而获得了意料之外回报的故事。其实旅途之中除了预定规划好的旅程，一切的相遇和故事都是未知的。沿途的风景和故事总是会出乎意料，刷铁路其实也不仅仅是因为那个数字吧。这一年度登上了玉龙雪山，走过了大庆油田，渡过了几次长江。旅游还是给人一点放松身心和感受自然和人文的想法，因为岳阳楼记而免费登上了岳阳楼，因为想要去滕王阁而背下了千古名篇滕王阁序，人文和景色的结合，也更好的了解了背后的故事。当然还是取消了很多的旅程，因为疫情取消了成都重庆的旅途，取消了去西藏的计划，当然也还是有点遗憾，但是人生当然没有一切都能顺应自己的想法，在未来的一年希望有机会完成这些未完成的计划。回望这一年度，生活中也是得到了一些变化的机会。感谢现在的公司，有机会可以走向日本长住，其实也是对于未知生活的一种向往。但是因为疫情的原因，还是没有在这一年度完成一次的跨境旅行。因为这一个高度人才签证的目标，去完成初级的程序员考试，当然考试是十分简单，在考场上渡过了很多无聊的时间。最后也收获了最后的成果。这一年年初隐约定下的年度目标都收获了最后的成果。因为这样目标的激励，每一天的生活都变得有些盼头，无论是等待考试的结果，等待面试的结果，等待签证结果。这一年因为每一天的期盼，让每一天都变得没有那么无聊。这一年得到了很多的拒信，可能也不会忘记每一次满怀希望但是收到感谢邮件的那一刻，当然也不会忘记最终成功的那一点欢愉，怀揣着这样的点点滴滴，每一天每一月都有着不一样的心情。最后从京东离职的时候，回想着这3年半来的点点滴滴，这是人生中的第一份工作，身边的同事给了自己的很多教导，也学习到了很多。没有大家的帮助也不会有现在的自己，也不会有继续前进的底气。再次感谢大家和这样的一个平台。来到了新的环境，虽然相处只有短短的一个月，但未来可期。承载着过去的点滴，也希望自己能够更好的融入这个好的环境。这一年或许没有去年那么多的感受，那么多的变化，那么多的神奇心情，但是这一年在人生中也是十分重要的一年。在年末，对于这一年的总结，是承前启后，承上启下的一年。2020年的年末感受到了自己想法的一些变化，那么2021年，承接着这些变化完成了一些目标，希望在未来的2022年，甚至更之后能够有着更好的未来。这样承前启后的一年，就这样匆匆而过了。每一年的年末都有一些唏嘘，都会有一篇这样看起来满篇废话的矫情文章，这或许也是一年结束的一种仪式感吧。伴随着2021年的最后一缕夕阳，在阳台的窗边完成了这一篇的文章。未来的2022年这个时间我又会身处何方呢？希望未来总是充满希望，虽然每天都是在未知中前行。人永远不会被动失败，只有放弃了希望，放弃了学习，才是最终的失败。努力走下去，总会获得好结果。2020年的最后，我希望这隧道最后的光明。2021年的最后，感觉到了那一丝光明令我更加的期盼。一如既往的祝愿 友谊地久天长！2022年祝所有好朋友一切顺利！以上。2021年12月31日" }, { "title": "React和它的小伙伴们(3) - React Hooks", "url": "/posts/react3/", "categories": "技术", "tags": "JavaScript, 前端, React, 源码", "date": "2021-07-10 16:00:00 +0800", "snippet": "本文为近期有关于React Hooks源码学习的笔记小结，原文对应为：https://juejin.cn/post/6944863057000529933一 为什么要使用Hooks？React Hooks是React 16.8中引入的有关于函数组件的相关进化，解决了函数组件没有state、生命周期逻辑不能复用的问题。引申： Class组件和函数式组件的优缺点Function组件在之前主要做简单的展示逻辑，没有复杂的业务逻辑或者状态记录。而Class组件有着完善的生命周期支撑。在Hooks引入之后，函数式组件也可以进行状态记录，并且可以进行一些逻辑复用，提供了另一种编码的可能。另一层意义上，后文也会说道，Class组件只要一次实例化之后就能保存状态数据，而函数式组件每次都会重新执行，所以需要Hooks这种机制来保存状态数据。二 TL;DR 函数组件的执行函数：renderWithHooks。两大功能，执行函数组件、改变ReactCurrentDispatch对象。 初始化Hooks： mountWorkInProgressHook生成hooks链表 mountState初始化state dispatchAction控制无状态组件更新 mountEffect初始化useEffect内容 mountMemo初始化useMemo mountRef初始化useRef mountState初始化useState 更新hooks updateWorkInProgressHook更新hooks链表，找到对应hooks updateState获取最新state updateEffect更新updateQueue updateMemo/updateRefs之类的进行更新 三 从何而来?正如前面所说的，Hooks就是一个增强函数式组件功能的东西。所以，在探究Hooks之前，可以先看一下Function组件是在哪里开始进行处理的。function组件的初始化是调用这个方法开始的：renderWithHooks( null, // current Fiber workInProgress, // workInProgress Fiber Component, // 函数组件本身 props, // 函数组件的props context, // 函数组件的context renderExpirationTime // 渲染优先级标志)引申：current Fiber和workInProgress Fiber：两者是React Fiber所用到的双缓存两棵树，current是上一次渲染（也就是现在在展示的DOM）所对应的Fiber树状结构，而在触发更新渲染之后会在workInProgress这个Fiber树上进行构建和处理，构建完成之后，会把workInProgress赋值给current树。所以当current为null的时候，可以知道这一定是这个程序第一次run，也就是初次渲染。这个方法中也主要用到了以下这些数据结构： workInProgress.memoizedState: 对于Class组件，这个内容主要是用来存放state信息，而在函数式组件中，将以 链表 形式来存放hooks的信息。 需要注意区分两个memoizedState： 此处Fiber树上的会保存hooks信息链表或者state信息，而hooks数据结构中也会有这个内容，但是其中存储的是每个Hooks不同的内容 currentHooks：current树上的当前调度的hooks节点。 workInProgressHooks：workInProgress树上的当前调度的hooks节点这个方法的主要做的事情： 置空workInProgress树上的memoizedState和updateQueue。接下来的步骤需要将新的信息放到这两个节点上面。 根据组件是否是第一次渲染，赋予ReactCurrentDispatcher.current不同的hooks调用方法名称。两个通过current树上是否有内容进行区分，两者的区别在一个是用HooksDispatcherOnMount中的方法来处理hooks对象，而非首次则用HooksDispatcherOnUpdate中的方法。 调用Component(props, secondArgs)来执行我们写的函数组件。我们的hooks组件会依次执行，然后保存到workInProgress树上。具体如何绑定在之后讲到 将ContextOnlyDispatcher赋值给ReactCurrentDispatcher.current。 置空一些currentHooks等的数据const HooksDispatcherOnMount = { useCallback: mountCallback, useEffect: mountEffect, useLayoutEffect: mountLayoutEffect, useMemo: mountMemo, useReducer: mountReducer, useRef: mountRef, useState: mountState,};const HooksDispatcherOnUpdate = { useCallback: updateCallback, useEffect: updateEffect, useLayoutEffect: updateLayoutEffect, useMemo: updateMemo, useReducer: updateReducer, useRef: updateRef, useState: updateState};四 Hooks的初始化前面提到的方法第三步讲到了hooks的初始化操作，那么接下来就是了解如何进行初始化这些hooks。主要围绕四个重点Hooks：useState：组件状态和更新触发 useEffect：执行副作用useRef：保存数据 useMemo：缓存优化mountWorkInProgressHook所有Hooks的生成都需要调用这个方法，这个方法主要是为了生成Hooks的数据结构，并且把这些生成的Hooks放置到workInProgress树上的memoizeState上。Hooks的对象里存储的内容： memoizedState: 每个Hooks中会缓存不一样的数据。useState：state信息、useEffect：effect对象、useMemo：缓存的值、useRef：ref对象 baseQueue：useState和useReducer中保存最新的更新队列。 baseState：useState和useReducer中，一次更新中，产生的最新state的值 queue：保存待更新队列pendingQueue，更新函数dispatch等信息 next：指向下一个hooks对象因为这个Hooks结构，所以在Fiber树上的state会是一个通过Hooks中next对象链接的链表。Q：为什么Hooks不能声明在条件语句中：A：因为React中会进行对比current树和workInProgress树进行比较。如果在条件语句中声明Hooks的话，可能会导致两个树比较的hooks信息不相同（因为链表链接的next），涉及到读取state的操作的话，会发生异常。useState与mountState 获得初始化的state，并将其赋值给mountWorkInProgressHook产生的hook对象的memoizedState和baseState属性，创建queue对象负责保存更新的信息。 利用dispatchAction（无状态组件更新机制）方法得到可以触发更新的方法。useState传出去的第二个内容为绑定了Fiber节点和updateQueue两个参数的dispatchAction方法。dispatchAction作用机制 无论是类组件调用setState还是函数组件的dispatchAction都会产生一个update对象，记录此次更新的信息，然后把这个update放入待更新的pending队列中。（队列也是循环链表） 判断当前函数组件的Fiber是否出入渲染阶段。 处于更新阶段，那么就不需要更新组建，而是更新expirationTime即可。 不处于更新阶段，则调用lastRenderedReducer来获取最新的state，和上一次的currentState作比较。 currentState和新state相同，就不会触发更新操作 不相同，调用scheduleUpdateOnFiber调度渲染到当前的Fiber。 useEffect与mountEffect 创建hooks对象，并且这里保存effect hooks的信息 调用pushEffect(tag, create, destroy, deps) 方法创建出effectHooks信息。 因为effect是一个闭包的运行环境，所以如果执行setTimeout等异步方法，可能会拿不到最新的依赖项数据。pushEffect机制：作用： 创建effect对象，挂载updateQueue详细：判断这个组件是不是第一次渲染，那么创建componentUpdateQueue（workInProgress中的updateQueue），然后将effect放入其中。其中的updateQueue将会是一个循环链表。useMemo与mountMemo创建一个hooks，执行useMemo的第一个参数，得到需要缓存的值，然后将值与deps记录下来，赋值给当前memoizedStateuseRef与mountRef创建一个ref对象，对象的current来保存至，用memoizedState来保存这个对象。总结在一个函数组件第一次渲染上下文过程中，每个hooks产生一个hooks对象，形成链表。绑定在树的memoizedState上，对于effect会在workInProgress.updateQueue上绑定，在commit阶段执行每个effect钩子。这里有两个循环列表出现： 在dispatchAction时候提交的action 在useEffect中提交的effect五 Hooks的更新updateWorkInProgressHook对于一次函数组件更新，当再次执行Hooks函数时，首先要从current树的Hooks中找到当前workInProgressHook对应的currentHooks，然后复制一份给workInProgressHook，接下来hook函数执行时，再把最新状态更新上去，以保证其不丢失。useState的更新：updateState将setXXX中执行时候放入的pendingQueue内容（dispatchAction），合并至baseQueue。把当前useState或useReducer对应的hooks上的baseState和baseQueue更新到最新状态。循环baseQueue的update，复制并更新expirationTime，获取最新的state状态，然后执行useState上的每一个action。useEffect的更新：updateEffect判断两次deps是否相等： 若相等，则此时useEffect不需要执行，直接调用pushEffect（与初始化类似，把内容放入updateQueue中，tag为hookEffectTag） 若不相等，那么需要更新effect，并直接赋值给hook.memoizedState（tag为hookHasEffect hookEffectTag） 在commit阶段，React通过tag来判断是否执行当前的effect函数。不管是不是都要执行都要push，是因为后一次的更新需要比较。useMemo的更新：updateMemo判断deps是否相等，若不相等，那么因为依赖项目发生了改变，执行memo的第一个方法，得到新的值，放入hook.memoizedState。若相等，那么就不用执行，直接拿内容使用即可。useRef的更新：updateRef返回缓存下来的值，无论函数如何执行，执行了多少次。因为这些内容都指向了同一个对象。问答Q1：在无状态组件中每一次执行函数上下文的时候，React用什么方式记录hooks的状态。A1： 利用Fiber树种的current树种对应Fiber结点的memoizedState中所保存的hooks数据结构所组成的链表。Q2：多个Hooks用什么来记录每一个hooks的顺序的？（为什么不能在条件语句中声明hooks？）A2：用Fiber结点中memoizedState中的数据结构链表。因为函数是组建每次都会重新执行，若条件变化会导致hooks顺序的变化，会导致workInProgress树种与current树种的内容无法匹配，产生读取状态数据时候的问题Q3：setState与useState的区别？A3：1. setState是Class组件特有的设置状态的方法，这个会直接在实例化的class组件中进行修改。而useState是函数式组件Hooks中使用的设定状态的方法，useState的数据保存和是否执行通过dispatchAction的操作进行判断 setState不会对两次状态的变更进行比较，就算两个state是相同的都会进行更新。但是useState的设定的话，如果两次state相同就不会对其进行修改和改变。Q4：useRef为什么不需要依赖注入？A4：因为useRef只是运用了一个current指针指向一个内存对象，所以不需要对依赖项目进行判断。Q5：useMemo是如何缓存的？A5：将缓存的内容保存在hook的memoizedState中，方便后续的运行中，如果deps相同就直接取用。Q6：useEffect中为什么不能写异步async函数？A6：因为useEffect需要return一个函数，为了在下一次执行的时候apply执行这个函数进行销毁时候的操作。如果使用了async函数就会导致返回给React内核的是一个Promise，而没有apply方法，导致报错。所以要使用async的话需要重新包一层函数然后调用，这样就不会返回一个Promise给内核方法。" }, { "title": "JavaScript红宝书再阅读（2）", "url": "/posts/javascript-reading-7/", "categories": "技术", "tags": "JavaScript, 前端, 读书笔记, 再学习", "date": "2021-03-06 23:00:00 +0800", "snippet": "第7章 迭代器与生成器1. 迭代器迭代器模式描述了一个方案，即可以把有些实现了正式的Iterable接口，而且可以通过迭代器Iterator消费的结构称为”可迭代对象“（iterable）。迭代器无需了解与其关联的可迭代对象的结构，只需要知道如何取得连续的值。可迭代协议（实现Iterable接口）：需要具备的两种能力: 支持迭代的自我识别能力 创建实现Iterator接口的对象的能力在ES中，上述两点意味着： 必须暴露一个属性作为”默认迭代器“，而且这个属性必须使用Symbol.iterator作为键。 这个迭代器必须引用一个迭代器工厂函数，调用这个工厂函数必须返回一个新迭代器。实现了该接口的内置类型：字符串、数组、映射（Map）、集合（Set）、arguments对象、NodeList等DOM集合类型接收可迭代对象的原生语言特性（自然调用迭代器对象Symbol.interator）：for-of循环、数组解构、扩展操作符、Array.from()、创建集合、创建映射、Promise.all()接收有Promise组成的可迭代对象、Promise.race()接收有Promise组成的可迭代对象、yield*操作符Ex.:let num = 1;let obj = {};let str = &#39;abc&#39;;console.log(num[Symbol.iterator]); // undefinedconsole.log(obj[Symbol.iterator]); // undefinedconsole.log(str[Symbol.iterator]); // f values() {} //调用这个生成器会生成一个迭代器console.log(str[Symbol.iterator]()); // StringIterator(); //如果对象原型链上的父类实现了Iterable接口，那这个对象也实现了这个接口class FooArray extends Array{}let fooArray = new FooArray(&#39;foo&#39;,&#39;bar&#39;,&#39;baz&#39;);for(let el of fooArr) { console.log(el);}迭代器协议迭代器是一种一次性使用的对象，用于迭代与其关联的可迭代对象。迭代器API使用next()方法在可迭代对象中遍历数据。每次成功调用next()，都会返回一个IteratorResult对象，包含两个值： value：包含可迭代对象的下一个值（done为false）、undefined（done为true） done：一个布尔值，表示是否还可以再次调用next()取得下一个值。true为耗尽。迭代器的两点注意点： 每个迭代器得到的实例之间没有关系，只会独立地遍历可迭代对象。 迭代器并不与迭代对象的某个时刻的快照绑定，如果对象被修改了那么迭代器也会反映变化。（关于2的个人想法，所以对于数组的forEach修改，前一个如果修改，那么后一个得到的内容将会是修改后的）（虽然和这个无关，但是亲测是正确）注意：迭代器维护者一个指向可迭代对象的引用，因此迭代器会阻止垃圾回收程序回收可迭代对象。Ex.let arr = [&#39;foo&#39;, &#39;bar&#39;];console.log(arr[Symbol.iterator]); // f values() { [native code] }let iter = arr[Symbol.iterator](); console.log(iter) // ArrayIterator {}console.log(iter.next()); // {done: false, value: &#39;foo&#39;}console.log(iter.next()); // {done: false, value: &#39;bar&#39;}console.log(iter.next()); // {done: true, value: undefined}//只要到达next()的done为true的地方，之后无论如何调用next得到的值都为一样。console.log(iter.next()); // {done: true, value: undefined}// 每个迭代器得到的实例之间没有关系，只会独立地遍历可迭代对象let iter1 = arr[Symbol.iterator](); let iter2 = arr[Symbol.iterator](); console.log(iter1.next()); // {done: false, value: &#39;foo&#39;}console.log(iter2.next()); // {done: false, value: &#39;foo&#39;}console.log(iter2.next()); // {done: false, value: &#39;bar&#39;}console.log(iter1.next()); // {done: false, value: &#39;bar&#39;}//迭代器并不与迭代对象的某个时刻的快照绑定，如果对象被修改了那么迭代器也会反映变化。let iter3 = arr[Symbol.iterator]();console.log(iter3.next()); // {done: false, value: &#39;foo&#39;}arr.splice(1, 0, &#39;baz&#39;);console.log(iter3.next()); // {done: false, value: &#39;baz&#39;}console.log(iter3.next()); // {done: false, value: &#39;bar&#39;}自定义迭代器任何实现了Iterator接口的对象都可以作为迭代器使用。如下面例子中的Counter类。class Counter { constructor(limit) { this.count = 1; this.limit = limit; } next() { if (this.count &amp;lt;= this.limit) { return {done: false, value: this.count++}; } else { return {done: true, value: undefined}; } } [Symbol.iterator]{ return this; }}let counter = new Counter(3);for(let i of counter) console.log(i);//1//2//3for(let i of counter) console.log(i);// (nothing）上述对象因为直接修改了实例对象中的内容，所以每个实例的counter对象只能够被迭代一次。为了解决这个问题，需要把计数器放在闭包中， 然后通过闭包来返回迭代器。class Counter { constructor(limit) { this.limit = limit; } [Symbol.iterator]{ let count = 1, limit = this.limit; return { next() { if(count &amp;lt;= limit) {return {done: false, value: count++};} else {done: true, value: undefined}; } } }}let counter = new Counter(3);for(let i of counter) console.log(i);//1//2//3for(let i of counter) console.log(i);//1//2//3提前终止迭代器可选的return()方法用于指定在迭代器提前关闭时执行的逻辑。执行迭代的结构在想让迭代器知道它不想遍历到可迭代对象耗尽时，就可以“关闭”迭代器。可能的情况： for-of循环通过break、continue、return或throw提前退出 结构操作并未消费所有值。return()方法必须返回一个有效的IteratorResult对象。简单情况下，可以只返回{done: true}如果迭代器没有被关闭（done没有被设置为true），那么还可以继续从上次断开的地方继续迭代。要知道这个迭代器是否是可以被关闭的话，只要判断return属性是不是函数对象。不过，仅仅给一个不可关闭的迭代器增加这个方法并不能让它变成可关闭的。class Counter { constructor(limit) { this.limit = limit; } [Symbol.iterator]{ let count = 1, limit = this.limit; return { next() { if(count &amp;lt;= limit) {return {done: false, value: count++};} else {done: true, value: undefined}; }, return() { console.log(&#39;Existing early&#39;); return {done: true}; } } }}let counter = new Counter(5);for (let i of counter) { if(i &amp;gt; 2) break; console.log(i);}//1 2 Existing early//如果迭代器没有被关闭（done没有被设置为true），那么还可以继续从上次断开的地方继续迭代。//数组的迭代器是不能被关闭的。let a = [1,2,3,4,5];let iter = a[Symbol.iterator]();for(let i of iter) { console.log(i); if(i &amp;gt; 2) break;}// 1 2 3for(let i of iter) { console.log(i); // 4 5}2. 生成器何为生成器生成器是ES6新增的一个极为灵活的结构，拥有在一个函数块中暂停和回复代码执行的能力。这个能力可以自定义迭代器和实现协程。生成器基础生成器的形式是一个函数，函数名称前面加一个星号（*）表示它是一个生成器。只要是可以定义函数的地方，就可以定义生成器。注意：箭头函数不能用来定义生成器函数。调用生成器函数会产生一个生成器对象。生成器对象一开始处于暂停执行的状态（suspended）。与迭代器类似，生成器也实现了Iterator接口，因此具有next()方法，调用这个方法会让生成器开始或回复执行。next返回的value为生成器函数的返回值，默认值为undefined。可以通过return 来指定。生成器函数只会在初次调用next()方法后开始执行。生成器对象实现了Iterator接口，默认的迭代器是自引用的。//生成器函数声明function* generatorFn() {}//生成器函数表达式let generatorFn = function* () {}//作为对象字面量方法的生成器函数let foo = { * generatorFn () {},}//作为类实例方法的生成器函数class Foo { * generatorFn() {};}//作为类静态方法的生成器函数class Bar { static * generatorFn() {};}//生成器对象的生成const g = generatorFn();console.log(g) // generatorFn( &amp;lt;suspended&amp;gt; )console.log(g.next) // f next() { [native code] }console.log(g.next()) // { done: true, value: undefined } function* generatorFn1() { console.log(&#39;foo&#39;);}//初次调用并不会打印日志let gO = generatorFn1();//手动调用next之后才会调用。generatorFn1.next(); // foo//自引用迭代器console.log(g === g[Symbol.iterator]()) // true使用yield来中断执行生成器函数在遇到yield之前会正常执行。遇到之后，会停止，函数作用域的状态会被保留。停止执行的生成器函数只能通过生成器对象上调用next()来恢复执行。yield有点类似于函数的中间返回语句。通过yield退出的生成器函数会处在{ done: false }的状态。通过return返回的done会成为true。生成器内部的执行流程会针对每一个生成器对象区分作用域。在一个生成器对象上调用next()不会影响其他生成器（类似于迭代器的机制）。yield只能直接在生成器函数内部使用，在其他地方或者嵌套使用会抛出错误。yield的作用： 生成器对象作为可迭代对象。 使用yield实现输入和输出。 产生可迭代对象（yield *）。 yield* 实际上只是讲一个可迭代对象序列化为一连串可以单独阐述的值。所以这把yield放入一个循环中并没有什么不同。yield*的值是关联迭代器返回done: true时的value属性，对于普通迭代器来说，这个值是undefined，对于生成函数产生的迭代器来说，这个值是return的值。 使用yield*实现递归算法。 这个内容可以用来实现图，并且实现深度优先遍历等图的算法（具体代码参考P200-201） // 1 生成器对象作为可迭代对象。function* generatorFn() { yield 1; yield 2; yield 3;}for(const x of generatorFn()) { console.log(x);}//1 2 3// 需要自定义迭代对象时，这样使用生成器对象会比较有用：// 需要定义一个可迭代对象，他会产生一个迭代器，这个迭代器会执行指定的次数。function* nTimes(n) { while(n--) yield;}for (let _ of nTimes(3)) { console.log(&#39;foo&#39;);}// foo foo foo// 2 使用yield实现输入和输出。function* generator2(init){ console.log(init); console.log(yield); console.log(yield);}// yield位置会接受到next方法的第一个参数。// 但是第一次调用next传入的直不会被使用，因为这只是开始生成器let g = generator2(&#39;foo&#39;);g.next(&#39;bar&#39;) // foog.next(&#39;baz&#39;) // baz (attention!)//yield也可以输出内容function* ge3(){ return yield &#39;foo&#39;;}let g2 = ge3();//先遇到yield传出foo，然后在return yield传入的内容barconsole.log(g2.next()); // { done: false, value: &#39;foo&#39; }console.log(g2.next(&#39;bar&#39;)); // { done: true, value: &#39;bar&#39; }//无穷计数器function* infi() { for(let i = 0; ; ++i){ yield i; }}let infig = infi();console.log(infig.next().value) // 1console.log(infig.next().value) // 2//...//亦可以实现范围和填充数组function* range(start, end) { while(end &amp;gt; start) { yield start++; }}for (const x of range(4, 7)) { console.log(x); // 4 5 6}function* zeroes(n) { while(n--) yield 0;}console.log(Array.from(zeroes(8))) // 8个0的数组// 3 yield* function* ge4 () { for (const x of [1,2,3] yield x;}function* ge4equal() { yield* [1,2,3];}// 4 递归算法function * nTimes(n) { if(n &amp;gt; 0) { yield nTimes(n - 1); yield n - 1; }}for(const x of nTimes(3)) { console.log(x);}// 0 1 2 生成器作为默认迭代器这里for-of循环调用了默认迭代器（是一个生成器函数）例子：class Foo { constructor(){ this.value = [1,2,3]; } *[Symbol.iterator](){ yield* this.value; }}const foo = new Foo();for(const x of foo) console.log(x);// 1 2 3提前终止迭代器return和throw方法都可以用于生成器进入关闭状态。与迭代器不同，所有生成器都有return()，一旦调用就无法回复了。for-of循环等语言内置语言结构会忽略状态done为true的返回值。throw()方法会在暂停的时候将一个提供的错误注入到生成器对象中，如果没有被处理生成器就会被关闭。不过假如生成器函数内部处理了这个错误，那么就不会被关闭，并且可以恢复执行，错误处理会跳过相应的yield。注意：如果生成器对象还没有执行，那么调用的throw抛出的错误不会在函数内部被捕获，相当于在函数块外部抛出了错误。function* geThrow() { yield* [1,2,3];}const g = geThrow();try { g,throw(&#39;foo&#39;);} catch(e) { console.log(e); // foo}console.log(g) // closed//内部处理了errorfunction* geCatch() { for( const x of [1,2,3]) { try { yield x } catch(e){}; }}const gC = geCatch();console.log(gC.next()); // {done: false, value: 1} // 因为yield抛出的错误在内部被捕获，所以不会产出2gC.throw(&#39;foo&#39;);console.log(gC.next()); // {done: false, value: 3}" }, { "title": "JavaScript红宝书再阅读（1）", "url": "/posts/javascript-reading-9/", "categories": "技术", "tags": "JavaScript, 前端, 读书笔记, 再学习", "date": "2021-03-03 19:00:00 +0800", "snippet": "第9章 代理与反射注意：本章的内容是ES6之后的专属，注意兼容性。1. 代理的定义与创建代理是目标对象的抽象，类似于C++的指针。可以用作目标对象的替身，但又完全独立于目标对象。Ex:const target = { id: &#39;target&#39;,};const handler = {};//需要两个参数，一个是目标对象，一个是处理程序对象，生成一个新的代理对象const proxy = new Proxy(target, handler);console.log(target.id); // target console.log(proxy.id); // targettarget.id = &#39;foo&#39;;console.log(target.id, proxy.id); //foo fooproxy.id = &#39;bar&#39;;console.log(target.id, proxy.id); //bar barconsole.log(target.hasOwnProperty(&#39;id&#39;)); //trueconsole.log(proxy.hasOwnProperty(&#39;id&#39;)); //true//Attention: Proxy没有prototype，所以无法使用instanceOfconsole.log(target instanceof Proxy) //TypeErrorconsole.log(proxy instanceof Proxy) //TypeErrorconsole.log(proxy instanceof Object) // trueconsole.log(typeof proxy ) // &quot;object&quot;//相等可以区分两者console.log(target === proxy); // falseconsole.log(target == proxy); // false 2.代理的作用主要目的是可以定义捕获器（trap）（基本操作拦截器）每次在代理对象上调用这些方法的时候，代理可以在这些操作传播到目标对象前先调用捕获器函数，从而拦截相关行为。Ex.:const target = {foo: &#39;bar&#39;};const handler = { // 捕获器在处理程序中以方法名为键。// 任何捕获器都有三个参数：目标对象，要查询的属性，代理对象 get(trapTarget, property, receiver) { console.log(trapTarget === target); console.log(property); console.log(receiver === proxy); //重新创建get的原始行为 // return trapTarget[property]; return &#39;handler override&#39;; }}const proxy = new Proxy(target, handler);//可以触发get的方式：proxy[property] // 直接获取属性, 只会获取到get中返回的内容proxy.foo// true// foo// ture// handler override proxy.property // 直接获取属性Object.create(proxy)[property] 想要触发get就一定要在proxy对象上进行操作，否则不会触发捕获器。在原target上就不会3.Reflect对象所有捕获器都能够基于参数创建原始操作，但是有些操作会比较复杂。所以可以调用全局Reflect对象的同名方法来创建（Reflect对象封装了原始行为）const target = {foo: &#39;bar&#39;};const handler = { get() { return Reflect.get(...arguments); }}/*更简洁：const handler = { get: Reflect.get}*/const proxy = new Proxy(target, handler);// 创建一个捕获所有方法，然后将方法转发给反射API的空代理，可以使用const proxyReflect = new Proxy(target, Reflect);4.捕获器不变式捕获器设置限制：捕获器不变式（trap invariant)：因方法不同而异，但通常会防止捕获器定义出现过于反常的行为。Ex. 目标对象有一个不可配置且不可写的数据属性，那么在捕获器返回一个与该属性不同的值时，会抛出TypeErrorconst target = {};Object.defineProperty(target, &#39;foo&#39;, { configurable: false, writable: false, value: &#39;bar&#39;,});const handler = {get: ()=&amp;gt;&#39;qux&#39;}const proxy = new Proxy(target, handler);console.log(proxy.foo)// TypeError5.撤销代理new Proxy创建的代理在生命周期中会一直存在，如果要撤销可以使用revocable()方法来创建代理，并且创建出来的revoke方法是幂等的，调用多少次结果都一样。revoke之后再调用这个代理对象会得到TypeErrorEx:const target = { foo: &#39;bar&#39;,};const handler = {get: ()=&amp;gt;&#39;intercepted&#39;}const { proxy, revoke } = Proxy.revocable(target, handler);console.log(proxy.foo) // &#39;intercepted&#39;console.log(target.foo) // &#39;bar&#39;revoke();console.log(proxy.foo) // TypeError6.反射API反射API并不限于捕获处理程序，大多数反射API方法在Object类型上有对应的方法。通常Object上的方法适用于通用程序，而反射方法适用于细粒度的对象控制与操作。：一些反射方法返回的是状态标记的布尔值，表示操作是否成功。Ex:const o = {};try { Object.defineProperty(o, &#39;foo&#39;, &#39;bar&#39;); console.log(&#39;success&#39;);}catch(e) { console.log(&#39;fail&#39;);}//利用Reflect的状态标记重构：const o = {};if(Reflect.defineProperty(o, &#39;foo&#39;, &#39;bar&#39;)) { console.log(&#39;success&#39;);} else { console.log(&#39;fail&#39;);}//返回状态标记的Reflect方法；Reflect.defineProperty();Reflect.perventExtensions();Reflect.setProtoTypeOf();Reflect.set();Reflect.deleteProperty();//用函数来替代操作符Reflect.get(); // 替代对象访问操作符Reflect.set(); // 替代=操作符Reflect.has(); // 替代in/with()Reflect.deleteProperty(); // 替代deleteReflect.construct(); // 替代new//安全调用可能已经被重载的方法Reflect.apply(myFunc, thisVal, argu);7.多层次代理//代理另一个代理const target = { foo: &#39;bar&#39; };const firstProxy = new Proxy(target, { get() { console.log(&#39;first proxy&#39;); return Reflect.get(...arguments); }});const secondProxy = new Proxy(firstProxy, { get() { console.log(&#39;second proxy&#39;); return Reflect.get(...arguments); }});console.log(secondProxy.foo);// second proxy// first proxy// &#39;bar&#39;8.代理的问题 代理中的this const target = { thisValEqualProxy() { return this === proxy } } const proxy = new Proxy(target, {}); console.log(target.thisValEqualProxy()); // false console.log(proxy.thisValEqualProxy()); // true 无法与Date等存在Proxy没有的内部槽位方法的对象共存使用 const target = new Date();const proxy = new Proxy(target, {});console.log(proxy instanceof Date); // trueproxy.getDate(); // TypeError: 因为这个方法依赖于this中的[[NumberDate]]，// 代理对象上不存在，所以抛出TypeError9.代理捕获器与反射方法getsethas definePropertygetOwnPorpertyDescriptordeletePorpertyownKeysgetPropertyOfsetPropertyOfisExtensiblepreventExtensionsapplyconstruct具体参考中文版红宝书P275 - P28310.代理模式跟踪属性访问通过捕获get set has等操作，可以知道对象属性什么时候被访问过，被查询过。隐藏属性属性验证验证所给的值是允许还是拒绝赋值函数与构造函数参数验证只让函数接受某种类型的值数据绑定与可观察对象// 跟踪属性访问const user = {name: &#39;Jack&#39;};const proxy = new Proxy(user, { get(target, property, receiver){ console.log(`getting ${property}`); return Reflect.get(...arguments); }, set(target, property, value, receiver){ console.log(`setting ${property}=${value}`); return Reflect.set(...arguments); }});// 隐藏属性const hidden = [&#39;foo&#39;, &#39;bar&#39;];const targetObject = { foo: &#39;1&#39;, bar: &#39;2&#39;, baz: &#39;3&#39;,};const proxy = new Proxy(target, { get(target, property){ if(hidden.includes(property)) { return undefined; } else { return Reflect.get(...arguments); } }, has(target, property) { if(hidden.includes(property)) { return false; } else { return Reflect.has(...arguments); } }});//属性验证const proxy = new Proxy(target, { set(target, property, value, receiver) { if(typeof value !== &#39;number&#39;) { return false; } else { Reflect.set(...arguments); } }});//函数与构造函数参数验证 const proxy = new Proxy(target, { apply(target, thisArg, argList) { for(const arg of argList) { if(typeof arg !== &#39;number&#39;) throw &#39;Non-number argument provided&#39;; } return Reflect.apply(...arguments);});//数据绑定与可观察对象/* 1. 将被代理的对类绑定到一个全局实例集合，让所有创建的实例都可以放入到这个集合中 2. 把集合绑定到一个事件分派程序，每次插入新实例都会发送消息 代码见书P285-286*/" }, { "title": "孤身走我路 —— 记2020", "url": "/posts/2020newyear/", "categories": "NEWYEAR", "tags": "新年, 年终", "date": "2020-12-31 19:00:00 +0800", "snippet": "题记：以往的年末总结都是在年末的最后一天。特殊的一年就将走到尾声了，今年的经历了许多，所以就先行准备好了。 我已决意踏遍长路，跟心中拍子。傲然独舞永没停步，不想管终点何日到 。2020年，这一年估计是谁都没想到会这样度过的一年。从年初的惊慌失措，到年终的坦然面对。这不平凡的一年，也经历了许多不平凡的事情，做出了很多关于人生的决定。这一年的事情或许也已经决定了未来好几年的人生走向。从年末回望年初，那时候根本不会想到这一年会是这样度过。2020年的一切是从一种未知病毒的了解开始的，并且贯穿了这一整年的基调。其实，这场疫情估计也像改变了我的人生一样改变了世界上很多人的人生。对于我来说，这一年的转折或许出现在下半年的第一天，上下两个半年在我现在看来似乎判若两人。在疫情全面爆发之前，安排了一场日本旅行。这是一场不知道何日更重游的出境。突如其来的疫情，让闭关锁国的常态化，对国外水深火热印象的加深，并且国内民族主义的爆发式增长。国际人流往来的减少，成为了上述三点持续性恶化的温床，在我看来，这或许不是什么好事情。上半年，贯穿的就是在家。春节假期之后，一直到4月之前似乎都没有好好的去过职场。春节时期空城的肃杀，一周甚至两周才出门一次，走在外面的马路上似乎是寂静岭。路上的公共汽车纷纷开出了60分钟甚至以上的间隔。骑着自行车来回市中心就为了买上一点春节例行的食物，也是前所未有的体验。那时候的晚上五六点天黑骑在平凉路上，感觉是半夜一两点。在家办公的时间一延再延，成为了一种新奇的生活体验。当然，那段时间也是完成了一些事情，也让我感受到了其实有时候每天上班的通勤可能只是为了满足人们的群居性吧。这一年，也继续了去年的考研历程。这一些的内容可以看之前更详细的博文，里面有所有考研经历的总结。当然非全日制的调剂复试我是很有信心能够通过的，但是通过之后更多的是担忧。录取之后、缴费之前也陆陆续续有点想法，最后的做决定的纠结总爆发实在开学之后。当然这一段经历在前一篇博文也有着详细的描述。这里也就不再多写了。考研对于我来说或许更多的是学习的检验。有一天的加班回家路上，听了一路的《孤身走我路》，或许每个人的人生都是孤身走我路，一如既往。这一年里，虽然没有了机会走出国门，但是在国内确实也走了很多之前根本不会想到的地方。走到了西部地区，看到了中国经济落后地区的现况，了解到了读万卷书。更要行万里路。身处城市长大的我根本不会想到在西部地区的人们是这样的生活。说起读万卷书，这一年可能是近几年都是最多的一年吧。书评也是写了一点，了解历史或许也是一种乐趣。当然读书的速度还是比不上买书的速度吧。疫情当然也给旅游带来了一些麻烦。各地为政的二维码和土方法也看到了这个国家的一些弊端。上半年的惊恐随着疫情在国内的渐渐和缓而有所减少，出门次数逐渐增多，口罩也渐渐拿了下来。虽然行动松懈但是思想上还是有很多人对于疫情的敏感度没有消退。但是不禁令人反思，是不是反应过度激烈了。这个事情或许要到时候才能盖棺定论了。上半年还有一件事，就是拿到了上海车牌和自己的车。如果一个词在总结上半年的话，或许是孤独。在家办公、外出自肃的时候，在上半年独自旅游的时候，在上半年很少很人讲话的时候。人生来就是孤独的，所以，孤身走我路。下半年的序曲，从沪通铁路的开通开始。可能只是普通的一天，但也可能就此改变了一些东西。下半年的一切，过得有点和以前不太一样。听到了之前距离自己蛮遥远的故事，感受到了之前没有感受到的感觉，尝试了以前没有做过的事情。有些人事物或许就是有这样的魅力驱动着我去做一些事情。摆脱孤独，或许是下半年我个人的感受。我从来没有想到过，我会感觉到单人旅行不再那么快乐，感觉到分享生活点滴会习惯成自然。国庆的铁道大纪行，虽然在事前一度认为会被取消，但最终还是顺利成行。这是我第一次如此深入国铁，途中第一次一个人参加了婚礼，虽然很抱歉的早退了，但是也感受到了爱情的无上甜蜜。一次铁道旅行，重要的并不是目的地，而是沿途的风景。我永远不会忘记在宝成线的风景和事情，不会忘记在黄河桥上发呆看夕阳西下的那十几分钟，不会忘记第一次青藏上陆的漫步。一次旅途发生了很多值得记忆的事情，或许正是这一年的机缘巧合才给了这样的机会。下半年的几个月工作上似乎没有什么建树，不过午饭倒是变的丰盛起来。在2020年的最后一周离开了充满记忆的淞虹路，离开了美食基地娄山关路，也离开了每周五的71の日。在呼兰路的一切我只体验了一周，一切是那么的新鲜。工作上的事情并不会在这里多谈，这一年一如既往的和大家合作很愉快，虽然有时候会遇到一些挫败和小插曲。但是在技术的学习上，仍然感受到的是原地踏步和被外人嫌弃。人生追求的是什么，这几天莫名开始思考起了这个问题。一些东西是我从大学毕业之前就有了了解和一些想法的事情，但是从来没有想过会如此的难以实现和那么遥远。或许因为这一年疫情的关系，把我在国内“憋”坏的后遗症，让我在这年底这段时间，前所未有的把某些事情提到了如此高的高度。从9月中旬一时兴起决定报考N1，到现在有点迷茫，甚至思考，我的目标错了么，想要达到的目的是什么，想要得到的是什么，我想度过的人生究竟是什么样的，这些其实应该在一开始就想好的问题。或许是当局者迷，我一直没有想清楚这些问题的答案，也或许不需要清楚，因为人生很多事情或许就没有答案。喜欢无脑三分钟热度做事的我，似乎也就是这样，漫无目的的追求着看似虚无缥缈的事情。至于能不能成功，只能靠时间的检验了。下半年，我感受了我有着强烈的独立生活的愿望，和父母的沟通看来已经是断崖式下降，这或许是人生的必经之路，但也似乎有着什么没有被发现的契机。下半年也逐渐减少了SNS社交平台的发布，学会了精简自己的网络生活，取消关注了一大批公众号和换手机之后拿掉一大批app之后，感受到其实信息的收获确实需要精简。站在年底，我并没有强烈的感受到一年的即将结束，混乱的一年，令人抓狂的一年令我有点丢失了时间的观念。但这一年似乎也并不全是坏事，如果没有这一年，或许不会收获挚友、或许不会了解到自己的渺小、或许不会知道曾经习以为常的一切是如此的脆弱不堪一击。如果想要找一个词概括这一整年，我想会是改变。一些想法、思考、习惯因为人事物的深入了解已经发生了彻底的变化，有些已经有所感知，但更多的或许是潜移默化。改变，其实人也是无时无刻都在改变的吧。曾经沧海难为水，除却巫山不是云。365天的循环又将走到了新起点的开始，新的一年总想有着新的展望。但是，现在来看一年的期望或许有点长，因为人甚至不会知道下一秒会发生什么，更不要奢望一年内的事情都能顺心如意了。临近2021年的起跑线，现在望去，这漫长的隧道有没有看到了一丝光明呢？最后，一如既往的友谊地久天长！以上。记于2020年12月27日" }, { "title": "忙碌的一周", "url": "/posts/busyweektech/", "categories": "技术", "tags": "前端, React, 工作, 项目", "date": "2020-12-12 00:30:36 +0800", "snippet": "这一周我度过了可能是入职以来最“忙碌”的一周。一周工时长达了63小时。当然大多数的事情是因为自己在之前完成需求的疏漏，从而产生了如此的结果。这一周还是收获到一些内容的，例如做新需求的时候，学到了一些已经不算新但是好像是第一次付诸实践的东西。总结一下，以备后查。React Context 与 HooksReact在几年前引入了新的Context的使用方法，主要的组成部分为生成Context对象的createContext方法，以及其对应的Provider对象以及Consumer对象。这些其实都很简单，如果看官方文档的话能够解释的比我更清楚，所以引入一下连接 -&amp;gt; Context – React那么我想要总结的是，如何把这个Context和新的Hooks结合起来的话，会产生什么样的内容呢？首先这里Hooks，我们就用到了useContext这个。这个的作用其实就是用来替代Consumer这个东西的。我个人浅薄的认识，useContext和Consumer有这样的区别：useContext可以在“真实消费”的组件中使用，直接把需要的Context的内容引入，即可使用。而Consumer则有一种“高阶组件”的感觉，把原有的消费组件套入Consumer包裹的内容中，把高阶组件中的内容化为props传入原有组件，在原有组件中利用props来获取这个context因为useContext的内容获取的第一个参数是要用createContext的对象传入，所以需要有一个独自的组件export出这个，这样可以更好的做引用。落实到实际的项目中，使用一下useContext。let themeContext = createContext({});//及时exportexport {themeContext}/*其实可以直接吧&quot;.Provider&quot; 放到要用的地方，这样做可以动态变化Context。但是如果直接导出这个会导致性能问题，产生很多不必要的渲染.所以这里可以把利用props.children插入的方法优化性能，具体的原因前人之述备矣。*/function ContextProvier(props) { let [ themeContextState, setThemeContextState ] = useState({}); let value = {themeContextState, setThemeContextState} return ( &amp;lt;themeContext.Provider value={value}&amp;gt; {props.children} &amp;lt;/themeContext.Provider&amp;gt; );}/*useContext*/function useContextConsumer() { let { themeContextState, setThemeContextState } = useContext(themeContext); // 只要继续使用即可。 // 修改context的话？ 这样会重新设置Provider组件中的state，这样就会触发重新渲染。 setThemeContext({a: &#39;123&#39;}) return ()}其实用useContext很简单，但是这里想要特别说的其实是useEffect的坑。useEffect因为渲染机制的关系，那么useEffect这个里面的回调函数（setTimeOut, 事件回调等）所拿到的数据都是那一次渲染的数据，和context结合的话，如果set之后有了新数据，但是在回调中拿到的仍然会是上一次的数据。解决的方案，其实可能会有更优雅的方案，但是我所利用的或许是最原始的。利用useRef的current属性，这样才会拿到最新的值。举例：function withContextAndEffect() { let { themeContextState } = useContext(themeConext); let [ themeRef ] = useRef(themeContextState); useEffect(() =&amp;gt; { themeRef.current = themeContextState; }, [themeContextState]) useEffect(() =&amp;gt; { setTimeout(()=&amp;gt; { //如果有修改这里拿到的是最新的 console.log(themeRef.current); //这里还是会上次的 console.log(themeContextState); }, 1000) }, [])}这个坑其实很容易被识别，还是在这里记着了。Node同构我们的主项目是通过Node同构直出的，Node同构有很多的优势，例如减少首屏渲染时间，更好的支持SEO， 充分利用了服务器的性能。当然这里如果要说Node同构的优势就有点老生常谈了，这里讲讲Node同构所带来的一些不方便点。比如，一些需求中需要在给我们的后台服务拉取数据的时候，需要拿到用户当前的位置，那么由于有Node这一层的存在，我们就需要其他的第三方服务给我们拼接一些数据在链接后面才能给到后台。又如在编程写React组件的时候，需要注意到的不能够轻易使用window, navigator等只有在浏览器宿主中才能够获取到的对象。否则会导致报错，导致renderToStringError。如果没有很好的兜底的话，可能导致整个服务的崩溃。在利用Node时候，也要注意对服务器运行的稳定性以及要做好降级预案，否则会导致服务的不稳定。Node的导入让前端的性能可以进一步优化，首屏的体验会变得更好，但利用Node优势的同时也要主要到一些坑点。仅仅在这里有所记录。项目的全局观其实整个项目有着很多的功能，有时候不能想当然的把已经上线已久的服务作为稳定的依靠，在新添加功能的时候需要更好的了解老逻辑，老逻辑是否可靠，是否需要和它对齐来让整个功能才能正确使用，这个都是需要考虑到的，不能够只想到自己这部分的内容有着更好的方案，否则就会导致大问题。两年多来自以为对项目的业务层很了解，这次的问题让我意识到其实自己没有深入自己业务范围之外的内容，还是需要更全局的宏观观点。这样才能够更好的实现任务。一周的忙碌希望可以有所收获吧~" }, { "title": "React和它的小伙伴们(2) - Redux与状态管理", "url": "/posts/react2/", "categories": "技术", "tags": "前端, React, 源码", "date": "2020-11-22 15:30:36 +0800", "snippet": "Redux根据前一篇文章中最开始说的，React就是一个函数对应关系，那么相应的，如果作为一个大应用来说就可能有些状态是需要跨组件共用的，那么自然而然地就会想到用一个仓库来把它保存起来，这里就产生了Redux这个“思维模式”。Redux其实是一个可以脱离React使用的思维模式，这种方式具有四个想法： 提高修改数据（应用状态）的门槛主要就是引入action和dispatch两个方式来对全局的状态进行修改，而不是仅仅在每个组件内部进行修改和处理。 抽象出一个初始化的createStore方法，内部包含一个store，dispatch和getState三种方法。 加入订阅者模式来改变视图。（也就是subscribe方法） 引入Reducer函数（纯函数）有了这四个想法，那么就直接来代码：）//初始化的createStore创建全局状态集方法function createStore(reducer) { //store中的state let state = null; //存储所有的监听事件 const listners = []; //添加订阅者 const subscribe = (listner) =&amp;gt; listners.push(listner); //暴露给外部获取状态 const getState = () =&amp;gt; state; //暴露给外部根据初始化传入的reducer方案进行修改状态 const dispatch = (action) =&amp;gt; { state = reducer(state, action); listner.forEach((listner) =&amp;gt; listner()); } //初始化操作（reducer中switch的default事件） dispatch({}); //暴露给外部的所有方案 return {getState, subscribe, dispatch};}//使用方案function reducer(state, action) { /*初始化state以及定义本store所需要的action*/}//调用初始化方案进行创建Storelet store = createStore(reducer);//将重新渲染视图这个时间加入订阅者中store.subscribe(() =&amp;gt; renderApp(store.getState()));//根据初始化的state，初始化ApprenderApp(store.getState());//需要更改状态时，使用这个store.dispatch(action);React-Redux下面要做的就是将Redux与React连接，那么如何将一个全局的State分发到所有的组件中呢？初步考虑：把这个组件状态放入全局可以获得的Context中，并且向下传递。那么这样的方案会带来两个问题： 有大量的重复逻辑 -&amp;gt; 每个组件都要取出context， 从中取出需要的store中的state 对context的依赖性过强 -&amp;gt; 如果这个组件需要跨应用复用就难以为继了。真正的框架中，使用了高阶组件的方式来解决第一个问题。那么第二个问题就是尽量使用dumb组件（类似于纯函数），这样仅仅依赖于props来渲染组件，提高组件的可复用性。那么具体是如何实现的呢？Code please://connect函数首先接收两个map对应的方法，并且返回一个接收需要被包装组件作为参数的包装方法，并且return出去//比如C组件，需要包装的话，调用方式为connect(mSTP, mDTP)(C);export connnect = (mapStateToProps, mapDispatchToProps) =&amp;gt; (Wrapped) =&amp;gt; { export Connect extends Component { static contextTypes = { store: PropTypes.Object, } constructor() { super(); this.store = {allProps: {}}; } _updateProps() { const {state} = this.context; let stateProps = mapStateToProps ? mapStateToProps(store.getState) : this.props; let dispatchProps = mapDispatchToProps(store.dispatch); this.setState({allProps:{...stateProps,...dispatchProps, ...this.props}}); } render() { return &amp;lt;Wrapped {...this.state.allProps}/&amp;gt; } } return Connect;}那么接下来来看重要附加内容，两个参数： mapStateToProps: 或得到的Props如何对应到数据结构中（本组件的状态存储） mapDispatchToProps： 如何修改state的dispatch方法（自定义）那么最后一个问题就是怎么样分发这里的状态呢？整合Context， 在最顶层给出一个Provider组件，它就是一个容器组件, 会把嵌套的内容原封不动作为自己的子组件渲染出来. 它还会把外界传给它的props.store 放到 context, 这样子组件 connect 的时候都可以获取到.Let’s see itclass Provider extends Component { static propTypes = { store: PropTypes.object, children: PropTypes.any } static childContextTypes = { store: PropTypes.object } getChildContext () { return { store: this.props.store } } render () { return ( &amp;lt;div&amp;gt;{this.props.children}&amp;lt;/div&amp;gt; ) }}/*在需要使用Redux的地方套用这个Provider组价最为根节点，这样connect函数获取到的props内容就都是这里拿到的store*/以上就是React中对于状态管理的Redux方案。当然这里也就只描述了ClassCompnent情况下的内容，如果使用Hooks的话，对于状态管理其实也大同小异。这个话题可以留待下次讨论~。修改的方式有了，那么如何获得数据对其进行修改？如果在变化视图之前需要进行一些其他的操作呢？那就需要下一次讲到的中间件的登场了。本系列未完待续。" }, { "title": "React与它的小伙伴们（1）—— React", "url": "/posts/react1/", "categories": "技术", "tags": "前端, React, 源码", "date": "2020-11-21 01:40:36 +0800", "snippet": "几个月前，机缘巧合，跟着几篇博文对于React、Redux等技术做了一些更深层次的了解。在此，特别整理一下汇整成笔记。前人之述备矣，这里也仅仅只是汇整，所以大佬们可以跳过啦。当然也欢迎挑刺问题。不正之处，敬请指出。~一天肯定是写不完了，还是分系列完成吧。今天是第一部分。React首先，从React开始。React作为一个当前流行的前端框架，从使用上，API的调用，生命周期的流转，作为一名前端工程师来说相信都是十分了解和完备的了。但有时候确实也会想要钻研一下，内部的实现逻辑。这时候就要去看看源代码啦~。（下面的内容，主要为这篇文章的摘要笔记，基本省去了看代码的环节，详情可参考这篇好文 -&amp;gt; React技术揭秘（文章内容已经比我几个月前看要详细不少了））React的设计理念七个字就能概括，速度快，响应自然。当然如果从数学的角度来看，也就是一个y=f(x)的对应关系。视图y根据状态x的变化而变化。从jQuery直接操控DOM的方式解放出来。个人理解，其实说到底React所做的就是完成y=f(x)中f的变化映射关系。也就是把想要的视图和所拿到的数据进行连接的工作。React架构的演变历程 —— V15之前在ReactV15版本重构之前的架构可以一览如下。Reconciler（协调器）-&amp;gt; 找出变化的组件Renderer（渲染器）-&amp;gt; 将变化的组件渲染到页面上流程为：用户出发update =&amp;gt; Reconciler =&amp;gt; Renderer接下来，就来详细看一下这两个组件干了些什么，以及为什么会被重构的原因。构成 Reconciler：当有更新发生时（this.setState、forceUpdate、render等可出发），这个部分组件完成以下工作：a. 调用函数组件，或class的render方法，将返回的JSX内容转化为虚拟DOM结构。b. 对比上一次生成的DOM结构c. 找出要被更新的DOM结构d. 通知renderer组件更新到页面上。 Renderer：这部分其实根据React运行环境的不同，React将其拆分出了几个部分。如果宿主为浏览器，那么进行这部分工作的为ReactDOM，App原生组件的话是ReactNative，如果为测试环境或者canvas环境也有着各自的渲染组件。这些渲染组件的存在，使得React可以用同一套理念进行不一样端的渲染，减少开发的工作量。 这个部分的作用其实就一句话，接收上一层Reconciler的通知，把视图更新到宿主环境即可。此架构的缺点Reconciler中，被mount的组件会调用mountComponent、被Update的组件会调用updateComponent，这样产生的后果就是会递归更新子组件。递归更新子组件的话，因为大多显示器的展示帧率为60Hz，且JS的计算运行线层与渲染视图是互斥的，那么递归深度过沈的话，就会导致部分UI的更新不完全，产生业务上不必要的困扰。那么新的架构是如何解决这个问题的呢？React架构的演变历程 —— V16及之后新的架构引入了一个新的组件，称之为Scheduler（调度器），顾名思义，这个是用来调度任务的优先级的组件。其余的两个部分还是和之前的一样，是Reconciler和Renderer。构成那么主要来看一下这三个部分分别做了些什么事情。首先是新引入的Scheduler组件。 Scheduler：主要任务就是判断当前更新工作的优先级，进行调度。部分浏览器已经实现了一种名为requestIdleCallback的机制，来让我们可以从浏览器知道是否有剩余时间作为任务中断的标准。但是，虽然部分浏览器已经有这个回调函数功能，但是因为兼容性以及触发概率不稳定等原因，React并没有采取这个，而是亲自实现了这个可以独立于整个React框架使用的Scheduler库。 Reconciler协调器当然也有变化。根据之前版本的痛点，把更新的过程，从递归变化了可中断的循环过程。每次循环都会以调用shouldYield作为标准来判断当前是否有剩余时间。 那么React16是如何解决中断更新时DOM渲染不完全的问题呢？在React16中，Reconciler与Renderer不再是交替工作。当Scheduler将任务交给Reconciler后，Reconciler会为变化的虚拟DOM打上代表增_删_更新的标记。只有当所有组件都完成了Reconciler，才会将其交给下一步的render。所以，如果上一个渲染被高优先级任务打断了，那么这个被打断的流程也不会走到render上，让用户看到错误的数据。这个部分中采用了Fiber架构 Renderer这个部分并没有什么过多的变化，同样是根据上一步给出的虚拟DOM标记，同步执行用户界面的渲染工作。FiberFiber何许人也？也就是React16之后内部的虚拟DOM结构。为什么要有Fiber？ 因为之前的虚拟DOM结构适用于递归寻找更新，由于递归有可能很深，造成用户界面卡顿，所以转化了为了循环。为了适应这个可中断循环，那么就要对内部的虚拟DOM结构进行改造。 作为静态的数据结构来说，每个Fiber节点对应一个React element，保存了该组件的类型（函数组件_类组件_原生组件…）、对应的DOM节点等信息。 作为动态的工作单元来说，每个Fiber节点保存了本次更新中该组件改变的状态、要执行的工作（需要被删除_被插入页面中_被更新…）。 Fiber树的双缓存双缓存？ 在内存中构建并直接替换的技术叫做 双缓存 (opens new window) 。React使用“双缓存”来完成Fiber树的构建与替换——对应着DOM树的创建与更新。React在构建中最多同时有两棵Fiber树，一个对应着当前的视图结构（current Fiber），一个对应着之后将要变化到的结构，也就是正在构建中的（workInProgress Fiber）。 每次状态更新都会产生新的workInProgress Fiber树 ，通过current 与workInProgress的替换，完成DOM更新。Fiber树的构建替换流程这里考虑的是这个简单的React组件。function App() { const [num, add] = useState(0); return ( &amp;lt;p onClick={() =&amp;gt; add(num + 1)}&amp;gt;{num}&amp;lt;/p&amp;gt; )}ReactDOM.render(&amp;lt;App/&amp;gt;, document.getElementById(&#39;root&#39;));Render时 首次执行ReactDOM.render时，会创建一个fiberRootNode和rootFiber。其中前者是整个应用的根节点而rootFiber是所在组件树的根节点。Why区分？因为应用中可以多次调用ReactDOM.render来渲染不同的组件树，但是整个应用的根节点只会有一个。那么fiberRootNode的current指针就会指向当前已经渲染内容的Fiber树，这个就被称为current Fiber树。 接下来进入render阶段。根据组件返回的JSX在内存中创建Fiber树，并且构建成workInProgress树，这个树会尝试复用current中的Fiber元素，作为alternate的智者。 构建完成的workInProgress Fiber树将会在commit阶段渲染到页面中。 Update时 用户触发了改变，这样会启动一个render阶段并构建新的workInProgress树。和amount时候一样，这个fiber的创建可以复用数据，也就是alternate的节点。（判断是否可以复用，就要用到之后的diff算法） workInProgress树在render阶段完成以后在commit之后渲染到页面上，同时变为current树。 大致的流程就是如此，那么每个Fiber节点是如何创建的呢？请继续往下。React构建Fiber树（render阶段）React构建Fiber树是通过深度优先遍历进行的。主要的流程是：beginWork =&amp;gt; reconcileChildren =&amp;gt; completeWork （根据深度优先遍历进行迭代，直至最终结束）beginWork该方法根据传入的Fiber节点创建子节点，并将这两个节点连接起来。这个方法的三个参数为：current，workInProgress以及renderLanes。作用分别为对应节点上一渲染的结果，当前组件对应的Fiber节点以及优先级相关内容。并且可以通过current是否为null来进行区分是mount阶段还是update阶段。这两者的区别在于，如果是update，那么就可以尝试复用current来优化，克隆current.child作为workInProgress.child，而不需要重新创建。而mount时候则根据不同的fiber.tag来创建不一样的子fiber节点。update时候有两种情况可以直接使用： oldProps === newProps &amp;amp;&amp;amp; workInProgress.type === current.type， 即props与fiber.type 不变 !includesSomeLane(renderLanes, updateLanes) ，即当前Fiber节点优先级不够。mount时，也就是当不满足优化路径是，则要新建子Fiber（fiber.stateNode === nul，且接下来的步骤中不会赋值effectTag，而根节点拥有）。根据不一样的Fiber类型（FunctionComponent，ClassComponent， HostComponent），进入到最核心的reconcileChildren方法。reconcileChildren对于mount来的，创建新子Fiber节点。对于update来的，进行diff算法，对应比较上次的Fiber和这次的更新，将比较的结果生成Fiber子节点。无论是哪一种方式，都会生成新的子节点作为本次beginWork的返回值，作为下次workInProgress的传参。通知Renderer进行更新的两个条件： fiber.stateNode存在。 fiber.effectTag存在。何为effectTag？effectTag就是用来告诉renderer执行DOM操作的具体类型。利用二进制数据表示。那么既然mount阶段没有stateNode和effectTag，首屏渲染的完成是如何完成的呢？其中fiber.stateNode将会在之后的completeWork中创建。而后一个effectTag的问题，mount时候只有第一个root结点会有effectTag，那么整个树只要在执行一次插入的DOM操作即可。completeWork这个部分接收三个参数，和beginWork同样，并且针对不同类型的fiber会有这不同的处理逻辑。这里的主要工作分别是处理一些props内容，并且对已经存在Fiber结点进行一些更新处理或者回调函数的注册。effectList其实整个render阶段的工作已经接近完成了。那么在之后commit阶段如何避免再次对Fiber树进行递归寻找effectTag不为null的节点呢？这里，React在completeWork的上层方法completeUnitOfWork中，每个执行完成的completeWork且存在effectTag的Fiber节点会被保存在effectList的单向链表中。那么之后的阶段只要对这个链表进行遍历就可以执行完所有的effect了。 借用React团队成员Dan Abramov的话：effectList相较于Fiber树，就像圣诞树上挂的那一串彩灯。React进行渲染（commit阶段）commit阶段的起点，就是调用commitRoot方法，并且传参root这个结点。这个里面包含了rootFiber.firstEffect，也就是上面提到的单向链表的起点。在commit阶段做的工作是副作用对应的DOM操作，部分DId系列生命周期钩子以及hook的useEffect都需要在这个阶段进行执行。那么整个commit阶段分为三个部分，分别是before mutation（执行DOM操作前）、mutation（执行DOM操作）、layout（执行DOM操作之后）在before之前和layout之后其实还有一些例如useEffect的出发，优先级相关的充值以及ref的绑定等。before mutation之前主要完成一些变量赋值，状态重置的工作。主要还是最后的firstEffect的赋值。layout之后包含三点内容: useEffect的处理、性能追踪相关以及生命周期钩子函数的触发。before mutation概述就是遍历effectList，并调用commitBefore MutationEffects方法进行处理。这个方法大致可以分为三个部分： 处理DOM节点渲染、删除之后的autoFocus和blur逻辑 调用getSnapshotBeforeUpdate生命周期钩子这里提出的问题，为什么在重构之后，will系列的生命周期加上了UNSAFE前缀。主要原因就是前一个render阶段可能会中断或者重新开始，那么在render阶段调用的will系列生命周期钩子就有可能触发多次。为了解决这个问题，React给出了getSnapshotBeforeUpdate。在commit阶段进行调用因为是同步的就可以避免多次调用的问题。 调度useEffect（流程有点复杂，可以参考原文 -&amp;gt; React技术揭秘）useEffect的调用是异步的。为什么要异步？ 与 componentDidMount、componentDidUpdate 不同的是，在浏览器完成布局与绘制之后，传给 useEffect 的函数会延迟调用。这使得它适用于许多常见的副作用场景，比如设置订阅和事件处理等情况，因此不应在函数中执行阻塞浏览器更新屏幕的操作。 可见，useEffect异步执行的原因主要是防止同步执行时阻塞浏览器渲染。mutation同样是遍历effectList链表，并执行commitMutationEffects方法，主要进行了三个操作： 根据ContentReset effectTag重置文字结点 更新ref 根据effectTag分别处理（DOM的增删改等操作）effectTag的处理主要是以下几种 Placement类型： 该Fiber结点对应的DOM结点，需要插入到页面中，首先获取父级DOM结点，其次获取兄弟DOM结点，最后根据DOM兄弟结点是否存在来决定是否调用parentNode insertBefore或者parentNode.appendChild来进行DOM的插入操作。 update类型： 说明该Fiber结点需要更新。根据fiber.tag分别处理。Function的话调用useLayoutEffect这个hook的销毁函数（return出来的函数）。Host类型的话就调用commitUpdate deletion类型：需要从DOM中删除，调用的方法是commitDeletion。做的操作是递归调用Fiber结点和子孙结点中fiber.tag为ClassComponent的componentWillUnmount生命周期，并且从页面中移除DOM，其次解绑ref，最后调用useEffect的销毁函数。layout阶段该阶段触发的生命周期函数以及hook已经可以访问到改变之后的DOM了。layout阶段同样需要遍历effectList，这里执行的就是commitLayoutEffect方法了。主要做了两件事 commitLayoutEffectOnFiber（调用生命周期钩子和hook的相关操作）对于Class组件，会通过current是否为null来决定调用DIdMount或者是DidUpdate.setState的第二个回调函数参数，也会在这里被调用（所以里面拿到的state数据已经是新的了）对于Function的组件，会调用useLayoutEffect的回调函数，调度useEffect的销毁与回调函数，useEffect将会在layout结束以后异步执行。对于HostRoot，如果有第三个回调函数，也会在这时候被执行。 commitAttachRef（赋值ref）这个很简单，获取DOM实例，并且绑定到ref上最后，双缓存机制需要把结束的工作挂载到current上。而root.current = finishedWork 这行代码是在mutation结束后，layout前执行的。Why?我们知道componentWillUnmount会在mutation阶段执行。此时current Fiber树还指向前一次更新的Fiber树 ，在生命周期钩子内获取的DOM还是更新前的。componentDidMount和componentDidUpdate会在layout阶段执行。此时current Fiber树已经指向更新后的Fiber树，在生命周期钩子内获取的DOM## 就是更新后的。最后的总结，其实commit的三个阶段就是在三次遍历上一个render阶段生成的effectList，并且根据这个list来对DOM进行操作，将数据驱动到视图上。这个effectList的生成，其实规避了commit阶段三次对Fiber树的遍历，优化了性能。DIff算法这里只简单概述。这里需要完成的内容就是DOM结点是否可以复用的问题。根据Fiber的children的类型不同可以分为单节点diff和多节点diff主要的流程：1 看key是否相同2 key不同，直接不复用。3 key相同，如果type相同那么复用，如果type不同，那么久不复用。状态更新可以出发React状态更新的主要有几种方法：ReactDOM.render、this.setState、this.forceUpdate、useState以及useReducer.React通过创建一个Update对象，在render阶段的beginWork中根据这个对象来计算新的state。关键节点：触发状态更新 -&amp;gt; 创建Update对象 -&amp;gt; 从Fiber到root(从触发状态更新的fiber一直向上遍历到rootFiber，并返回rootFiber。) -&amp;gt; 调度更新（Scheduler的工作） -&amp;gt; render阶段 -&amp;gt; commit阶段。关于优先级：（具体：React技术揭秘） 生命周期方法：同步执行。 受控的用户输入：比如输入框内输入文字，同步执行。 交互事件：比如动画，高优先级执行。 其他：比如数据请求，低优先级执行。" }, { "title": "放弃的艺术", "url": "/posts/abandon/", "categories": "个人杂记", "tags": "考研, 心路历程", "date": "2020-09-16 20:12:36 +0800", "snippet": "“这篇文章或许是一篇记录文，一篇流水账。但是也夹杂着一些人生感悟，可能不是什么好方向，可能有很多人不会认同我的想法，但是希冀可以互通有无吧。\\n一切的开始源自于2019年2月的一个决定。那一天，为了给自己的未来找点什么事情做做，选择了考研试试。其实那个时候我并没有意识到自己能够坚持下来整个流程。考研准备的哪一年，说起来也没有什么特别花精力，抱着就像试试自己水平的心态参加了考试。数学应该是其中我认为最有趣的一门功课，也是我最花心力的一门课程。接近一年的时间我所有的可以动用的复习时间都花在了准备数学一的考试上。报名的时候，没有犹豫，要考就要考最好的心态继续左右着我的选择（我感觉我经常有着莫名的自信）。报考了交大的非全日制（根本没想过全日制，不能接受脱产了），挑战的科目也是计算机考研中的魔鬼配置——数学一英语一加408。当然考试之后的成绩并没有像一开始准备考试的时候那样完美。数学没有及格，只准备了两个周末刷完历年选择题的408考试当然也不可能及格（其实只差一分的成绩我已经很满意了）。反倒是没有准备的英语给了最大惊喜，成为了几门中的折算最高分。疫情的关系，其实考完笔试就感觉到自己根本不可能考上交大，但是国家线肯定是稳得，也就很坦然根本没有怎么想这个事情。看到成绩其实感觉还行，完成了预期的目标，很明显301分刚刚及格的成绩除了接收调剂的非全，哪里也去不了。华东师范大学其实从高考开始就是憧憬的目标，在考研的一路上其实也是作为调剂对象的目标。当开放调剂之后，也就理所应当的报名了。当然，在调剂之前也是有一番犹豫，是就此放弃，还是继续走下去完成初试和复试，最后选择了后者，选择了调剂。调剂的面试其实也很水，当时调剂报名了计院和软院的两个学院。当然，计院率先开始了面试，被排在了一组中的最后一个，等了好久才轮到我。疫情关系，成为了线上面试。说实话，我是一点都没有准备就准备瞎扯凑满时间了。英语部分其实还蛮顺利的，但是由于很久没有用英语说话了确实有点不流利。到了专业部分就是一脸懵逼，一连两道我现在都记不起来题目的专业问题完全答不上，教授引导到的本科知识我感觉我也回答的并不是很正确。然后教授就放弃专业问题开始闲聊工作。其实这里就已经有了第一次警钟，说论文的问题，但是我也就一番糊弄说了一点高大上的东西就感觉自己能够完成。面试其实很快就结束了。考完之后其实我认为根本不可能过，因为参加面试和最后的录取率大概也有百分之10-20的淘汰率了。学院的效率确实很快，当天晚上就出了结果，我其实根本没有想到会成为调剂复试的第一名进入了拟录取名单。当天晚上其实也没什么激动，很平淡的一天。当时天真的想象，认为考上了就能毕业，直到新生报到的那一天。其实说实话，中间有没有过犹豫。是有的，在交学费的那一天晚上，我也想过一点要不要交，但是实在因为缺乏了解，所以也就交了。（也为了能够参加新生报到）\\n在中间有非全的同学加了微信，并加入了班级群。说实话我对他们的谈话内容确实有点嗤之以鼻，我承认我带有了一股不知道哪里来的优越感来看他们的对话。当然可能也与我想要“水”一个学历的心态有关系。那些同学的言语似乎都有点幼稚，让人感觉不是一个研究生的语言体系和提问水准。时间很快就到了上周六。9月12日。阔别校园几年后的我重新回到了校园，看到了春风满面刚刚入学的本科生，看到了家长对学生的殷切希望，一切是那么的熟悉但又感觉离自己有点遥远。下午的新生见面会是我焦虑的开始。院长一开始就开始说要非全的研究生进组研究，不能混学历。其实这也是我最初最担心的这一点，工作的高强度其实根本没有余力能够完成这些任务。然后后面紧接着的各种团队介绍也让我应接不暇，感觉没有一个团队会适合一个web前端的人。高大上的知识看起来很牛逼，但其实选完导师之后，放养式的管理根本没有机会接触到它们，最终还是要靠自己。不仅仅是这个宣讲会，大家的耳语也让人心生退意。在周日的晚上加入了一个包含学长学姐的大群，看到了他们的忿忿不平，看到了他们口口相传的20%的毕业率，无不增强了我的焦虑。其实从周六下午开始我就开始陷入了人生25年来最严重的焦虑之中，对于未来的迷茫和未知的一切感到了陌生和担忧。读还是不读成为了一道决定人生走向的选择题。这道选择题摆在任何人面前或许都值得纠结一番。走下去，得到的会是一张毕业证书和一张硕士学位证书，得到的会是三年的含辛茹苦，得到的会是一些这辈子可能就写论文时候会用到的知识（因为这些知识根本不可能去和全日制学习的人比，去获取工作岗位），得到的更是一个自我满足感和虚荣心，获得了和别人内心攀比的资本。选择放弃，放弃的不仅仅是一个硕士学位，放弃的是过去一年的努力，放弃的是未来可能对于学历要求岗位的机会。\\n孟子有云，鱼与熊掌不能兼得。两害相较取其轻，我进入了好几天的漫长思考。当然也要感谢各位在这几天中给我思考建议和人生哲理的好朋友、好同事、好同学们，这些建议都成为了我做出决定的因素。也让我尽快做出了一个决定。放弃。放弃两个字说起来简单，但是作出决定并不容易。我周六晚上其实感觉还能咬咬牙坚持一下，在twi上连发了两篇短“檄文”，在ins和各种社交平台上收到了鼓励的言语，给我带来了一丝对于未来光明的憧憬，在此感谢，也要十分抱歉，让大家失望了。一切的翻转从周一开始。我开始焦虑是不能够工作和学习两者兼顾，看到了那些同学们开始纷纷讨论起了脱产，学长们也纷纷表示很难毕业。没错，我开始打起了退堂鼓。退出很容易，但是做出决定的那一瞬间，其实需要很多参考。周一的一天过得有点浑浑噩噩，其实在微博上也发了很多的东西，每次心烦意乱的时候总有无尽的表达欲，但是其实有无法真正触及最本质的那个问题。当时在纸上，列出了两条路的所有可能和权衡利弊。流程图，或许是理科生梳理和解决问题的最好用的方法。退出的决定很快在周二晚上就成为了我内心的选择，彻底推翻了两天前硬打起的勇气。因为我感觉我的内心已经产生了强烈的抵触情绪，看到微信群的聊天窗口就下意识的焦虑，我认为这样走下去三年或许也是对心理的一种极大伤害和压抑，简而言之，如果走下去三年内不是被课业压力逼疯，就是被搞不出来的学位论文整垮。\\n长痛不如短痛。我选择了在第一年还没有开始的时候“止损”。这或许是个明智的选择，也可能是个这辈子最愚蠢最让我后悔的选择。但这一切可能也就只有时间才能够证明对错。算法常常难以得到全局最优解，但是如果能得到局部最优，虽然最终的结果可能也是不尽如人意，但是概率上来说总是最棒的选择。我在人生的当下，选择了这个局部最优解。做完选择之后，今天看到了各种关于非全社会认可度，以及一些同学要脱产和努力学习的宣言，心中其实只能感叹，人各有志吧。而我只想追求一个随遇而安。“既自以心为形役，奚惆怅而独悲”。这句在我高中作文中被用烂的话我又想拿出来讲了。或许硕士学位能够证明一些事情，但是人生的学识素养绝对不是一个文凭能够证明的。当然我知道在这个学历第一的社会里，这样的论调会显得格格不入，但是这或许就是我内心的想法吧。在别人看来，我这样的放弃会被人嘲笑，被别人认为怂，被误解半途而废。但是，自己的人生或许总需要自己来定义吧。今天，周三，我似乎开始明白自己想要的是什么，想要努力的方向是什么以及对于未来的生活的憧憬。当然其实也有一点瞎试验的成分，我自己都不认为在熬完三年研究生都没有信心的我能够达到这个目标。不过敢想敢干吧，走一步看一步，用这个局部最优的理念来度过这绝无仅有的人生。其实2019年的2月我根本不会想到我有一天会这样纠结于这个问题，一路走来考试的准备其实没有那么惨烈和难以维系，但是最后的一里路，我做了一位“逃兵”，成为了一位没有自信心的学生。时间总会证明一切的对错，不过既然想好了目标就要一步一步往前走。就像一年半前的自己一样，开始筹划下一场旅行，下一个挑战，下一个人生战场。关关难过关关过，是美好的愿望。人类的悲欢或许总是不能那么的想通，不妨可以考虑，如果是你你会选择什么？最后， 戒慎恐惧，勿忘在莒。 矢勤矢勇，必信必忠。一心一德，贯彻始终。以上。 就是来自一个经常放弃的人的自辩。 2020年9月16日”" }, { "title": "2020读书记#12 抗战的金融史", "url": "/posts/2020book12/", "categories": "读书记", "tags": "抗战, 近代中国, 读书, 金融", "date": "2020-06-19 20:12:36 +0800", "snippet": "《抗战外援 1937-1945年的外国援助与中日货币战》推荐指数 四颗星难得有书讲述抗战时期的金融经济情况以及外国援助的情况。本书主要分成了两个部分，第一部分是1937到1941年中国独自面对日本抗战以及1941到1945年美国加入太平洋战争之后。前半段，美英苏等列强对于日本的侵略在德国开战之前采取了隔岸观火的状态，自己在中国的利益收到损害之后才会出手扶助国民政府，采取了租借法案以及各种条约借款中国抵抗日本的货币战，维护法币的币值以及中国抗战的物资经济需要。而到了1941年太平洋战争开始以后，美国加入了二战，面对国民政府蒋委员长的5亿美金的无条件借款以及日本在战争前期的节节胜利，由于不了解中国不会放弃抗战的决心，相信了蒋方面的外交辞令（如果不借款就和日本讲和），答应了各方面的借款要求。但是面对战争时期的通胀，由于国民政府的通胀处理的不当，发行公债的策略不当，滥发纸钞以及日方对于伪币的推行，通胀日益加剧，但是固定汇率的试行，黑市交易繁盛，更加剧了通胀，为了解决通胀，国民政府开始出售黄金储备，为了稳定币值，并向美英等采购（要求援助）黄金，但是也没有发挥左右，通胀仍然随着战争的继续而继续。在战争的末期，经济局势日益混乱，当然援助也并没有及时到位，美国方面对于中国的复苏计划也莫衷一是。抗战的末期各种局势更加加剧了混乱。这本书结构清晰明确，不过有些翻译稍稍有些晦涩，需要一些的金融专门知识，否则需要花点世界理解为什么这个政策会产生这样的结果。后面的三个附录也是不可多得的历史材料。就是编辑有些粗心。有一些错别字的错误，看到两次大平洋战争。以上。" }, { "title": "关于video元素的种种", "url": "/posts/videotag/", "categories": "技术", "tags": "前端, 视频元素, video", "date": "2020-05-10 20:12:36 +0800", "snippet": "看起来已经很久没有写技术方面的文章了，今天就来记录一下最近经常打交道的一个html元素——video。说起video元素，是html5中新加入标准的“新兴”元素，基本目的是用来取代flash插件，以弥补html中关于多媒体的弱项。（一起被带入的当然audio元素）。P.S 经过了那么多年，Chrome似乎终于会在这几年不再支持flash。。不过，新元素总不是那么的完美。各个浏览器的厂商总有着自己奇奇怪怪的想法，最终导致的就是前端的晕厥。（如果所有的浏览器都能像Chrome那样完美那该多好啊。。）那么。进入正题。看看关于video兼容性的那些坑。以及一个小小的目标。今日的目标gif图。大家最喜欢的表情包就是这个格式，他能循环播放几帧动画。那么，同样的工作用视频不是也能完成么？看起来似乎很简单。じゃ　やりましょう！跟随本心一顿操作后，发现我们能不能换还是用gif呢？（关于视频用作动画图像为什么比gif更好，Apple公司给出缘由，同样的动画，MP4的视频所占用的带宽比gif图更小，占用的内存等资源也比gif更优。也就是这个原因。iOS从iOS 10开始放开了视频的各种限制，比如自动播放等。 But the GIF format turns out to be a very expensive way to encode animated images when compared to a modern video codec like H.264. We’ve found that GIFs can be up to twelve times as expensive in bandwidth and twice as expensive in energy use.参考webkit官方文档：New video Policies for iOS (WebKit)最初的最初让我们引入一个video元素作为本文的主角。so easy的代码&amp;lt;video class=‘video_area’&amp;gt; &amp;lt;source src=&#39;&#39; type=&#39;video/mp4&#39;/&amp;gt;&amp;lt;/video&amp;gt;当然如果嫌麻烦，而且只有一个源，不需要兜底的话，直接写成这样也是ok的&amp;lt;video class=&#39;video_area&#39; src=‘’/&amp;gt;这样今天的主角就是这个video元素。后面的所有都会围绕这个展开。如果这个放在浏览器器中查看的话，可以看到各家浏览器厂商自己的原始想法。比如弹出播放，直接全屏播放，给出一个播放按钮等等。后面要做的就是慢慢统一这个百花齐放的局面。。。。。让他循环？静音？这些都是最简单的操作，各家也很好的遵守了这个规范，只需要在video元素上默默的加上这两个标签（muted，loop）即可。&amp;lt;video muted loop class=&#39;video_area&#39; src=‘’/&amp;gt;这样，视频就会静音循环播放。自动跳出全屏？浮出播放？这是个令人头疼的问题，有些安卓厂商的web内核，总喜欢接管video元素的播放，让他全屏，浮到最上层，让他变成fixed布局的感觉。（摊手。。）。我们需要的是让他乖乖的在文档流里！找出文档，找到一个有用的标签，就是这个了！playsinline！&amp;lt;video muted loop playsinline class=&#39;video_area&#39; src=‘’/&amp;gt;于是我们开始一顿操作，发现在手机上并没有生效？？没事。继续加&amp;lt;video muted loop playsinline webkit-playsinline class=&#39;video_area&#39; src=‘’/&amp;gt;看起来似乎好点了。。。拿到微信一看。。。什么？！好像还不是自己想要的那种。。看起来微信的x5 webview也有着自己的想法。那么我们Google一下，发现好像stackoverflow的那些同学不怎么碰到这个问题（。。。）。中文博客给的方法好像也都不怎么有效。。这时候。还是回归官方文档吧。。参考这个：腾讯浏览服务-前端技术文档恩 这个元素很有效果，加入以后瞬间ok&amp;lt;video muted loop playsinline webkit-playsinline x5-video-player-type=&quot;h5-page&quot; class=&#39;video_area&#39; src=‘’/&amp;gt;不过暂时不知道这个对于x5内核的版本有没有什么要求。。这样做了以后，大多数的环境还是ok的，安卓各种各样的原生浏览器除外。厂商太多太杂。顾了东面没了西面。如果有更好的方法，欢迎交流~自动播放？我好好一个动画，用户点击了才能看？这样估计是不行的，做点处理吧。这样&amp;lt;video muted loop autoplay playsinline webkit-playsinline x5-video-player-type=&quot;h5-page&quot; class=&#39;video_area&#39; src=‘’/&amp;gt;autoplay。望文生义，自动播放。这个标签各大厂商还是做得不错的。当然这里还是有一个坑点。坑点1 低电量模式原以为一切都是那么的顺利，直到广泛实验之后发现了两台iOS13的手机死活没法自动播放。连接Mac的Safari说是allow error。这次stackoverflow的回答千奇百怪五花八门。始终没找到好方法。然后搜索iOS13的新功能的时候，发现省电模式的介绍。。。恍然大悟，关掉低电量模式，果然可以自动播放了。原来打开了iOS的低电量模式以后，iOS就自动屏蔽了视频的自动播放，一定要用户有所操作。那就只能接受，从控制台的报警来看，这个play()这个方法竟然是个Promise。播放的时候就是pending，如果拒绝自动播放的话，就会给一个rejected的状态。知道了这个。（机智的）前端们：“那我们就给个虚拟按钮的点击不就好了？”(当然，如果要做这个的话，要在页面加载完的回调里手动触发play()方法，也是和autoplay一样的效果，这里暂且保留autoplay）试验如下&amp;lt;video muted loop autoplay playsinline webkit-playsinline x5-video-player-type=&quot;h5-page&quot; class=&#39;video_area&#39; src=‘’/&amp;gt;&amp;lt;div class=&#39;button&#39; /&amp;gt;(CSS省略） window.onload = () =&amp;gt; { let playPromise = document.getElementById(&#39;video&#39;).play();// 似乎有些地方play不会返回个promise if(playPromise) { playPromise.then( () =&amp;gt; {}, // 顺利播放的话就什么也不用做了 () =&amp;gt; { // rejected的话模拟点击一下 document.getElementById(&#39;button&#39;).click(); } ) } }然后发现。。。似乎iOS并不买虚拟点击的帐，所以这里唯一的解决方案就是。。。让这个按钮可视化让用户点击。。不过滑动等等操作也可以，一般用户无意识的操作scroll的时候出发这个其实也是ok。那这个如果rejected就展示button的详细代码就从略了。。基本和上面的差不多。控制条很碍事？干掉！其实干掉控制条还是很“简单“的，如果大家都按照规范的话，一句CSS足矣。.video::-webkit-media-controls{ display: none !important;}在电脑上其实效果很好了。但是，有些手机就是不怎么听话。还是会骄傲的展示进度条。。如果愿意裁切的话，其实可以通过CSS布局的方法把播放条很好的隐藏起来就行。但是这样终究不是很好。接下来，就要介绍我们另一位好伙伴，canvas出场！Canvas救场canvas就是一块画布，往上面填东西。既然video标签五花八门的事情那么多，那么我们就开动脑筋！把video上的东西画到画布上吧！（互联网上其实有很多这样的做法，可以解决很多事情，比如自定义控制条，不展示原始的视频啊等等，都可以通过这样的方式实现）简单的思路一个隐藏的video元素 -&amp;gt; 加一个定时器每隔一段时间把video元素的内容画到canvas上。仅此而已。接下来就是coding time！&amp;lt;video muted loop autoplay playsinline webkit-playsinline x5-video-player-type=&quot;h5-page&quot; class=&#39;video_area&#39; id=&#39;video&#39; onPlay={drawOnCanvas} src=‘’/&amp;gt;&amp;lt;canvas class=&#39;canvas_video_area&#39; id=&#39;canvas&#39;/&amp;gt;&amp;lt;div class=&#39;button&#39; /&amp;gt; window.onload = () =&amp;gt; { let playPromise = document.getElementById(&#39;video&#39;).play(); // 似乎有些地方play不会返回个promise if(playPromise) { playPromise.then( () =&amp;gt; {}, // 顺利播放的话就什么也不用做了 () =&amp;gt; { // rejected的话模拟点击一下 document.getElementById(&#39;button&#39;).click(); } ) } } function drawOnCanvas() { let ctx = document.getElementById(&#39;canvas&#39;); let video = document.getElementById(&#39;video&#39;); //每隔50ms把视频元素上的内容，画到canvas上 setTimeout(()=&amp;gt;{ ctx.getContext(&#39;2d&#39;).drawImage(video, 0, 0, width, height); }, 50); }这样，其实在大多数的环境中已经可以正常显示了。接下来要做的就是要让真实的视频元素隐藏掉。隐藏的方式有很多种，就不做介绍啦。不过，用fixed布局设置0的高度宽度似乎iOS的兼容性最好。还有一个小问题这个问题只是体验上的问题，就不详细贴代码了。（懒。。）在安卓手机上，这样的画法总会出现一闪而过的黑屏。体验上总不是很好，找了很多技术大佬的博客，发现这个回调方法确实还不错，而且效果还行。就是timeupdate这个回调。这个timeupdate会在播放的时候每隔一段时间调用一次。那么就只要在这个回调里判断，如果当前的播放时间已经是0.1s以后了，那么才把内容画到canvas上。这样就能解决一开始的黑屏啦。(需要一个判断的flag，只有在刚开始播放的时候才做，否则会一直调用这个方法，性能感觉会有问题）总结这几天糊这个也是花了很多时间，摸索，搜索前人走过的路。。这里其实也就是个方法的总结备忘。真正实现的过程中其实还会有这样那样的小细节需要去避开和解决的，这里也没有详细的列出（相信各位机智的读者碰到例如视频画到canvas上的比例问题，如何在视频播放前展示一张兜底图等等之类的小细节会处理的很好~）。这样的话，本文就到这里啦。希望下次写技术文章不会过很久。。。以上。2020.5.10" }, { "title": "2020读书记#5 国共二十五年", "url": "/posts/2020book05/", "categories": "读书记", "tags": "中国国民党, 近代中国, 读书, 国共关系", "date": "2020-03-15 23:05:36 +0800", "snippet": "历时两周，读完了这本八百多页的“巨著” ——《国民党的“联共”与“反共”》。不愧是大家杨奎松的作品，二十五年的恩恩怨怨，可以一看究竟。两边骨子里的基因决定了最后的成败。K就是一盘散沙，派系林立，以前这样，现在也是这样。C则正好相反。个人评分 五星。⭐️⭐️⭐️⭐️⭐️早期共产党从1921年几人创党之后，受共产国际影响较深，因此采取了加入国民党，支持孙中山先生联俄容共的想法，并且在国民党中央占据了一席之地。随着共产党方面在国民党中央的权势越来越大，以及孙先生的逝世，老国民党咽不下这口气，开始另组中央，后来的西山会议派从此发端。当时蒋中正只是黄埔军校的校长，在赴苏联考察之后对于共产党还有支持的心情，在黄埔中对于共产党也是赞赏有加，并且认为俄国之路是一条救国之路。孙逝世，蒋上台孙先生逝世之后，蒋中正因为与汪精卫等中央要员不和，并且因为中山舰时间开始对共产党有了敌意，并且影响了后来几十年他对共产党的看法。广州国民政府开始北伐之后，战事顺利的同时，蒋中正也开始对于汪精卫和共产党方面有了芥蒂。蒋在南昌之时，汪精卫和一些国民党看不惯蒋中正大权在握的中央常委在武汉复立中央，这惹恼蒋中正，是夺权行动，武汉方面在夺蒋之权稍显成功之时，联共的政策让后方经常罢工而政局不稳，经济捉襟见肘。时局的演变让武汉方面也追随南京的脚步转而清党，宁汉从分裂专向合流。南京方便从四一二就开始清党，但清党过于严厉反而转为白色恐怖。共党的赤色恐怖对上白色恐怖，让南京方面也软化调整。宁汉合流之后，共党问题从明面上的强力争斗，转为地下特务工作。CP在城市被南京方面追剿而转入农村，借蒋忙于处理中原军阀战局，轻视共党之时继续发展。国强共弱的战前时期随着张学良的东北易帜，中华民国南京国民政府完成了中华民国的统一。而共产党也在闽赣地区活动。随着中原大战的结束，国军主力开始剿共，第五次围剿使得共产党的红军开始长征，从东南之地转移到了西北地区。随着国军的大举进攻，但是因为张学良杨虎城通共，对共产党有恻隐之心，没有严格执行中央的剿匪政策，谋划对蒋中正的兵谏。西安之事过后，长达近半年的谈判，因为七七事变的开始，从原先的双方一步不让转到了双方各自软化，C方表面收编于K方，但与K方争取到了自己继续发展的根据动力。蒋方也接受表面上的合作，但与蒋从谈判一开始就想彻底解决共党问题的想法相去甚远。国共两党就因为七七事变的突然爆发，就草草开始合作，为后来的冲突埋下伏笔。CP在上世纪20-30年代，除了张某某的少年冲动为贵人之外，国际形势亦有利于CP在蒋某人的围追堵截下继续发展。抗战中国共旗鼓相当抗战中，国军作为抗战主力正面应敌，共产党的八路军和新四军主要是敌后游击。随着欧洲战场的开始以及日本闪电战的想法破裂，国共两党脆弱合作的矛盾也开始局部展现。国共小范围的争夺，使得蒋中正想把共产党军队全部调集到黄河北部，但是共产党阳奉阴违，因为其中的误会和摩擦，造成了皖南事变。这个类似于“下克上”事件的突然爆发，令蒋中正骑虎难下，只能强化对共党的态度。两党在重庆艰难进行着的和谈也陷入僵局。随着日本军对国军在战争后期的突袭，让国军的不堪一击展现在了共产党的眼前，共党开始抬高对国民党和谈的加码，不断对蒋提出的收编共产党军队员额数量讨价还价。战后两党的强弱交替随着抗战的结束，重庆和谈开启了两党边打边谈的序幕。双十协定这一纸协定并没有换来长久的和平。随着东北地区战胜接收问题，因为苏联占据东北，共党手握东北的最大筹码。因为蒋坚持要求东北接收必须有国军出面，这个最大症结是国共之后和谈的最大矛盾。在国共美的三方会谈下，蒋同意关内停战，但是东北主权不容共党侵犯为理由，不愿意结束东北战事。但是随着国内因为东北苏联打死中国人的事件发生后，举国爆发反苏运动，导致苏联倒向中共一边。最后国军出兵东北，并且军事上获得了一定的胜利，打下了四平，并且共党军队也受到了一定的损耗。中共在东北受挫后，因为国民党精锐部队大举开进东北关外，中共开始在关内开始战事，并且屡战屡捷。一方面在打，但是两方的和谈也并没有中断。但是随着战事的强弱转变，从国方主导逐渐转变为了共方主导 。这一个转折点在北平的和平接受。1947年国大选举，通过了中华民国宪法。宪法主要根据国共政治协商会议商定的宪草通过，但是共党因为国大需要重新选举为由，拒绝参加国大会议，而且批评国民政府单方面召集。1949年，蒋中正下野，李宗仁代行总统职权，白崇禧也对总统职位有着想法。带上中共，三方都在打着自己的算盘。李宗仁对于共产党的和谈条件讨价还价但是在蒋中正不列战犯名单之后做出了让步，但是最后关头还是没有签订最后的和平条约。随着大陆战事接连失利，国民政府播迁台湾。总结这本书，通过大约25年间的各项事件，主要以国民党或者说非共产党的角度来讲述故事，引用了大量对岸以及蒋中正日记的史料。可信度和可读性都很高。两党关系此起彼伏，一切皆有天定。在抗战以后，两党都对和平抱有希望，但是两党之间没有互信，导致政治协商会议的“政治民主化，军队国家化”这个目标没有得到实现。共产党的统治只是在国民政府实在太差，通货膨胀严重的情况下显得好，得到了当时的民心。国民政府后期政府失能，共党间谍横行，毫无机密可言。并且政令不畅，蒋一度认为战事顺利，剿共成功有望。胡宗南一部攻进延安之后，更加坚定的蒋的想法。但谁料到，进攻延安的消息早就被中共获知，胡部只是拿到了一座空城。迁台之前，大量军政要员见风使舵转向共党一边。总而言之，两党都标榜自己有着法统，站在人民一边。但是内战之下，人民总是最苦的。共产党从1921年开始历史就是割据一方的历史，一度被打的考虑二次长征进入蒙古只为和苏联有联系。只是国民政府的执政实在不力，让中国共产党找到了千年一遇的契机，通过战争赢得了全国政权。这本书详细刻画了中共和国民党在抗战中谈判的细节，如何讨价还价，如何保留谈判果实，确实是一本通过国民党方面了解这段国共史的好书。也可以窥到共产党本质的基因（发动民众，拉一方打一方转移焦点通过民众达到自己的目的）。" }, { "title": "2020读书记#4", "url": "/posts/2020book04/", "categories": "读书记", "tags": "袁氏当国, 近代中国, 读书", "date": "2020-02-21 00:03:36 +0800", "snippet": " 绝怜高处多风雨，莫到琼楼最上层。《袁氏当国》（这本书的名字已经进入黑名单了，不过图书内容本身就是删减版所以应该无虞）书摘前篇微博略有一二，原计划附图再摘两句。（很可惜，这两句和书的图片微博都不让上传）评鉴分：⭐️⭐️⭐️⭐️⭐️这本书从讲袁世凯来讲民初的混乱。袁世凯，在从小到大的历史教育中基本都是反面人物。这本书从另外一个角度来看袁世凯。袁这个手腕极高的人物，赌对了一辈子，最后被身边一小撮人“劝进”，落得个晚节不保。最后“他害了我”的遗言，他究竟是谁。袁世凯没有给出答案。清末民初，群雄纷争。KMT从刚创党就是内斗内行，外斗外行。为了限制袁世凯搞了一个纸糊的镣铐，用参政院妄想绑住袁世凯。袁世凯和孙中山二者又有何差异？孙在袁做万年大总统后跑去日本也搞了一个中华革命党，必须效忠领袖，效忠革命，搞一个中央集权的政党。 袁是个在朝的总统，其实他和在野的党魁孙中山搞绝对权力的想法，实在是殊途同归，一个铜元的两面。只是中山在野，心有余而力不足；袁氏在朝，因而他就不顾一切，讲独裁进行到底了。”国父孙中山在护国运动之前做了一个错误的武力解决宋教仁案的决定，为民国后期的历史发展留下伏笔。正如作者所言，袁世凯杀宋教仁是开了一个暴力解决的坏头，孙中山发动二次革命更是一个错误决定，不到几个月便失败草草收场。但历史不会负负得正，有了第一次 第二次便会有后来的第三次第四次。。这本书整体语言诙谐，给人欲罢不能的感觉。行文流畅，也有很多“笑点”，严肃中不失快乐。是一本好书。附两句书摘： ”胡适说：‘麻将里头有鬼。’事实上，打政治麻将，则鬼更多矣。在这场袁、孙两派的政治麻将里，孙党就手气奇差。简直没一张好牌；而袁党则手气奇佳，好牌不断涌现。当袁氏决定对国民党动武时，忽然来了一个杠上开花” “袁翁世凯的处境，还在燮州府和白帝城之间，他望峡生畏，要掉转船头，驶回重庆，其居心原不难理解，只是其行为则愚蠢不堪罢了。他此时已驶船入峡，顺流而下，滩高浪险，掉头逆水，必然翻船。而袁及其党不知也，悲夫！” 然见微知著，不谨细行，终累大德，袁世凯后来之身败名裂，都可于此等细微人品中见之。执简者能不慨然？一个政客每好逞一时之快，而罔顾死后遗臭万年，是愚不可及也。当政者应知身前自律才好。以上。2020.3.1" }, { "title": "考研与工作", "url": "/posts/woring-and-test/", "categories": "个人杂记", "tags": "考研, 考试, 总结", "date": "2020-02-21 00:03:36 +0800", "snippet": "边工作边考研的10个月也算是一种生活体验吧决定之前就想要要玩就玩最大的数一英一408对于非全职备考真的是很大的挑战综述这种全靠自觉的备考，就是心理负担比较重有几个周末也会玩玩游戏甚至还去了好几次日本玩的时候、看闲书的时候会想着我还没做数学 还没看专业课之类的就是有一种放不下心的感觉好久没有参加国家性考试，考试的时候既紧张又激动，但也多一份坦然。不像大多数学生没有工作只能靠考研，我还是没啥很重的心理负担的。（如果是应届计算机类的话我真的建议秋招和考研可以一起，有一份offer会让压力减轻很多，我2018年尝试过，但最后还是放弃了考研，一是十一之后才准备，二是因为拿到了offerhhh）考完后还是如释重负的，也不怎么在意分数。所以现在才能轻松自在补一年都没怎么玩的塞尔达🤣🤣最后看到分数也还算满意了。62+68+82+89分科说一下，先来我花时间最长的数学，数学一路跟着张宇的课（我甚至还氪金了最后还是没及格）感觉还行，不过后期的课也没怎么听后期主要还是做题吧 各种真题、练习题能找来做、有时间做都做真题现在的我考题见多识广真的很重要做数学题真的很花时间，一套卷子要3小时，不完整做也把握不了时间。最后考场就是在拼在最短时间做最多的题。数学一的内容确实多，但后面的多重积分看似复杂但都是套路，证明内容少，不擅长数学二中值定理证明之类的重点考察的话，真的可以尝试数学一总结数学还是细心！平时做题和最后出来对对答案有时候就是一个符号，一个数字的差距。解答题还有同情分过程分（别留白！随便涂点真的会有分！我估计为什么比我估分高七八分多就是这个原因），填空选择就真的拜拜啦。专业课其次是专业课。408内容也是超级多，计算机专业考生可能都想避开。408前期只看了计组，然后就放弃了。。（计组后面真的复杂，有一段时间就想着转软工考自命题，但是资料奇缺以及挑战自己的奇怪心态还是考了408）经验408的复习开始是考前15天，拿出真题从前往后一年一年做选择题（只做选择题）经常考的知识点看看。大题分类别跨年分直接看答案，考前错题扫一眼就稀里糊涂上考场了。好在今年408可能用的学校大幅增加的情况下不算太难。算法题三元组那道方法竟然还用对了。后面的大题也就随缘大题能有几分算几分看结果可能前面选择题也不是很理想。距离及格差一分也算是正常发挥吧。（合格的程序员？😁）政治英语政治然后政治。政治前期的做徐涛的真题和习题。不知道怎么的第一遍做真题还行，后面做习题就越来越难受，多选都对不了几道。。）讲课我是没听，全凭高中政治累积的基础随便选选。有空就来一套选择题，徐涛的，肖秀荣的都做做，上班地铁上做做微信小程序的什么1000题，多做题总没错。背诵考前一周，拿起肖四就开始背。最后一周天天搞到一两点。边背边抄。最后偷懒就只背全了前两套，后面两套随便混混了。事实证明还是有那么一点点用，但也没押得很准啦 就是不至于考场上没东西写。政治62也算意料之内。但其实我估分感觉能到65-68来着的（。。英语最后英语（竟然是几门中这点分数最高的。。。难以置信）真的没啥好说的经验没背单词 没做题 纯粹高中水平裸考考前最后一天才第一次做新题型，最后考场上的还和2018/19两年的是不同题型。阅读和完型全凭感觉，我英语阅读一想还蛮有自信的（不是自卖自夸。。）翻译英译中比高中一直做的中译英感觉简单点，也是一年没练过直接上了考场就开干。作文，考前晚上和路上翻那本那本王江涛（？）的什么作文考前预测 看了几个范文背了几个开头（还是在交大进门到考场的路上背的）就去考了。。上海学生的英语真的不用太担心，我高考我校平均分都没到裸考考研也有70左右的水准啦，各路英语大佬相信自己。总结看了各位群里大佬的分数，把精力多花在数学和专业课上。这两个150才是拉分重头。前面政治英语两门加起来大家上上下下有10-15就已经算很大的差距了。最后总结考研这条路，说不辛苦是假的。自己选择的路，再苦再累也要走完它。（考的这么差还臭不要脸写了这么长，也不能算啥经验了，就是写流水账。感谢看到这里。。）祝大家不管今年考的还是以后要考的都能金榜提名。" }, { "title": "面向新一年", "url": "/posts/2020-new-year/", "categories": "NEWYEAR", "tags": "新年, 年终", "date": "2020-01-01 00:03:36 +0800", "snippet": "每年的这个时候都会坐在电脑前搞出一篇文章，现在随着年岁的增长，这样撰写文章的机会也越来越少了，年末之际，回首过去，展望未来。今年年初不知道的怎么的就想要挑战考研，既然要考，当然就选定了最魔鬼的科目组合，虽然在年中的时候曾经有过动摇转去交大的软件工程自命题，但最后还是坚持了下来。这一年每天晚上抽空看看张宇的数学教学，周末做做数学题，看看专业课。（英语确实没有复习过。。。不知道最后能考几分）可以说是充实的一年了。因为这个考试却是舍弃了很多的娱乐时间，当然也没有像全职的学生一样全身投入，但是也确实花了很多时间，尤其在数学上。当然最后还是没有做完所有该做的题目，当然及格也是不指望了。经历了备考的这一年，真正感受到寒来暑往的准备考试其实打的是一场持久战，比的是谁的耐久力更好。坚持下来到考场的都是胜利者。一年的数学熏陶，不仅仅充实了生活，也锻炼了思维。当然仍然感觉自己的智力差那么一点。当然，无论怎么样，这一年也就这样过来了，完成立的flag，第一次参加研究生考试，也是时隔6年再次参加全国性考试，这样的考场感觉久违了。当然如果有希望的话还是但愿能够上线。过年期间立下的flag还有一个就是体重管理。上半年开始疯狂锻炼，骑室内自行车，顺利的把体重减少了15kg左右。当然这一段时间不仅仅是运动，也是加上饮食的管理，那段时间的锻炼也是习惯成自然了。Apple Watch圆环的激励也帮助了不少。完成了两百多天的连续画三圈，但是在不经意间就断了，甚是可惜。体重的下降其实带来的是自信心的提升。手机里的自拍好像不经意的多了起来，去优衣库的次数也在不经意之间多了起来，敢于尝试更多风格的衣服，体会到了标准体重真是一件好事（当然也是一件伤钱包的事情）这一年，工作上不仅仅继续堆砌了通天塔，也完成了第一次红包雨活动，这一次活动第一次感受到了选择这份工作的初心，为世间带来快乐和美丽。当然这样完美的一年，通天塔的完善和完美的活动，光靠我一人之力也是无法完成的，感谢每天陪伴的同事，美丽帅气的产品，高冷的后台小哥，负责的测试同学等等！尤其是开车群的大佬们（～。这一年也走过了大陆和日本的很多地方，感受了各种的风土人情。横跨东西，踏入西部，走进东洋。更多的旅游，发现自己的摄影水平着实有点着急。看着大佬们的各种完美照片，自己也想要拍出更好的景色。当然，摄影只是旅途中的一部分，能够设身处地的到自己常听歌曲中提到的地名和展现的舞台，也是一种特殊的体验和感受。2019年对于我来说确实是个不平凡的一年，经历了众多的第一次。23年来的人生进入了新的阶段，第一个完整的工作年份，第一次在境外度过生日，第一次一个人决定一次旅行，还有更多的第一次不胜枚举。这一年，越洋过海去东洋的次数来到了3次，也感受到了有时间到处旅游也是一件十分快乐的事情，就算没有去很多的景点就是在异国他乡的河边走走也是一件十分幸福的事情。2019年的flag基本都完成了，这一年的风风雨雨好事坏事就全部留在了这个365天循环，下一个366天更美好的一次地球公转希望能够过得更好！2020年的flag其实还没有明确，但是唯一一点，就是不会再去参加考研啦。希望2020年能够继续在人生最大梦想完成路上更进一步，虽然我认为如果没有考上交大的话应该是初战没有胜利了（。。。2020年迎来了人生第二个十二生肖轮回的开始，也希望这一年在各个方面都能有所进步，尝试一些之前没有完成和尝试过的事情，了解更多自己未知的世界，克服更多自己各种各样的小毛病。一年又一年，每年的年末都是一样的感受。岁岁年年花相似，但是年年岁岁经历又不尽相同。随着人生阅历的增加，人的心智也会越来越走向成熟吧。今年遗憾的事情也有很多，各种事情也有很多后悔的，有的后悔可以补救，但有的也就一去不复返了。新旧交替，一元复始。这一年，希望能和新老朋友继续携手并进！友谊地久天长！新的一年也请多多关照！毛泉2019.12.31" }, { "title": "世界在年轻的胸怀（胡志强） ", "url": "/posts/huzhiqiang/", "categories": "NEWYEAR", "tags": "新年, 年终", "date": "2019-07-31 10:21:36 +0800", "snippet": "这篇只能算是个提纲。大概在几年前在youtube上看到了胡市长讲的通识课。感觉很有营养。几年后重新拿来看 就做了点记录。欢迎去youtube上亲自看看【逢甲通識】胡志強 世界在年輕的胸懷其实强本高涛这个系列的课程都很不错1 超越国际观，走向全球化know the world全球在地化拥抱全世界时，不必放弃自我。全球和在地不是零和关系。2 六大全球新趋势环保、民主、人权 环保 气候变迁、天然灾害、低碳、节能、永续发展 人权无国界主权的弱点所在（人权没有国界保护，若没有保护，会被外国人关心和干预）、外国人关心、外国政府干预国际社会：主权（球撞球）有硬壳保护 民主政治的普及与深化「第三波民主」（民主是不是已经完成？要看深度）「变形民主」（财团对民主和政治的影响，伤害了民主的真谛） 财富均衡的争议与对立 贫富差距、道德观感、新社会阶级「对抗快速扩大的贫富不均，将是各国政治领袖，必须面对的重要课题」 『有钱的罪恶感』社会中对于有钱的观感不佳 新的社会阶级： 反财团 资讯革命的延伸 世代差异与大数据1） 世代差异： 从接收到质疑（要对所有资讯有质疑观） 从垂直到水平（每个人都可以成为媒体） 从灌输到自我（个人的意见和反应很重要，对媒体的质疑会有媒体跟进）2） 大数据： 数量与速度 解答与预测 谦卑与人性 和平面临危机 没有大危机，却有小危机 全球危机 （世界大战）VS. 区域危机（区域冲突） 自主、自觉： 民族主义与武装冲突 恐怖主义方兴未艾：理念、宗教与财富 创意无国界、创意就是商机 Ex. 泰国餐（第一个有计划输出饮食文化的国家）与星巴克文化创意经济已成21世纪世界经济主潮流创造精神加物质的美好感觉：追求满足、感受进步、让消费行为有更大成就感A. 文创经营城市理念 创意要与众不同（Be different） 重创意就要重文化（创意与文化有关） 用文化“诱”出财力 创意不能落空 -&amp;gt; 必须满足众人需要创意不是炫耀、不能曲高和寡最好与产业共生共荣Uniqueness+Demand=Business 不能成为第一（No. ONE），至少成为唯一（Only ONE） 第一是胜者，唯一是智者" }, { "title": "2018年最后的再见", "url": "/posts/end-of-2018/", "categories": "NEWYEAR", "tags": "新年, 年终", "date": "2018-12-31 23:03:36 +0800", "snippet": " 子在川上曰，逝者如斯夫，不舍昼夜。时值岁末，每年的这个时候总会写点什么，也总会在每年的这个时候才真实感受到时光正在远去。最近几年越来越感受到一年已经不再是小时候那漫长的时间了。一些关于近几年的记忆已经交错在一起，有些几年前的时间甚至如今年刚刚发生一般。回望这一年，上半年的毕业论文，下半年的公司生活。一切都是这样的平凡和普通。上半年从开题到结题，原先感觉这4-5个月会是很长的一段时间。但是根据开题，中期和结题之间也就只有1个多月的时间。其实说实话，本科的毕业设计还是蛮水的，从去年年末的恢弘规划，最后限于时间和水平，都只实现了一部分，最后还是没有把自己造的系统把现成的轮子换掉。当然着重点还是论文，这一篇论文最值得骄傲的应该就是查重率吧。hhhh，查重率0%（看起来是可以吹一阵了）。上半年在中期答辩之前和毕业之前抽时间进行了以后可能再也不会有的东渡之旅。虽然拿到了三年签证，并且原先的设想很美好，但看了周末的机票发现自己也是多虑了。4月的樱花，向往了很久终于实现。当然也留有了很多遗憾。从1月份第一次樱前线预报就开始追，一路看着预报的开花和满开时间提早。最早的仙台附近的盛景，从去的太早，到正好满开，到最后出行的时候已经开始吹雪。人算始终拼不过天算。6月的超长线，刷完了四国铁道，也遇到了小插曲，意识到有时候过分自信也是会付出代价。四国的巴士走过东南角的室户岬，抬眼望去是无边无际的太平洋，同时感谢天公作美。坐着代行巴士穿越了常磐线辐射区，车内举目四周，看到的是海啸过后留下的满目疮痍，自然把那里的一切都停留在了2011年。便利店和商店也都已经长出了野草。大自然重新掌管了这一片区域。也感受了新干线的大晚点。大家席地而坐等车，没有指定座的也不会抢占座位，不由得感叹。6月在日本感受了参加世界杯国家的热情。原来想找个地方看第一场比赛，可是最后只能在新干线上看了。日本队今年的表现真的很棒。最后的八强赛真的是遗憾。。每次旅行都会感受到世界之大，和自身的渺小。希望以后继续有机会多出去走走。上半年在日本也买到了Switch，也买了很多游戏。但最中意的或许还是马里奥奥德赛吧。收集月亮的过程十分享受，虽然对手残党真的不友好😤。下半年，顺利完成了从学生到社会人的转变。由于去年半年实习的关系，并没有感受到很大的区别。每天上下班的通勤时间成为了读书的好时间。进修了一些专业知识，学习了一些历史知识，也看了许多隔夜新闻。下半年和“头号玩家”们经过的时间非常愉快。一条条需求大家都用心的去完成。当然光靠一人是无法完成高质量的软件的。这一点在学校的闭门造车也是无法感受到的。团队的力量真是无穷的，完美的人际关系当然也是必不可少的。衷心希望明年的通天塔能越筑越高😆下半年也申请了一堆信用卡开始了薅羊毛的旅程，小愿望明年能够凑够2W亚洲万里通，换去日本的机票吧。🧐今年也会看棒球了。在100回甲子园之际。今年也是平成的最后一年。回首30年的同时，明年的新元号会是什么呢？这一年看着台湾年底选举的一步步，仅仅2年，2016年民主进步党的大胜还在眼前，今年马上就反转，不由得感叹民意的力量真的是无穷的。最爱的乐队少了一位成员，希望すばるさん单位未来能更好（叹息🙁）今年拍了一年的牌照。。原来想三个月完成的壮志没有完成，。明年继续了～地球上的70亿人又一次在欢庆地球像之前49亿年一样完成了一次艰难的公转。这一年也发生了许多顺心不顺心的事情，把这些都留在这一年吧。每一年都是这样过来了。年末的展望永远只会停留在前一年年末了。下一年、下一天甚是下一秒发生什么都无法预知，就这样抱着这样的新鲜感向前行。年末总结总是流水账🤪。。。但希望这样的流水账也会给未来的自己留点印象吧。新的一年，大家加油、成为更好的自己！友谊地久天长！感谢一年来各种各样同学、同事、家人的陪伴。明天会更好！以上。毛泉2018年12月31日20:00" }, { "title": "“政治民主化，军队国家化”", "url": "/posts/democracy/", "categories": "读书记", "tags": "读书, 近代史, 国共关系", "date": "2018-12-31 23:03:36 +0800", "snippet": "–读《联合政府与一党训政》之拙见难得在三四天内读完一本书。大陆地区难得中立立场看待1944-1946年间国共关系的书。史料充足，论证详实，立场中立。政治民主化是国民党的需要解决的问题，而军队国家化是共产党所需要解决的问题。两个问题相互纠缠，没有一便没有二。事实证明共党之所以不肯交出军队是因为国家当时是国民党的，国民党剿共于无形之间、而国民党不愿意国大代表重选也是因为共党有军队而提防和平演变。两党从1943年战局扭转一直纠缠道1947年南京会谈彻底谈崩，都是围绕着这个问题僵持不下。而双方谈判的基础就是谈判当时的军事实力，谈判当时的军事能力强的一方能在谈判中开高价码，两党互不相让，导致谈判破裂。即使是1946年政协会议第三方参与情况下的两党各退一步，一度让共党开始了军队整编步伐，国党开始改组政府，但在国民党六届二中全会的右派对于明面上三民主义五权宪法的争论实际是右派不愿放权的反攻和苏联在东北的搅局，谈判最后仍然破裂。苏联的搅局加速了内战的爆发，没有苏联在东北造成的混乱局面给中共开入东北有可乘之机，和匆忙签下的中苏条约，共党问题不可能不解决。最终结论：民国政治的决定性因素在于两党军事实力和国际因素，而不是共党所谓的人心所向。" }, { "title": "永远不要被自己和规则打败 ", "url": "/posts/2017end/", "categories": "NEWYEAR", "tags": "新年, 年终", "date": "2017-12-31 10:21:36 +0800", "snippet": "— 2017年年终总结2017年度、在这个世界上的第21年。其实很多事情也已经渐渐的在微博上发了。年末的总结也算是一个常规内容了。这一年的收获或许是近几年来最多的一次了，年初和年中的两次日本之行，贯穿全年的驾驶学习，下半年的实习。这365天或许是这一生最重要的一年了。最近每年都会写年终总结，但是似乎每年的年终似乎都是大同小异，回顾过去，展望未来。确实，人类的记忆给了我们能够在一段时间过后回顾过去的能力，但是如果仅仅报报流水账，似乎年终总结也并没有意义，所以，我想尽量减少这类内容的叙述。这一年里，我体会到了成为一名社会人的艰辛。在半年的实习中，开始渐渐的走向社会，学会和人进行交流。每天早上短暂的通勤，然后在办公室坐下完成一天的任务，然后准备回家。简单的重复这一天又一天。有时候会去想这件事，其实这个社会也就是一个大型的过家家游戏。一部分人的付出为另一部分人的生产工作提供支持。诚然，如果少了一个人两个人并不会影响整个全局的运行，但是如果缺少了很多人，那么这个社会也就无法持续的运转下去。每一个人的存在，也就是这个社会存在的意义之所在吧。上半年，度过了简单的一个学期，没有什么课程，基本每天在市区松江来回。完成了两个大作业，让我感受到了前端的魅力，也让我选定了这个方向最为找工作的目标。在一次次的面试的锻炼下，也让我明确了工作以后的目标，目标明确，对于一个人总是十分重要的一件事情。在这个奇怪的实习制度下，逐渐感受到了不公平其实到处存在。深刻的感受到了什么叫做“会哭的孩子有奶喝”，也知道了权利真的可以让有些人为所欲为。有些事情，就是人善被人欺，如果只是按部就班的按照规则，一步一步走，反而会被人不理解，如果合理的利用小聪明，反而会得到出乎意料的结果。一旦被有些人盯上，因为面试请个假都会成为不可饶恕的大错。这些事情，毕业以后会有详细叙述。下半年，奔波在全上海找合适的毕业去向。因为有着明确的工作岗位和薪资目标，所以找工作确实有着一定的目的性。虽然，自己接触前端只有短短的半年都不到，但是我相信这也是证明自己学习能力的一个机会。在面试的场合，我发现，面试的候选人80%都是研究生，说实话是有点胆怯，但是从另一个角度来说，我一个本科生也能和他们同台竞技，不也就证明了其实研究生并没有什么了不起，学历并不代表能力也是确实的。在这几个月里，前几个月疯狂的笔试，一场接一场的笔试但基本都没有面试邀请。从10月开始，面试邀请逐渐多了起来，但是因为奇葩的制度，我也推掉了很多面试，那一句“不要参加不可能入职的面试”，让我瞬间怒气爆棚，如果我有这个本事面试前就知道能否入职，我相信我也不会在这里。这句话，相信我我会永远记在心里。面试这件事情，真的是熟能生巧的东西，一次又一次的锻炼，也让我逐渐了解了前端面试的众多知识点，从最初的面试紧张、支支吾吾回答，到后来的从容的对答如流，我相信也是靠这近十次的面试逐渐积累的经验。这样的经验也让我知道了什么叫做“不到最后，永远不要轻言放弃”，如果几次失败后，我就转换去考研，或许是两面都不会成功。失败并不能打败人，打败人的是自己的胆怯。永远充满自信的面向未来。这一段时间我也发现了自己其实在遇到问题的时候，总是首先会去找客观原因（这个或许在前文中已经有所显露了）。这一部分的缺憾，在新的一年中希望能够有所改观，其实在和人沟通以及承认错误的时候，其实他人更想听到的是自己的主观原因吧。其实我也已经有所察觉，争取改掉这个吧，自己的错误将会首先叙述的。这一年里，聚会的次数似乎已经降到了这一段时间的谷底。高中的同学似乎也都有着自己各种各样的烦恼，有的也已经奔赴在千里之外。有时候想想，在这个有着75亿人口的世界中，有着一面的相见似乎都是冥冥中注定的缘分，更不要说能够成为朋友。可能因为内向的关系，有时候也难以分清怎么样能够算是朋友，所以有时候在路上见到熟人也不敢主动地打招呼，生怕逾越分际，或许对面之人也是想要有一个招呼吧。对那些人表示自己的歉意吧，走向社会之后，也希望能够有所改观吧。这一年，其实也出去走走了两次。足迹也已经遍布了日本四岛。日本的种种事情，也在大陆关心着。这一年，因为月曜夜未央粉上了关八这个乐队组合，或许最吸引我的是他们的音乐着实很符合我的胃口。无论是快歌还是抒情慢歌，总能抓住我的耳朵。也是因为这个开始买CD，专辑。也深深感觉入了一个大坑呢。。。（另外，我也开始后悔小时候没有听我妈的话学钢琴了！）hhh。还有Sekai No Owari，在这大环境中，这种小众乐团（似乎也已经不小众了）的存在，也正是音乐的包容性吧。这一年，也感受到了其实偶像也是一个承担着许多的职业，在众人之中被选出，几乎没有隐私的空间，在享受着万众瞩目的同时，也有着不为人知的艰辛吧，毕竟也算是承担梦想之人了。在这一年也继续刷了很多的里程。当然主要还是JR，三次的日本之行，也让我发现了其实我还是能在日本用三脚猫日语和人交流的hhhh，新的一年，也希望能有机会再去，以及好好的系统学习日语吧。毕竟人生目标中也有着离开大陆的这一个选项。一年的365天也只剩下了最后的3小时。但是，从另一个角度来看，如果没有人为历法的分割，这1月1日也不是普通的一天之一嘛，好好的度过每一天，也就能度过这一年，这一生。いつでもこれがらも　よろしくお願いします！把种种的烦心事留在2017吧，2018 你好！！以上。毛泉2017年12月31日21时10分" }, { "title": "秋招小结", "url": "/posts/career/", "categories": "技术", "tags": "操作系统, 线程", "date": "2017-11-15 00:03:36 +0800", "snippet": " 心まで躾けられた悲しみの記憶本当は君に出来ないことなんてないのにー「象」関ジャニ∞2017年11月14日、寄走了自己的三方，结束了为期3个月的秋招路。有过焦虑、迷茫和不知所措、最终也算是机缘巧合找到了一个心仪的东家。回顾往事、才能更好向前。（前半部分流水账、后半部分干货）心路历程秋招开始于夏季的8月、期间没事逛逛牛客论坛、看着别人一路顺畅在内推就拿到offer、心中是羡慕的、但是也没有如此慌张，毕竟这只是提前批。之间夹杂着歇斯底里的疯狂投简历、忘记了之前心中预设的原则和期望、听说的没听说的一阵海投，看到心仪公司的内推信息仿佛如获至宝、生怕晚了一分钟会错失机会的快速投递简历。当然不出意料、很多简历投出去了也就渺无音信了。前两个月的笔试轰炸在9/28之前没有换来一场面试。看着别人的面试通知一个接一个的求面经、要说不紧张那是假的，从那时候开始、深刻感受到了难找工作。也是从那时候开始、开始了准备起了考研、做好两手准备。当然开始考研准备的10月、面试通知开始纷至沓来，一个接一个应接不暇。但是由于各种客观原因的限制（本文不吐槽奇葩制度、留待后文）、也是放弃了一些面试。下文将会着重讲一下前端方面的大略面经和复习梗概。相比9月的煎熬笔试、面试的路程也并不是一帆风顺。到了每一场面试、发现自己都是在和一群研究生在抢夺同一个职位、说没压力那是假的。我的经验来看、本研比可以达到了2:8。但是庆幸的是一所211的大学确实可以加分一点也不至于在和研究生竞争的过程中毫无优势，但是这种优势却除了能过简历关外似乎也是一无是处了，毕竟能在一起面试的基本都是笔试中通过的。时间来到10月底、那时候还是一个offer都没有的我收集到N多几面之后的拒信、看着论坛里一个个都在比较offer、心中一股会成为高等游民的想法油然而生。回头来看、那时候真的是考验自己的时候，没有退路可走的时候、光明也似乎就在眼前了。这就好比1000m长跑来到了最后200m、需要做的除了咬牙坚持、也没有了别的选择。那时候也投了许多简历、因为一些大型银行、金融机构、国企开始了招聘。计算机专业的其实也能抓住这些机会。10月底offer也开始逐渐来了、但是拒信肯定是比offer更多。第一个口头offer来自海尔金控、因为是口头offer（可能是实习）、而且目前为止也没有进一步沟通、那时候也没太当回事。第二来自中国联通上海分公司的信息部。投简历的时候只有一个表格让我差点以为是骗子，不过还是没有坚持原则、填了表格、经过群面、专业面，也算拿到了offer。联通逼签能力一流、后文详述。第三来自现在签的京东。京东的过程可以称作坎坷。9月底内推的电话面试似乎是一面挂、后来的笔试也没有顺利通过。但是在联通发offer的同时、又开始了新一轮的补招面试。这一次顺利很多、一天之内两个电话面试之后十分顺利的搞定了offer。但是好事多磨，最后offer确定发放的时间还是比联通的deadline晚了一天、3000元保证金的时效也就仅仅只有一天。（说不心疼那是假的！最后一个是上海银行、垃圾箱中找到的offer、因为已经签了京东、也就没再关心、签约会前一天HR打电话来、我也终于扬眉吐气了一把、拒绝了HR的offer、不过也要向如此敬业通知的HR表示致敬！3个月的路也就这样走过来了，希望自己做的决定以后不会后悔。现在回头来看、除了上面的文字、最好的一句话就是： 归去、也无风雨也无晴。笔试笔试就参加吧、没什么好讲的。大多数公司笔试会考填空选择编程、也有只考编程的、有的公司所有计算机知识点混着考、也有的只考投递岗位的专业知识。其实能从试卷名上一窥究竟啦、有岗位名称的基本都是具体领域为主。笔试考的点会很细致、前端的角角落落、API名称之类都会考、这只能靠死记硬背了。别无他法。有些单位十分喜欢考算法题（基本所有单位都会考）、不过难度并不大、简单的贪心、动态规划稍微会一点解决80%的问题不在话下。面经部分面试这个东西真的是熟能生巧。从小害怕面试的我7/31参加了一个创业公司的面试、也算是第一次面试，心中真的十分紧张、也没有充足的准备。上来一道闭包的编程题就挂了。到了10月底最后一次的JD电话面试、真的顺畅了很多、面试官的问题听到也不会懵逼了、自我介绍也顺畅了、问题回答的表达方式也清晰了很多。不过也有一些国企会有群面、我的经验就是群面不要怕、少说话跟着做就OK。所以，结论是、面试真的要靠一次次去尝试才能增长经验的。我应聘的主要是前端工程师的岗位、但是在一些国企并没有如此细分，所以计算机知识都考（其实笔试也是一样）。下面主要罗列一下前端面试的必考点：JS方面： ES6的新特性（必考、主要着重于var与let的区别、块级作用域、Promise的作用以及新特性的罗列）、有些点不需要十分细致会，但是名称以及哪些是新的一定要了解。 this的绑定问题、call_apply_bind：毫无疑问的必考点、《你所不知道的JavaScript》总结的很好、不再赘述。 继承的实现问题：原型、原型链。 闭包：重中之重、一定要能解释清楚定义、作用、优点缺点。每家都问 函数的作用域链。 事件、事件代理。代理的优点、IE和一般的区别。 对象的概念、用法、API、对象类型判断：比如如何定义对象啊、判断是不是数组啊、深拷贝的手写之类的。 数据类型转换以及true/false的判断：弱类型语言的致命必考点、搞清楚请同样阅读《你所不知道的JS》。 数组、字符串的常见方法：之前一直没有很好总结，推荐一本书《Javascript框架设计》、里面总结了一些常见的方法和一些扩展的造轮子方法。 框架：至少听说过几个大框架、实际用过、又一个能吹逼的项目。了解其中的核心内容的原理以及每个框架各自的特点特色。不用实现但要知道、比如vue的双向绑定实现之类的。当然我也碰到过要手写jQuery链式调用实现的面试题。 localStorage、sessionStorge、cookie之间的区别和联系。 Node.js：也逐渐成为必考点了。知道包管理、包管理的寻找路径、大致使用方法、简单API即可。HTML/CSS部分：这两个可以合着一起： HTML标签：分清楚哪些是5新加的、哪些是块级的、哪些是行内的、这两个有啥区别。多准备几个就行。 HTML5新特性：和ES6一样、简单了解就行。 垂直居中布局：必考中的必考、至少要会几种、absolute的、flex的、zindex的等等。 CSS一些属性可以设置的值：有哪些position啊、有这么区别啊、display有哪些可设置之类的。 CSS的继承：继承层级要会、优先级要会。 CSS的盒模型：主要落脚点是IE和一般的区别。 repaint和reflow：哪些是repaint、哪些是reflow要能分辨。 清除float：一要会、二要知道为什么要。主要就是以上这些，其他的就看临场应变了，也欢迎补充。不要以为前端面试只是空谈、也会直接撸代码，毕竟这才是最终的要求。上面这些最好是自己试过、这样让你直接写代码才能心中有数。平时要是能写点小模块那就是更好的了。分公司的面经另开一文。以上。 10年後まだここであえるよ そんとき今よりずっと笑っているよ！ー「象」関ジャニ∞2017.11.15凌晨" }, { "title": "操作系统复习（二） 线程", "url": "/posts/os2/", "categories": "技术", "tags": "操作系统, 线程", "date": "2017-09-03 00:03:36 +0800", "snippet": "线程的引入目前为止进程的两个特点：资源所有权一个进程具有一个执行状态和一个被分配的优先级，进程是一个可被CS调度和分派的实体两个特点是独立的，OS应该能够独立的处理它们。所以，为了区分这两个特点，分派的单位通常称为线程，而进程仍然为拥有资源所有权的单位。多线程指OS在单个进程中支持多个并发执行路径的能力。多线程环境中：进程： 定义为资源分配的单位一个被保护的单位。线程： 一个进程中可以有多个线程。进程中的所有线程共享进程的状态和资源与进程相关的内容：A. 存放进程映像的虚拟地址空间B. 受保护地对处理器、其他进程、文件和I/O资源的访问与线程相关的内容：A. 线程的执行状态 B. 未运行时的保存的线程上下文C. 一个执行栈 （有线程的OS中，每个线程都有执行栈）D. 用于每个线程局部变量的静态存储空间E. 与进程内的其他线程共享的对进程内存和资源的访问线程的优点：在一个已有进程中创建一个新线程比创建一个全新的进程所需要的时间少很多终止一个线程比终止一个进程花费的时间少同一进程内线程间切换比进程间切换花费的时间少线程提高了不同的执行程序间通信的效率线程状态线程中的关键状态：运行、就绪和阻塞（线程级别没有挂起状态）基本操作：派生、阻塞、解除阻塞、解除线程同步：与进程同步的内容类似用户级线程和内核级线程用户级线程：定义：在一个纯粹的用户级线程软件中有关线程管理所有工作均由应用程序完成，内核意识不到线程的存在。线程与进程的相互关系：（设进程B有两个线程分别为1，2）A. 线程2进行了用户调用，阻塞的进程B：此时线程库来看的线程2处于运行态，处理器来看，线程2未运行，进程B处于阻塞态。B. 进程B因时间片用完，时钟中断把控制传给了内核：线程库来看，线程2处于运行态，处理器来看，此时进程B处于就绪态。C. 线程2需要线程1执行某个点：此时，线程库来看，线程2处于阻塞态，而线程1处于运行态。使用用户线程的优点A. 所有线程管理数据结构都在一个进程的用户地址空间中，线程切换不需要内核态特权，节省了两次状态转换。B. 调度可以是应用程序相关的，可以为应用程序量身定做调度算法而不扰乱底层OS的调度程序。C. 用户级线程可以在任何操作系统中运行使用用户线程的缺点：A. 典型的OS中，许多系统调用都会引进阻塞，用户级线程阻塞后，所有线程均被阻塞。B. 在纯粹的用户级线程策略中，一个多线程应用程序不能利用多处理技术。内核级线程：定义：一个纯粹的内核级线程软件中，有关线程管理的所有工作均由内核完成，应用程序没有进行线程管理的代码。优点：A. 内核可以同时把同一个进程中的多个线程调度到多个处理器中B. 若进程中有一个线程被阻塞，内核可以调度同一个进程中的另一个线程。缺点：把控制从一个线程传送到同一个进程中的另一个线程时，需要内核的状态转换。" }, { "title": "JavaScript精进之路 — 异步的实现（上）", "url": "/posts/js2/", "categories": "技术", "tags": "javascript, 前端, 异步", "date": "2017-08-19 00:03:36 +0800", "snippet": " 要帶著問題學,活學活用,學用結合,急用先學,立竿見影,在「用」字上狠下功夫。 — 林副主席题词是林副主席的语录，很有感触，特记于此。废话少说。这是这个专题的第二部分内容，异步。主要总结了《你不知道的JavaScript（中卷）》中有关于异步的内容。显然一下子写完三个部分的内容不太可能，下篇会在不久之后放出。由于前人之述备矣，所以有些地方会引用它山之石，它山之石可以攻玉嘛。 🙈什么是异步首先明确，JavaScript是一种单线程语言，不会出现多线程。 【异步的核心】程序中现在运行部分和将来运行部分的关系就是异步编程的核心。简单来讲，如果程序中出现了一部分要在现在运行（顺序同步执行），一部分要在将来运行（可能是设置了timeout也可能是一个ajax的异步调用后执行的函数），那么两者之间的关系的构建就构成了异步编程。 【事件循环】相当于一个永远执行的while(true)循环，循环的每一轮称为一个tick。对于每个tick而言，如果队列中有等待事件，那么从队列中拿下这个事件执行。队列中事件就是注册的异步调用函数。由于事件循环的原因，setTimeout只是在timeout的时间后将函数注册到事件循环中，因为有被其他任务阻塞的可能，所以其时间不一定准确。setInterval同理可得。setTimeout(…,0)可以进行异步调动，将函数放在事件队列循环的末尾，是一种hack的方法。具体可以参阅以下blog：你所不知道的setInterval | 晚晴幽草轩 【任务】Promise的then是基于任务的。任务和事件循环的区别，可以理解为任务代表的异步函数可以插队进入当前事件之后。所以从理论上来说，任务循环（job loop）可能导致无限循环（一个任务添加另一个不需要排队的任务，例如Promise中then的无限连接）使得无法进入到下一个tick中。 EX 事件循环和任务的感性认识 (function test() { setTimeout(function() {console.log(4)}, 0); new Promise(function executor(resolve) { console.log(1); for( var i=0 ; i&amp;lt;10000 ; i++ ) { i == 9999 &amp;amp;&amp;amp; resolve(); } console.log(2); }).then(function() { console.log(5); }); console.log(3);})()输出是 1 2 3 5 4 而非 1 2 3 4 5这就说明了Promise决议之后，先执行了then的这个任务（job），这个then没有进入事件循环中排队，因为如果排队，应该会在setTimeout这个先注册的function之后调用。所以then的任务队列的优先级高于事件循环。并且磁力还说明了Promise的决议过程是同步执行的。具体的原理说明：https://github.com/creeperyang/blog/issues/21 【异步交互协调】有时会由于两个ajax调用的先后顺序（或者其他操作的先后顺序）的原因会导致运行结果的不同，为了控制进程的执行，有两种控制的模式和两种简单的方式：首先是门：这个可以控制两个函数都完成之后才进行下一步工作，条件控制条件为if(a &amp;amp;&amp;amp; b)第二种是竞态，也可称为门闩。就是两个函数只有一个能够被调用，另一个会被忽略，其控制条件是设置一个undefined的变量a，调用后设为有值，并且判断if(!a)异步的基础模式 — 回调（callback）回调可以说是JavaScript的基础了，这里不讲回调的好处，只有回调的几个明显缺点（否则则么显现出后面的进化呢（笑））： 【回调函数】回调函数封装了程序的延续（continuation）。回调函数是处理JavaScript异步逻辑最基础的方法，但也有着各种的缺点。 【嵌套回调和链式回调（回调地狱）】 有下列代码： //《你不知道的JavaScript（中卷）》listen( &quot;click&quot;, function handler(evt){ setTimeout( function request(){ ajax( &quot;http://some.url.1&quot;, function response(text){ if (text == &quot;hello&quot;) { handler(); } else if (text == &quot;world&quot;) { request(); } } ); }, 500) ;} ); 这是一个由三个函数嵌套在一起的链式回调，每个函数代表了一个异步序列。 由于回调的特性，可能很难一下看出这个函数的执行逻辑（缺乏顺序性），所以又被称为回调地狱或者毁灭金字塔。【回调地狱的缺陷】：doA( function(){ doC(); doD( function(){ doF(); } ) doE();} );doB();如果函数A和D是异步执行的，那么这个回调过程的执行步骤是A - F - B - C - E - D除了难以阅读以外，回调地狱真正的问题在于一旦指定了所有的可能时间和路径，代码就会变得十分复杂，无法维护和更新。因为一个进行的回调要是能够覆盖所有路径，可能会写上很多并行的回调函数，在代码中看起来可能会十分凌乱和难以调试维护。 【控制反转】这牵涉到异步程序设计的信任问题。控制反转就是程序执行的主动权从自己的手中交了出去。如果仅仅是简单的ajax调用，那么这个控制切换可能不会带来什么大问题。但如果将一个回调函数交给一个外部的API，因为无法查看的具体代码，所以可以看做是一个黑箱。这个黑箱导致问题是无法调试，不知道这个外部程序到底怎样调用了这个回调函数，是一次都没有，还是调用了很多次，亦或是比预想中过早过晚的调用，最终可能的后果就是程序执行的结果不如所愿。教科书一点的定义就是把自己程序一部分的执行控制交给了某个第三方，且与这个第三方之间没有一份明确表达的契约。因为回调没有机制来保障这个必然出现的控制反转的问题，这就成为了回调的最大问题，会导致信任链的完全断裂，是程序出错。回调函数必须遵守的原则就是：信任，但要核实。（Trust But Verify.） 【error-first风格】回调函数的第一个参数留给错误处理，如果成功第一个参数就置为false，否则为true。回调执行时先进行判断。但是这个风格并没有完全解决信任的问题，如果同时成功和失败，就要另外写代码来处理。 【Zalgo】回调会有同步回调调用和异步回调调用。这样也会产生程序的运行问题，见下列代码： function result(data) { console.log( a );}var a = 0;ajax( &quot;..pre-cached-url..&quot;, result );a++;这端代码会有0（同步回调调用）还是1（异步回调调用）的结果就要看情况而定了对于可能同步调用也可能异步调用给出的回调函数的第三方工具而言，这个信任问题是明显的。虽然可以用臃肿的附加代码来解决，但并不优雅。这样的同步异步的混淆产生了另一条准则：永远要异步调用回调，即使只在事件的下一轮。（always invoke callbacks asynchronously, even if that’s “right away” on the next turn of the event loop）异步的进化一 — Promise前面一部分已经描述到了回调函数的两个问题分别是：缺乏顺序性和缺乏可信任性。那么这部分的Promise主要用来解决了可信任性的问题。 【解决可信任问题的范式】不把程序的控制权交给第三方，而是希望第三方提供一个了解其任务何时结束的能力，然后由我们的代码来决定接下来做什么。 【未来值】A对于B有一个承诺，如果A给出了任务完成可以兑现承诺或者失败不能兑现承诺的值，那么这个值就称为未来值，简单而言就是要在未来才能确定的值，但有承诺保证这个值存在。 由于未来值可能有两个可能，要么成功，要么失败。所以Promise值的then方法（在Promise值确定之后调用的函数）就可以接收两个参数，第一个为成功的话执行的函数，第二个为失败的话执行的函数。举个例子：把x和y相加，如果有一个值没有准备好，那就等待。一旦全部准备好就相加返回。为了统一处理将来和现在，就把他们全部变成未来值，就全部异步调用。回调模式下的代码：function add(getX,getY,cb) { var x, y; getX( function(xVal){ x = xVal; // both are ready? if (y != undefined) { cb( x + y ); // send along sum } } ); getY( function(yVal){ y = yVal; // both are ready? if (x != undefined) { cb( x + y ); // send along sum } } );}// `fetchX()` and `fetchY()` are sync or async// functionsadd( fetchX, fetchY, function(sum){ console.log( sum ); // that was easy, huh?} );Promise模式下的代码：function add(xPromise,yPromise) { // `Promise.all([ .. ])` takes an array of promises, // and returns a new promise that waits on them // all to finish return Promise.all( [xPromise, yPromise] ) // when that promise is resolved, let&#39;s take the // received `X` and `Y` values and add them together. .then( function(values){ // `values` is an array of the messages from the // previously resolved promises return values[0] + values[1]; } );}// `fetchX()` and `fetchY()` return promises for// their respective values, which may be ready// *now* or *later*.add( fetchX(), fetchY() )// we get a promise back for the sum of those// two numbers.// now we chain-call `then(..)` to wait for the// resolution of that returned promise..then( function(sum){ console.log( sum ); // that was easier!} );通过比较明显看出Promise模式的方法可以简洁的表达一些操作。Promise封装了依赖于时间的状态（等待未来值的产生，无论是现在还是未来产生，后续的步骤都是一样的，解决了同步回调还是异步回调的问题），其本身与时间无关，所以可以按照可预测的方式组合。但Promise一旦决议，那么永远将会保持在这个状态，成为不变值，可以随时查看。 【revealing-constructor】一种产生Promise的模式，通常格式为 new Promise (function (…){…}) ，传入的函数将会被立即执行。 【识别Promise】识别Promise是否为真正的Promise很重要。定义某种称为thenable的东西，将其定义为任何具有then(..)方法的对象和函数，任何这样的值就是Promise一致的thenable。如果Promise决议遇到了这样的thenable的值，那么就会被搁浅在这里，导致难以追踪的bug。 【Promise解决信任问题的方法】有五种回调导致的信任问题，分别来讲： 调用过早： 由于一个任务有时候同步完成，有时候异步完成。如果使用回调会导致Zalgo出现，使用Promise无论是立即决议的revealing-constructor模式，还是异步执行的内容，都会基于最前面所讲的任务队列来进行异步调用，这样就解决了调用过早的问题. 调用过晚：由于同步then调用时不被允许的，所以，一个Promise被决议之后，这个Promise上所有的通过then(…)注册的回调都会下一个异步时机点一次被立即调用。任意一个都无法影响或延误对其他回调的调用（不能插队）Ex: p.then( function(){ p.then( function(){ console.log( &quot;C&quot; ); } ); console.log( &quot;A&quot; );} );p.then( function(){ console.log( &quot;B&quot; );} );// A B Cfunction runme() { var i = 0; new Promise(function(resolve) { resolve(); }) .then(function() { i += 2; }); alert(i);} //0这里第一个function第一次注册了打印出A的then方法，打印出B的then方法，注册完毕后进行任务队列的处理，因为A先注册，所以先执行。这里又注册了一个C的then方法，虽然p已经被决议，但是并不能立即调用（不能同步调用），还是加入到任务队列的最后，不中断对B的执行。所以执行结果是A B C。第二个是即使是p立即决议了，但是then中的内容还是被延迟到执行完所有同步内容之后运行。但是不同Promise值的回调顺序是不可预测的，永远不要依赖于不同Promise之间的回调顺序来进行程序调度。* 回调未调用 ： 没有任何东西（包括JavaScript错误）可以组织Promise决议，它总会调用resolve和reject处理方法中的一个，即使是超时也有超时模式进行处理。（后续会讲到）* 调用次数过多或过少：由于Promise只能被决议一次，注册的then只会被最多调用一次，所以过多的调用会直接无效。过少就是之前解释的回调未调用的情况。* 未能传递参数值、环境值：任何Promise都只能有一个决议值，如果resolve(…)或者reject(…)中传递了过多的参数，那都只会采纳第一个，而忽略其他的，如果要有多个，那么就要封装到数组或者对象中传递。* 吞掉错误或异常：如果一个Promise产生了拒绝值并且给出了理由，那么这个就会被传给拒绝回调，即使是JavaScript的异常也会这样做。这里的会产生的另一个细节就是如果发生JavaScript错误会导致的同步调用，由于Promise的特性也会将其变为异步的调用。但是试想，如果在then的正确处理函数中出现了错误会发生什么？EX：var p = new Promise( function(resolve,reject){ resolve( 42 );} );p.then( function fulfilled(msg){ foo.bar(); console.log( msg ); // never gets here :( }, function rejected(err){ // never gets here either :( });由于第一个then中未定义bar函数，所以会产生一个错误，但是并不会立即处理，而是会产生另一个Promise，这个新的Promise会由于错误而被拒绝，并没有吞掉错误。因为p已经被决议为正确，所以不会因为fulfilled中间有错误而去调用rejected。* Promise.resolve()方法产生的Promise保证了返回内容的可信任性： 分别考虑resolve方法的参数，1）如果是一个非Promise，非thenable的 立即值，那么就会返回一个用这个值填充的Promise封装，保证了内容的可信任。（即使是错误值） 2）如果是一个Promise，那么也只会产生一个Promise。3）如果传递了一个thenable的非Promise，那么就会试图展开这个值，直到遇到了一个符合1条件的立即值，并封装为Promise通过这个方法，可以保证异步返回给回调函数的值为Promise可信任的。 【链式流】链式流可以应用在会进行多次异步调用的方法中，可以加强代码的清晰度可读性和快速定位错误。 参见下面两个代码段：//来自：http://imweb.io/topic/57a0760393d9938132cc8da9getUserAdmin().then(function(result) { if ( /*管理员*/ ) { getProjectsWithAdmin().then(function(result) { /*根据项目id，获取模块列表*/ getModules(result.ids).then(function(result) { /*根据模块id，获取接口列表*/ getInterfaces(result.ids).then(function(result) { // ... }) }) }) } else { //... }})//链式流getUserAdmin().then(function(reult) { if ( /*管理员*/ ) { return getProjectsWithAdmin(); } else { return getProjectsWithUser(); }}).then(function(result) { /*获取project id列表*/ return getModules(result.ids);}).then(function(result) { /*获取project id列表*/ return getInterfaces(result.ids)}).then(function(result) { // ...})能够产生链式流基于以下两个Promise的特性： * 每次对Promise调用then(…)，它都会产生一个新的Promise。 * 不管从then(…)调用的完成回调（第一个参数）返回的值是什么，它都会被自动设置为被连接Promise的完成，这句话表述了这个新的Promise的值就是这个then调用方法里的return语句，如果没有，那么这个Promise的值就是undefined。 考虑以下代码：var p = Promise.resolve( 21 );p.then( function(v){ console.log( v ); // 21 // fulfill the chained promise with value `42` return v * 2;} )// here&#39;s the chained promise.then( function(v){ console.log( v ); // 42} );上面的代码充分展现了这两条规则。另外两条则充分说明了即使是返回一个Promise甚至返回中有异步调用（这里的异步调用不会被放入事件循环的最后，而是在这里直接延迟执行，后续的then会等待其执行完毕），这两条规则都会正常工作：var p = Promise.resolve( 21 );p.then( function(v){ console.log( v ); // 21 // create a promise and return it return new Promise( function(resolve,reject){ // fulfill with value `42` resolve( v * 2 ); } );} ).then( function(v){ console.log( v ); // 42} );var p = Promise.resolve( 21 );p.then( function(v){ console.log( v ); // 21 // create a promise to return return new Promise( function(resolve,reject){ // introduce asynchrony! setTimeout( function(){ // fulfill with value `42` resolve( v * 2 ); }, 100 ); } );} ).then( function(v){ // runs after the 100ms delay in the previous step console.log( v ); // 42} );如果链中有步骤出错，会直接将这个错误封装为Promise传入到链中的下一个错误处理方法中（原因之前已经讲过）。如果这个错误处理return了一个值，那么这个值会被带入到下一个then处理的正确处理方法中，如果return了一个Promise那么就有可能会使得下一个then延迟调用。如果没有return，那就默认return undefined，同样也是正确处理中。默认的拒绝处理函数：如果产生了错误，但没有拒绝处理函数，那么就会有默认的，默认的所做的事情就是抛出错误，那么这个错误就会继续向下直到有显式的拒绝处理函数。默认的接收处理函数：纯粹将一个promise继续向下传递。如果只有拒绝处理可以将简写为：catch(function(err){…}) 【Promise的错误处理】 由于Promise一旦被决议就不再更改的特性，以下代码可能会导致没有错误处理函数来处理：var p = Promise.resolve( 42 );p.then( function fulfilled(msg){ // numbers don&#39;t have string functions, // so will throw an error console.log( msg.toLowerCase() ); }, function rejected(err){ // never gets here });几种解决方案（除了1都未被ES6标准实现）：1） 在最后加catch，这样会导致的问题就是catch中的函数如果也有错误就无法捕捉。2）有个done函数，就算done函数有错误，也传入done中。 【Promise模式】之前介绍了两种并发的模式，这里有Promise来直接实现： 1） 门：几个均实现再继续进行： Promise.all([….])，参数可以是由立即值，thenable或者Promise组成的数组。 注意：如果传入空数组，那么接下来的内容就会被立即设定为完成。如果有Promise.all中有任意一个被拒绝，那么整个都被拒绝，进入到拒绝处理函数。这个模式传入到完成处理函数中的参数是一个数组，数组中的顺序与all中声明的顺序相同，与其产生的顺序无关。 2） 竞态：几个中只有一个能执行：Promise.race([…])，参数与all相同，但是如果是立即值的竞争那就会显得毫无意义，第一个立即值会胜出。 注意：一旦有一个Promise被完成，那就全部完成，如果第一个是拒绝，那么整个都被拒绝。如果传递空数组，那么Promise会永远都不会被决议。3）超时模式的实现：之前讲到了会有超时模式，这里利用竞态可以来实现：// `foo()` is a Promise-aware function// `timeoutPromise(..)`, defined ealier, returns// a Promise that rejects after a specified delay// setup a timeout for `foo()`Promise.race( [ foo(), // attempt `foo()` timeoutPromise( 3000 ) // give it 3 seconds] ).then( function(){ // `foo(..)` fulfilled in time! }, function(err){ // either `foo()` rejected, or it just // didn&#39;t finish in time, so inspect // `err` to know which });4）几种变体： none：所有的Promise都是拒绝才是完成 any：只要有一个完成就是完成 first：只要第一个Promise完成，那么整个就是完成 last：只有最后一个完成胜出 【Promise的问题】讲了那么多好处。。Promise当然也有问题： 1） 顺序错误处理：可能会有错误被忽略而被全局抛出 2）单一值：只能有一个完成值、拒绝值，否则只能封装解封，这样会显得有些笨重。（这个问题可以通过ES6中的…运算来方便处理~） 3) 单决议：如果讲一个决议绑定到会重复进行的操作上，那么这个决议只会记住重复操作的第一次结果，如：// `click(..)` binds the `&quot;click&quot;` event to a DOM element// `request(..)` is the previously defined Promise-aware Ajaxvar p = new Promise( function(resolve,reject){ click( &quot;#mybtn&quot;, resolve );} );p.then( function(evt){ var btnID = evt.currentTarget.id; return request( &quot;http://some.url.1/?id=&quot; + btnID );} ).then( function(text){ console.log( text );} );//第二次按下就不会有任何操作，不会再次执行resolve4） 惯性：已经有很多回调的代码不会自然的进行Promise改写5）无法取消：如果Promise因为某些原因悬而未决的话，无法从外部阻止其继续执行。6）Promise会对性能有稍稍影响，但总体功大于过。" }, { "title": "JavaScript精进之路 — 函数、闭包与原型链", "url": "/posts/js1/", "categories": "技术", "tags": "JavaScript, 前端, 基础", "date": "2017-08-10 00:03:36 +0800", "snippet": "开这个专题，说实话，就是为了准备校招，补补基础知识吧。今天这个话题是因为这几天看了《JavaScript忍者秘籍》，感觉这本书把这几个内容讲的蛮透彻了，特撰本文，以便日后翻阅。（应该都会以知识点的形式给出吧。）函数 【基本类型】JavaScript中函数为first-class object，typeof的结果是object，没有function这个基本类型，但有可以调用的Function构造器。说到这个就列举一下JavaScript中的几个基本类型： * null （空值） * undefined （未定义） * boolean （布尔） * number （数字） * string （字符串） * object （对象） * symbol （符号）除了null的typeof结果是object以外，其他类型的typeof都是自己的基本类型名称。这几个类型还能有一堆可以讲的地方、之后再写~ 【函数声明】函数的字面量声明有四个部分组成，但有些可以省略，列举如下: * function 关键字 * 可选名称 ，可以匿名，但如果有必须为有效的JavaScript 标识符 * 括号内部一个以逗号分隔的参数列表 * 大括号括起来的函数体 【name属性】有名称的函数name属性永远为自己的名称。关于匿名函数赋予变量后的name属性是什么。。。我这里试出来ES5和ES6都是赋予后的变量名。 【函数调用与this的绑定】在这本《忍者秘籍》里给出了一个理解this绑定的方法：将this理解为运行上下文，this指的就是调用函数时的运行上下文。this的绑定实在运行时候确定的，而不是编译时。（在《你不知道的JavaScript》中详细讲了四种this绑定，以后补~） 这里讲了四种函数调用的方式： * 作为一个函数进行调用 就是作为一般的函数，直接在全局上下文中调用。 * 作为一个方法进行调用 将函数作为一个对象中的方法进行调用，那么这时候this就会绑定在这个对象的上下文中。同时如果在全局中定义一个函数，赋值到对象的属性中，其可以对不同对象进行操作，互不影响。（如图例） //全局的函数function all () { console.log(this.a);}//第1个对象let o1 = { a: &quot;In1&quot;, func1: function () { return this.a }, func2: all }//第2个对象let o2 = { a: &quot;In2&quot;, func: all}let a = &quot;Out&quot; console.log(o1.func1()) //method in object In1o1.func2() //this is o1 In1o2.func() //this is o2 In2 作为构造器进行调用 也就是利用new运算符进行调用。 构造器调用的时候会进行以下步骤： * 创建一个新的对象 * 传递给构造器的参数的对象是this参数，从而成为构造器的函数上下文 * 如果没有显示的返回值，创建的对象则作为构造器的返回值返回（即使有return值，作为构造器调用的时候，也返回新创建的对象）Ex:function Ninja () { this.ninjaName = function () {} return 3}let ninja1 = new Ninja()let ninja2 = new Ninja() //利用构造器得到两个不同的对象console.log(ninja1 === ninja2) //false//作为构造器调用时，返回的是对象而不是return值console.log(ninja1) // Ninja { ninjaName: [Function] }//作为一般函数调用时，返回的是返回值console.log(Ninja()) //3 通过apply()或call()方法进行调用可以随意改变函数的调用上下文，apply与call的区别是除第一个指定函数执行时this绑定参数之外的参数。apply传入参数数组，而call传入全部参数。 【函数参数】函数实际传入的参数和声明时候的参数列表可以不同。 如果传入的比声明的少，那么没有传入数据的声明将会是undefined，若多，则多出来的的传入数据将无法通过变量名的方式访问到。参数可以通过函数的argument属性访问到，这是一个类数组，无法使用大多的数组的自带方法。 【匿名函数】对象内的匿名函数如果被赋值给了另一个对象，会产生引用丢失的问题。 【函数的属性】函数作为对象，可以存储一些参数值，以方便做一些特殊的处理。主要用途有函数存储和自记忆函数。函数存储可以用来存储要调用的函数，自记忆函数可以用来缓存函数已经运行过的结果，减少重复计算（自记忆函数可以通过闭包的方式进行再优化） 【函数的变长参数】可以通过apply方法给出变长参数的数组。（ES6中可以使用…解包）如： let list = [7,9,1,2,0,10]Math.max(list[0],list[1]....) //此处省略，过于麻烦，要列出所有位置Math.max.apply(Math, list) //利用apply可以直接传入数组Math.max(...list) //ES6中可以通过解包符直接传入通过闭包的特性，同样可以实现通过参数个数不同的判断，进行函数的重载。闭包 【闭包的定义】闭包是一个函数在创建时允许自身访问并操作该函数之外的变量时所创建的作用域。-&amp;gt;声明的函数什么时候都可以调用，即使是在作用域消失之后。典型的闭包：let outer = &#39;ninja&#39;let laterfunction outerFunction () { let inner = &#39;samurai&#39; function innerFunction (paramValue) { console.log(inner) console.log(paramValue) console.log(toolate) } later = innerFunction} console.log(toolate) //undefined （用let会报错） var toolate = &#39;ronin&#39; outerFunction() //创建闭包 later(&#39;wakizashi&#39;) //ninja wakizashi ronin 都输出了闭包创建了一个气泡，保护了函数声明那一时间点的作用域里的所有函数和变量，获得了执行操作所需要的所有东西。有三个有趣的结论： 内部函数的参数是包含在闭包中的 作用域之外的所有变量，即使是函数声明之后，但是在函数被调用之前的那些声明也都包含在闭包中 相同的作用域内，尚未声明的变量不能使用（let声明）、值为undefined（var声明） 【闭包的用处】 创建私有变量：利用function的特性，可以创建一个变量无法在外部直接访问，需要用getter和setter，这两个函数就是闭包的作用 回调和计时器：回调函数中可以通过闭包来访问外部的变量 【绑定函数上下文（bind）】bind函数的用法与apply和call不同，简化版的bind：function bind (context, name) { return function () { return context[name].apply(context, arguments) }}//通过闭包的特性，来得到要绑定的函数//系统bind的使用：functionName.bind(newThis)() 【使用闭包实现的函数缓存记忆】 使用到的技巧：每个函数都有自己的上下文，所以函数从来都不是闭包的一部分。但是可以通过创建一个变量引用到这个上下文中（let fn = this，后面的function中可以利用fn调用到之前的this指向的上下文），从而将上下文也通过闭包保存起来。具体的实现可以参见《忍者秘籍》书P103 【函数的即时调用】 通常用于匿名函数，主要作用是可以保护作用域和变量名不污染全局。 并且可以解决迭代问题（同样可以用来解决变量名称过长的问题，将长名称传入即时调用的函数中，在函数中利用参数名进行操作）：for(let i = 0;i &amp;lt; div.length; i++) { (function(n) { div[n].addEventListener(&quot;click&quot;, function(){ alert(&quot;div #&quot; + n + &quot;was clicked&quot;) }, false) })(i)}//通过立即执行函数，直接把i和对应的div绑定，如果不这样做，最后按所有的按钮都会是最后一个i值（因为没有实时绑定）闭包肯定不止这么多内容，以后还会补充《你不知道的JavaScript》的内容原型链JavaScript通过原型链实现继承。 【prototype与new操作的共同使用】 只有通过new操作产生的对象，可以使用构造器函数原型链上的内容，否则对象只能使用自己原型链上的内容。利用这个可以得出，利用构造器函数可以将JavaScript产生类似于类的概念。 【prototype的使用】prototype在对象创建之后如果有改动，所做的改动同样会影响到已经创建的对象上去。对于对象中的引用，先检查是否在自己的声明中存在，如果存在则用自己声明的，如果不存在则循着原型链向上找，找到object根元素，如果仍然不存在，则返回undefined。prototype其实是object隐藏属性constructor的一个属性，所以可以利用这个进行原型链，原型是实时附加在对象上的。 【保持原型链】 用一个对象的实例作为另一个对象的原型，调用方式如下 SubClass.prototype = new SuperClass()这样SubClass的实例不仅拥有原型，更有SuperClass中的所有属性。并且instanceOf SuperClass也会判断正确。注意： 永远不要使用SubClass.prototype = SuperClass.prototype，如果这样做的话所有SubClass上的prototype修改都会影响到SuperClass上，会产生副作用。 【hasOwnProperty()方法】 利用这个方法可以检测属性是否是原生就有的，而不是通过检测原型链得到的。 【一些需要避免的场景】 扩展Object的prototype，这样会影响到所有的对象 扩展Number的prototype 产生原生对象的子类（尽量采用另外写类，但同名方法通过prototype来调用原生对象方法的方法） 通过构造器创建对象不加new操作符（这样做会有可能产生错误得不到对象并且污染全局变量） 这些就是读完《忍者秘籍》的一部分感想和知识点，这本书最精华的部分应该就是这三块的精炼描述了，这本书还讲到了JavaScript的测试方法、正则表达式、定时器、运行时求值、事件与DOM操作以及一些跨浏览器的实践方法。是一本好书（经常参加促销的好书~），可以借来或者买来一读~。以上。" }, { "title": "课程设计前端踩坑记录", "url": "/posts/design/", "categories": "技术", "tags": "课程设计, JavaScript, 前端", "date": "2017-07-16 00:03:36 +0800", "snippet": "使用vue框架完成这个课程设计（第一次使用）已经完成了好长时间了，总结了一下使用框架的10条踩坑经验。（这个老师的课就是个坑，给分超低。）课程设计的代码全部保存在github上，地址：GitHub - MQ-380/Manager: First try on Vue（webproject为所有前端部分）数据的保存与传输 localstorage和sessionstorage的区分 前者会永久存储，即使关闭浏览器也不会消失。后者只要关闭这个对话就会不在保存，比较适合于简单的登录验证。可以用原生的JavaScript语句进行存储和读取。 vuex只能保存一个状态用来跨页面传输数据，并没有保存数据的功能。 vue中的数据传递：子组件 -&amp;gt; 父组件 dispatch父组件 -&amp;gt; 子组件 props(子组件中设置）具体的可以参考以下链接中的文章：Vue.js组件 | Wu Xu 组件在挂载之前获取数据可以再created方法中写入获取数据的语句，参考：数据获取 · GitBook 异步的坑：因为ajax异步的特性，不会等待获取数据结束后再执行后续的方法，所以应该把后续的操作和获取数据的语句写在一个方法块中，可以保证在View的模块中最终可以获取到数据。 Ex：在查询的地方时候通过id查姓名、一定要把后续步骤含到访问http后的then中、如果拆开写成调用方法的话、会一边访问、一边又执行到后续语句，最终导致在向view中传递参数的时候其实根本没有获取到数据。JavaScript语言特性 遍历数组的时候可以用forEach这个方法，但是this指针在这个方法中会改变指向，所以使用要慎重，遇到这个问题或者要遍历一个对象的时候可以选用for…in…Ex: 遍历对象中的所有属性for prop in obj (prop -&amp;gt; 属性 obj[prop] -&amp;gt; 值） 转变日期的格式：toLocaleDateString() 判断undefined会有坑，具体参见： JavaScript判断变量是否为undefined两种方式差异 - snandy - 博客园 判断字符串是否可以转变成数字：isNan(Number(a)) true -&amp;gt; 不可以 false -&amp;gt; 可以 前后端交互 与Spring框架交互用JSON数据，参数只要写在url之后就可以。ajax跨域问题解决： tomcat的web.xml中改写加入```xml CorsFilter org.apache.catalina.filters.CorsFilter CorsFilter /* ```以上。" }, { "title": "基础算法与数据结构 目录", "url": "/posts/catelog/", "categories": "技术", "tags": "数据结构, 算法", "date": "2017-05-27 00:03:36 +0800", "snippet": "（更新至2017.5.9）最前面贴一个普林斯顿的算法课程，用的教材就是《算法（第4版）》，推荐。COS 226: Syllabus (Spring 2017)总GitHub地址：（如果发现有错误，或者您有更好的表述方法，欢迎pull，当然更欢迎给星星。。。）https://github.com/MQ-380/datastructure本博客中分篇地址： 链表 基础二叉树 二叉搜索树 平衡二叉树之红黑树 平衡二叉树之AVL树 图与其基本算法 拓扑排序 最小生成树与并查集 最短路径问题 最大流与最小割 二分图匹配 简单排序算法 快速排序 动态规划 数学" }, { "title": "基础算法与数据结构（十五） 数学", "url": "/posts/math/", "categories": "技术", "tags": "数据结构, 算法, 数学", "date": "2017-05-09 00:03:36 +0800", "snippet": "这个话题实在很宽泛，本人水平难以企及。但是最近一年，深感数学之于计算机学科的重要性。聊列此提纲，便于查阅和学习。前人之述备矣，网络可以解决一切。数论部分数论的题目，感觉看着基础概念有的小学就学过，但做题也能很难，而且完全想不到的感觉。。。就列几个名称吧整除性和约数、素数和合数除法定理（对于任何整数a和任何正整数n，存在唯一整数q和r，满足0&amp;lt;=r&amp;lt;n且a=qn*r )余数和等模公约数与最大公约数欧几里得算法：利用GCD递归定理（GCD(A,B) = GCD(B.A MOD B) )扩展的欧几里得算法：可以计算出d = gcd(a,b) = ax+by中的x,y可以为0或负数互质性唯一因子分解定理（合数a只能用唯一方式分解成若干个素数相乘的形式）欧拉函数欧拉常数求解模线性方程中国余数定理利用反复平方法求幂（快速求a^b mod n，防止爆范围）题目帖一道Google在Kickstart2017 Round A的题目吧，感觉对数学的要求很高。（翻墙必须）Dashboard - Kickstart Round A 2017 - Google Code Jam主要问题就是求n*m的点阵中，可以得到多少个正方形？这个问题在zhihu上有数学相关的讨论，在一些个人blog中有具体解法和另一些可行的想法。https://www.zhihu.com/question/56657137概率论概率论其实对计算机科学来说也是一门十分重要的课，现在十分火热的人工智能和概率论密不可分，以及还有经典算法中的模拟退火也和概率论有关。好好学好概率吧，无论是古典概率和一些需要使用微积分的概率计算方式，虽然当下可能没有什么用，但这真的是内功啊。具体数学/离散数学这两个应该是和计算机关系最大的数学分支了，两个都有经典的教材可以参考，一本是具体数学，一本是离散数学概念及其应用。都是两本大部头，有空的时候可以翻翻，有时真的会幡然醒悟，原来这个可以用数学更好的完成。数学真的是一个很重要的东西，希望每个人都能学好数学，不要有抵触情趣。TAOCP也是巨著，可以参考，全是数学内容，看完这个应该真的就是大神了吧。以上。这是本系列所有的内容。有些详细，有些划水，总而言之，一直以来的支持表示感谢！今まで、ありがとございました！完结于 2017.5.9" }, { "title": "基础算法与数据结构（十四） 动态规划", "url": "/posts/DP/", "categories": "技术", "tags": "数据结构, 算法, 动态规划", "date": "2017-05-07 00:03:36 +0800", "snippet": "转帖说实话，这个话题我也没有这个水平写，转个帖吧转自知乎 【干货】动态规划十问十答 - 知乎专栏【干货】动态规划十问十答ninechapter 专栏 九章算法 网址 http://www.jiuzhang.com 问1动态规划是个什么鸟蛋？答：动态规划是一种通过“大而化小”的思路解决问题的算法。区别于一些固定形式的算法，如二分法，宽度优先搜索法，动态规划没有实际的步骤来规定第一步做什么第二步做什么。所以更加确切的说，动态规划是一种解决问题的思想。这种思想的本质是，一个规模比较大的问题（假如用2-3个参数可以表示），是通过规模比较小的若干问题的结果来得到的（通过取最大，取最小，或者加起来之类的运算）所以我们经常看到的动态规划的核心——状态转移方程都长成这样： f[i][j] = f[i - 1][j] + f[i][j - 1] f[i] = max{f[j] if j &amp;lt; i and …} + 1 f[i][j] = f[0][j - 1] &amp;amp;&amp;amp; judge(1,i)   f[1][j - 1] &amp;amp;&amp;amp; judge(2,i)   … 问2动态规划面试考得多么？答：多。并且越来越多。随着CS从业与求职者的增加，并伴随大家都是“有备而来”的情况下，一般简单的反转链表之类的题目已经无法再在面试中坚挺了。因此在求职者人数与招聘名额的比例较大的情况下，公司会倾向于出更难的面试问题。而动态规划就是一种比较具有难度，又比较“好出”的面试问题。相比其他的算法与数据结构知识来说，贪心法分治法太难出题了，搜索算法往往需要耗费求职者过长的程序编写时间一般也不倾向于出，二叉树链表等问题题目并没有那么多，而且求职者也都会着重准备这一块。因此动态规划这一类的问题，便越来越多的出现在了面试中。问3动态规划快在哪儿？答：动态规划一般来说是“高效”的代名词，因为其解决的问题一般退而求其次的算法只有搜索了。以“数字三角形”一题为例子（Triangle ），在“三角矩阵”中找一条从上到下的路径，使得权值之和最小。如果使用暴力搜索的算法，那么需求穷举出2^(n-1)条路径（n为三角形高度），而使用动态规划的话，则时间复杂度降低到了n^2，完成了质的飞跃。那么究竟为什么这么快呢？原因在于动态规划算法去掉了“无用和重复的运算”。在搜索算法中，假如从A-&amp;gt;B有2条路径，一条代价为10，另外一条代价为100，B-&amp;gt;终点有1024条路径。当我们选择了代价为10的那条路径走到B时，可以继续往下走完1024条路径到终点，但是在此之后，我们再从代价为100的路径从A走到B时，我们可以发现此时无论如何走，都不可能有刚才从10的路径走过来更好，所以这些计算是“无用”的计算，也可以说是“重复”的计算。这就是动态规划之所以“快”的重要原因。问4学习动态规划有什么捷径？答：我们将动态规划的常见类型分为如下几种： 矩阵型 序列型 双序列型 划分型 区间型 背包型 状态压缩型 树型 其中，在技术面试中经常出现的是矩阵型，序列型和双序列型。划分型，区间型和背包型偶尔出现。状态压缩和树型基本不会出现（一般在算法竞赛中才会出现）。每种类型都有着自己的题目特点和状态的表示方法。以矩阵型动态规划为例，一般题目会给你一个矩阵，告诉你有一个小人在上面走动，每次只能向右和向下走，然后问你比如有多少种方案从左上走到右下 (Unique Paths)。这种类型状态表示的特点一般是使用坐标作为状态，如f[i][j]表示走到(i,j)这个位置的时候，一共有多少种方案。状态的转移则是考虑是从哪儿走到(i,j)这个坐标的。而序列型的动态规划，一般是告诉你一个序列；双序列的动态规划一般是告诉你两个字符串或者两个序列。将所做过的动态规划问题按照这些类别进行归类，分析状态的表示方法和状态转移方程的构造方法在每种类型中的近似之处，会让你更快的学会动态规划。问5什么样的问题适合使用动态规划？答：可以使用动态规划的问题一般都有一些特点可以遵循。如题目的问法一般是三种方式： 求最大值/最小值 求可不可行 求方案总数 如果你碰到一个问题，是问你这三个问题之一的，那么有90%的概率是使用动态规划来求解。要重点说明的是，如果一个问题让你求出“所有的”方案和结果，则肯定不是使用动态规划。问6解决一个动态规划问题的步骤是什么？答：首先根据“问5”判断是否是动态规划的问题，如果是，则尝试将其按照“问4”进行分类，找到对应的类别和相似的问题。接着从下面的4个要素去逐步剖析解决这道题： 状态是什么 状态转移方程是什么 状态的初始值是什么 问题要求的最后答案是什么 每个步骤分析完成之后，就基本上解决了整道动态规划的问题。问7怎样优化动态规划的时间？答：一般来说，使用动态规划求解的问题，时间上已经比暴力搜索要优化很多了。但是仍然存在着一些可以优化的空间。通常来说，动态规划的时间优化，有如下两种常见的方式： 通过变换状态优化 通过决策单调优化 对于通过变换状态来优化的问题比较难，需要一些经验和灵感。而对于决策单调的优化，则比较简单，但适用范围不广，一般只适用于划分型动态规划当中，通常这个方法可以将复杂度降低一个数量级。问8怎样优化动态规划的空间？答：动态规划的空间优化只有一种方法，就是使用滚动数组进行优化。以一个二维的动态规划为例子。假如状态转移方程如下：f[i][j] = f[i - 1][j] + f[i][j - 1]。我们可以发现，第i层的状态，已经和第i-2层的状态没有关系了，那么这种情况下，用于存储第i-2层的空间就可以被重复利用。方法非常简单，把数组的第一维对2取模就可以了：f[i % 2][j] = f[(i - 1) % 2][j] + f[i % 2][j-1]。这种方法通常可以将空间复杂度降低一个数量级。问9有什么书籍和参考资料可以推荐么？著名的背包九讲：http://vdisk.weibo.com/s/tanGyi7qM8TVE（也可以直接在网上搜索背包九讲）问10有哪些动态规划题目必须要练习的？在LintCode上包含了30余道动态规划的练习题，都是从实际的面试问题中汇总的精选练习几道题LeetCode上的Stock买卖的题目蛮经典的，可以参考。注意加维度就好。（这篇文章太水了。。。。。" }, { "title": "操作系统复习（一） 概述与进程", "url": "/posts/os1/", "categories": "技术", "tags": "操作系统, 进程", "date": "2017-05-06 00:03:36 +0800", "snippet": "操作系统复习（一） 概述与进程#OperatingSystem概述 操作系统的目标： 方便、有效、扩展能力 操作系统提供的服务：程序开发、程序运行、IO设备访问、文件访问控制、系统访问、错误检测和相应。 操作系统的三个重要接口： 指令系统体系结构（ISA）、应用程序二进制接口（ABI）、应用程序二进制接口（API） OS的发展：串行处理、简单批处理、多道批处理、分时 OS的主要任务：进程管理、内存管理、信息保护和安全、调度和资源管理进程进程定义进程有几种不同的定义方式，以下列举几种 * 一个正在执行中的程序 * 一个正在计算机上执行的程序实例 * 能分配给处理器并由处理器处理的实体 * 一个具有以下特征的单元：一组指令序列的执行，一个当前状态和相关的系统资源集进程的基本元素 基本元素有 程序代码和数据集 在进程的执行中，任意给定一个时间，进程均可唯一表征以下元素 A. 标识符 B. 状态 C.优先级 D.程序计数器（保存下一条指令的地址） E. 内存指针 F. 上下文数据 G.IO状态信息 H.记账信息 进程的五状态模型：创建进程的原因：新的批处理作业，交互登录、OS因为提供一项服务而创建、由现有的进程派生终止进程的原因：正常完成、超过时限、无可用内存、越界、保护错误、算数错误、时间超出、IO失败、无效指令、特权指令、操作员或者OS干涉、父进程终止或请求 挂起状态：将进程换入外存的状态导致挂起的原因：交换、其他OS原因、交互式用户请求、定时、父进程请求 挂起状态的特点： 进程不能立即执行 进程可能是或不是正在等待一个事件。如果是，阻塞条件不依赖于挂起条件，阻塞事件发生不会弄使进程立即被执行。 为阻止进程执行，可通过代理挂起进程，代理可以使自己、父进程或者OS 除非代理是显式地命令OS进行状态转换，否则进程无法从这个状态中转移 OS中的控制结构：4张交互使用的表：内存表、IO表、文件表、进程表 进程控制结构：进程映像：进程所含的程序，数据，栈和PCB 进程控制块（PCB）：属性的集合若OS要管理进程，那么进程映像至少有一部分位于内存中OS需要知道每个进程在磁盘中的位置，并且对于内存中的每个进程须知道其在内存中的位置 三类PCB信息：进程标识信息（系统分配的唯一标识符以及用户标识符） 进程状态信息 进程控制信息 PCB的作用： OS中最重要的数据结构、其集合定义了OS的状态 OS需解决PCB的保护问题 进程的执行模式：用户态、内核态 进程的创建过程：给新进程分配唯一的进程标识符 — 给进程分配空间 — 初始化PCB — 设置正确的链接 — 创建和扩充其他的数据结构 进程的切换：三个时间可以切换：中断 当前指令的外部执行 对异步外部事件的反应陷阱 与当前指令的执行相关 处理一个错误或异常事件系统调用 显示请求 调用OS函数所需的工作：A. 保存处理器上下文环境，包括程序计数器和其他寄存器B. 更新当前进程的PCBC. 当前PCB移至相应的队列D. 选择另一进程执行E. 更新所选择进程的PCBF. 更新内存管理的数据结构G. 回复上下文环境" }, { "title": "基础算法与数据结构（十三） 快速排序", "url": "/posts/quicksort/", "categories": "技术", "tags": "数据结构, 算法, 排序, 快速排序", "date": "2017-05-05 00:03:36 +0800", "snippet": "本节所有图片均选自 http://algs4.cs.princeton.edu/23quicksort/快速排序今天讲述的是一般语言自带的模板排序算法也是应用最广泛的排序算法— 快速排序。并不是说他最快，而是一般情况下它的性能能够达到普遍最优。它仅靠一个辅助栈以及NlgN的时间效率，是其他算法所无法结合的两个优点。快速排序描述快速排序是一种分治的排序算法，它将一个数组分为两个子数组，当两个自数字都有序的时候，整个数组自然有序。快速排序的精髓就在于切分。快速排序的切分首先这是一个切分的示意图。切分的整个过程中满足下面三个条件： 对于某个j，a[j]已经排定。 a[lo] 到 a[j-1]的所有元素都不大于a[j] a[j+1]到a[hi}的所有元素都不小于a[j]一般的策略如下先随意的去a[lo]作为切分元素，即那个将会被排定的元素。然后从数组的左端开始向右扫描直到找到一个大于等于它的元素，再从数组的右端开始向左扫描直到找到一个小于等于它的元素，将这两个元素交换。一直找到两个方向的扫描相遇，这一次的切分结束。切分完毕并不保证切分元素的左右各自有序，只能保证切分元素左半侧，切分元素，切分元素右侧这个大方向上有序，具体的有序还要基本算法去递归排序。轨迹就如下图所示：切分的实现代码：（Java）public int partition (Comparable[] a,int lo,int hi){ int i = lo,j = hi+1; //将数组分为a[lo..i-1],a[i],a[i+1...hi] Comparable v = a[lo]; //切分元素 while(true){ while(less(a[++i],v)) if(i == hi) break; while(less(v,a[--j])) if(j == lo) break; if(i&amp;gt;=j) break; exch(a,i,j); } exch(a,lo,j); //把切分元素放回中间 return j; //返回切分元素的位置}基本算法写完切分，接下来真正进入快速排序的算法部分了，其实切分完了快速排序也就完成了四分之三了。算法的基本思路就是切分当前部分，把大于切分元素和小于切分元素的元素分开，剩下的在进行排序。到了最底层，就可以保证元素直接都是有序的。这个其实也就是归并排序的反过来思考。Java算法代码：public class QuickSort{ public void sort(Comparable[] a,int lo,int hi){ if(hi &amp;lt;= lo) return; int j = partition(a,lo,hi); sort(a, lo, j-1); sort(a, j+1, hi); }}快速排序的精髓就在之前的切分，递归切分就能通过数学归纳法证明整体有序了。快速排序运行图：基本算法的几个细节问题 别越界 终止循环条件 处理切分元素值有重复的情况。 要把元素放入到正确位置然后终止递归。快速排序的继续改进通过三向快速排序可以继续改进这个快速排序，具体可以参见算法（第4版）这本书。" }, { "title": "基础算法与数据结构（十二） 简单排序算法", "url": "/posts/simplesort/", "categories": "技术", "tags": "数据结构, 算法, 排序, 简单排序", "date": "2017-05-04 00:03:36 +0800", "snippet": "排序算法今天开始，将进入一个新的领域，各种各样的排序算法。排序算法可以用一本TAOCP分册的篇幅来讲述，这里肯定不能全部讲到。今天主要来写一点简单基础的排序算法。排序算法的时间复杂度一般来讲基于比较来排序的算法，最快的时间复杂度为O(nlgn)。来给出一些常见排序算法的时间复杂度：本文里将一起讲述插入排序、选择排序、冒泡排序、归并排序和希尔排序5种排序算法。一些代码的共用部分排序算法一般来说都需要进行比较和交换位置，有一些代码进行复用。public boolean less(Comparable v, Comparable w){ return v.compareTo(w) &amp;lt; 0;}public void exch(Comparable[] a, int i, int j){ Comparable t = a[i]; a[i] = a[j]; a[j] = t;}插入排序描述插入排序简单来说，和理牌的方式基本一致，一个一个向后扫描，将一个未排序的数组元素向前插入到一个合适的位置，然后将其余所有元素向后移一个位置。情况分析最坏的情况，就是要排序的数组完全倒序，需要的移动次数最多，如果接近已经排序了，那么插入排序的移动次序较少。一些趣闻插入排序需要的交换操作和数组中倒置的数量相同，需要的比较次数大于等于倒置的数量，小于等于倒置的数量加上数组的大小减一。Java实现public class Insertion{ public static void sort(Comparable[] a){ int N = a.length; for(int i = 1;i&amp;lt;N;i++){ for(int j = i;j&amp;gt;0 &amp;amp;&amp;amp; less(a[j],a[j-1]);j--){ exch(a,j,j-1); } } }}选择排序描述首先，找到数组中最小的那个元素，其次，将它和数组的第一个元素交换位置（如果第一个元素就是最小元素那么它就和自己交换）。再次，再剩下的元素中找到最小的元素，将它与数组的第二个元素交换位置。如此往复，直到将整个数组排序。Java实现public class Selection{ public static void sort(Comparable[] a){ int N = a.length; for(int i = 0;i&amp;lt;N;i++){ int min = i; for(int j = i+1;j&amp;lt;N;j++){ if(less(a[j],a[min]) min = j; } exch(a,i,min); } }}冒泡排序描述冒泡排序算是一个比较经典的排序法了。首先从队首取一个元素，向后寻找，直到找到一个比它小的元素，然后交换位置之后，再从第二个元素开始循环上述的方式，直到所有的元素排完序。Java实现public class Bubble{ public static void sort(Comparable[] a){ int N = a.length; for(int i = 0;i&amp;lt;N;i++){ int cur = i; for(int j = i+1;j&amp;lt;N;j++){ if(less(a[cur],a[j]) exch(a,cur,j); } } }}归并排序描述归并排序其实在第一次链表的时候就已经讲到了。归并排序就是一个二分法的应用。归并排序将两个有序的数组归并成一个更大的有序数组。也就是将一个数组排序，可以先递归地将它分成两半分别排序，然后将归并起来。可以得到比之前的几个排序算法更好的时间复杂度。归并排序的几种方式 原地归并 自顶向下 自底向上原地归并的实现方式原地归并就是创建一个新的数组，然后将排完序之后的内容放回到原数组中,也是另外两个的基础归并的方式。public static void merge(Comparable[] a,int lo,int mid, int hi){ int i = lo, j=mid+1; for(int k = lo;k &amp;lt;= hi;k++){ aux[k] = a[k]; } for(int k = lo;k&amp;lt;=hi;k++){ if( i &amp;gt; mid ) a[k] = aux[j++]; else if(j &amp;gt; hi) a[k] = aux[i++]; else if(less(aux[j],aux[i])) a[k] = aux[j++]; else a[k] = aux[i++]; }}该方法将所有的元素复制到aux中，然后在归并到a中。用了4个条件判断进行排序的下一步判断。原地归并的图示：摘选自 《算法（第4版）》自顶向下的归并排序public static void sort(Comparable[] a){ aux = new Comparable[a.length]; sort(a,0,a.length-1);}public static void sort(Comparable[] a,int lo,int hi){ if(hi&amp;lt;=lo) return; int mid = lo + (hi-lo)/2; sort(a, lo , mid); //排左半边 sort(a, mid+1, hi); //排右半边 merge(a, lo, mid, hi);}图示：自底向上的归并排序public static Comparable[] aux;public static void sort(Comparable[] a){ int N = a.length; aux = new Comparable[N]; for(int sz = 1;sz&amp;lt;=N;sz = sz+sz){ for(int lo = 0;lo&amp;lt;N-sz;lo+=sz +sz){ merge(a,lo,lo+sz-1,Math.min(lo+sz+sz-1,N-1); } }}运行轨迹图示：最后来一个可视化的运行轨迹。希尔排序描述希尔排序是一个基于插入排序的快速的排序算法。插入排序只能交换相邻的元素，希尔排序为了加快速度简单的改进了插入排序，交换不相邻的元素已对数组的局部进行排序，并最终用插入排序将局部有序的数组排序。希尔排序的思想是使数组中任意间隔为h的元素是有序的，这样的数组被称为h有序数组。一个h有序数组就是h个相互独立的有序数组编制在一起组成的一个数组。如果h很大，我们就能将元素移动到很远的地方。希尔排序就是利用h递增来进行排序。java代码public void sort(Comparable[] a){ int N = a.length; int h = 1; //找到最大的h，从大到小进行h排序 while(h &amp;lt; N/3) h = 3*h + 1; while(h &amp;gt;= 1){ //将数组变为h有序 for(int i = h;i&amp;lt;N;i++){ //将a[i]插入到a[i-h]，a[i-2*h],a[i-3*h]...之中 for(int j = 1;j&amp;gt;=h &amp;amp;&amp;amp; less(a[j],a[j-h]);j-=h){ exch(a,j,j-h); } } h = h/3; } }希尔排序的几张图，第一个是h有序数组的图示：排序的图示：可视化图示：" }, { "title": "基础算法与数据结构（十一） 二分图匹配", "url": "/posts/match/", "categories": "技术", "tags": "数据结构, 算法, 图, 二分图匹配, 匈牙利算法", "date": "2017-05-03 00:03:36 +0800", "snippet": "二分图匹配概述首先是什么二分图？有一个无向图G = (U ∪ V, E) ，所有的顶点可以划分为U，V两个不相交的顶点集，那么就是一个二分图。二分图的最大匹配就是找到两个集合可以通过边相连且一一对应的最多对数。如果能够得到一个所有顶点都可以一一对应，那么这个图称为完美匹配。二分图匹配的应用二分图匹配问题可以用来解决任务分配的问题，求得可以被分配的最多任务数目之类的问题。二分图匹配的解法一 — 利用最大流如何利用最大流解决这个二分图匹配？换个想法，把所有的连接边作为一个有向图，从左边到右边的顺序建立这个流网络。设立超级源点，超级汇点，并且所有边的最大容量只有1。也就是能够得到的最大流量也就是能够通过这个网络图走到右边节点的个数。如果有匹配那么就能走通，所以就能用这个想法解决这个二分图匹配问题。利用最大流就是这样可以解决。匈牙利算法利用一个匈牙利算法也可以解决这个二分图匹配的问题。这个算法在网络上可以找到很多讲解的优秀文章，前人之述备矣，也就不再另外造轮子了。" }, { "title": "基础算法与数据结构（十） 最大流最小割", "url": "/posts/biggest/", "categories": "技术", "tags": "数据结构, 算法, 图, 最大流最小割", "date": "2017-05-02 00:03:36 +0800", "snippet": "流网络的基本概念和性质 定义：流网络G = (V, E)是一个有向图，图中每条边有一个非负的容量值c，不会有一条边是另一条边的反向边（即不存在u-&amp;gt;v 和 v-&amp;gt;u同时存在）。且存在一个源点和一个汇点。 容量限制：对于所有的节点，有0≤f(u,v)≤c(u,v) 现在的流量不大于最大容量。 流量守恒：对于除了源点和汇点的节点，流入的流量等于流出的流量。类流网络的转换根据之前的定义，可以知道有一些带权图并不符合流网络的定义，下面将对两种可以转换为流网络的有向图进行分析： 有反向边的图：反向边与正向边的容量可以互相抵消 有多个源点汇点的图：创建两个节点，作为超级源点和超级汇点。 无向图：创建一个相同容量的反向边。最大流问题本部分问题可以在纸上画一些简单的图进行模拟，可以更好帮助理解。（没错就是我懒得画图了。。。）最大流问题的目标在一个流网络中，找到一个最大流量，这个流量可以通过这个流网络。最大流问题的一些基本概念约定，正向边是原有网络中就有的边，反向边为新增的边。 残存网络：仍有空间对网络流进行调整的边组成。简单来说，就是在原来的基础上，为每条边新增了一条反向边的图。这条反向边的容量初始化的时候为0，然后随着网络中流的增加，原有的边的容量逐渐较少，这条新增的反向边的容量等于当前在这条边上的流的值。残存网络严格意义上来讲不属于流网络，但其满足所有流网络的性质。利用残存网络可以知道当前还可以增加多大的流。 增广路：是残存网络中一条从源节点到汇点的简单路径。当前增广路上可以增加的流量最多为原有正向边上的容量。 残存容量：当前增广路p上可以为每条边增加的最大值。也就是残存网络中正向边的容量。 图的割：图G = (V,E) 的一个切割(S,T) 将结点集合V划分为S和T = V-S 两个集合。 割的净流量：f(S,T) 可以定义为所有从S中的结点到T中结点的流量的和，减去T中结点到S中结点流量的和。 割的容量：c(S,T)等于所有从S中的结点到T中结点的容量的和。 最小割：所有割中，容量最小的一个。 最大流最小割定理：设f为流网络G = (V, E)中的一个流，该流网络的源点为s，汇点为t，那么下面三个条件是等价的：1） f是G的一个最大流 2） 残存网络不在包括增广路径 3）|f| = c(S,T) 隐含意义：当一个流为最大流时，其必定为最小切割的容量。 最小割的意义：保证没有一条从s到t的路径，需要删去的边的最小容量。 Ford-Fulkerson方法 这个方法依赖于之前所讲的最大流最小割定理，有这个定理的保证，可以确保这个方法最后计算出来的流就是最大流。 这个定理的证明可以参考算法导论的相关部分（P414）语言描述为：每一次迭代对流进行增加，知道残存网络中不再存在一个增广路径。伪代码描述：FORD-FULKERSON-METHOD(G,s,t)1. initialize flow f to 02. while there exists an augmenting path p in the residual network G3. augment flow f along p4. return fFord-Fulkerson算法上面那个是方法，就是一个最大流的方法，因为这个方法有很多不一样时间复杂度的实现方式，这部分主要讲这个算法一个基本实现，这个实现就是通过就的DFS进行搜索，时间复杂度估算为O(F|E|) 其中F为最大流的值，在实际应用中属于比较快，有更快的先使用BFS再DFS的算法，也附在后，但不进行详细注解。//利用邻接表存储图来实现的一个最大流算法的实现struct edge{ int to; int cap; int rev; //反向边的编号}vector&amp;lt;edge&amp;gt; G[MAX_V]; //用向量模拟的邻接表bool used[MAX_V];void addEdge(int from,int to,int cap){ //加入正向边，反向边的编号正好为未加反向边是那个点所含有的边数 G[from].push_back((edge){to, cap, G[to].size()}); //加入反向边，反向边对应的反向边就是正向边，就是from的size减掉1 G[to].push_back((edge){from,0,G[from].size()-1});}int dfs(int v,int t,int f){ //到达结束点，返回当前的最大流 if(v == t) return f; used[v] = true; for(int i = 0;i&amp;lt;G[v].size();i++){ //遍历v的所有边 egde &amp;amp;e = G[v][i]; //to节点没有访问过，代表这条边不是返回的边，并且还有容量可以增加。 if(!used[e.to] &amp;amp;&amp;amp; e.cap &amp;gt; 0){ //从to结点继续向前，最大流量就是现在的流量和残余流量中小的那个 int d = dfs(e.to, t, min(f, e.cap); if(d &amp;gt; 0){ e.cap -= d; G[e.to][e.rev].cap += d; return d; } } } //返回0意味着最后找到的d为0，也就是没有边可以从s-&amp;gt;t了 return 0;}int max_flow(int s,int t){ int flow = 0; for(;;){ memset(used,0,sizeof(used); int f = dfs(s, t, INF); //f返回0时就代表着在图中不再存在一个可以走通的增广路径，那么就是最大流了 if(f == 0) return flow; //还有路径可以走，那就增加到最大流中。 flow+=f; }}接下来介绍一个更快一点的最大流算法，这个算法的复杂度是O(|E||V|^2)这个算法的思想就是利用一个广度优先搜索对所有的节点进行一个编号，这样就可以根据这个分层的编号简化计算最大流中的深度优先搜索。代码如下：不做详细解释struct edge{int to, cap, rev;}vector&amp;lt;edge&amp;gt; G[max_v];int level[max_v]; //顶点到源点的距离编号int iter[max_v]; //当前弧，比当前弧小的已经无用了void addEdge(int from,int to,int cap){ //加入正向边，反向边的编号正好为未加反向边是那个点所含有的边数 G[from].push_back((edge){to, cap, G[to].size()}); //加入反向边，反向边对应的反向边就是正向边，就是from的size减掉1 G[to].push_back((edge){from,0,G[from].size()-1});}void bfs(int s){ memset(level, -1, sizeof(level)); queue&amp;lt;int&amp;gt; que; level[s] = 0; que.push(s); while(que.empty()){ int v = que.front(); que.pop(); for(int i = 0;i&amp;lt;G[v].size;i++){ edge&amp;amp; e = G[v][i]; if(e.cap &amp;gt; 0 &amp;amp;&amp;amp; level[e.to] &amp;lt; 0){ level[e.to] = level[v] + 1; que.push(e.to); } } }}void dfs(int v,int t,int f){ //到达结束点，返回当前的最大流 if(v == t) return f; for(int i = 0;i&amp;lt;G[v].size();i++){ //遍历v的所有边 egde &amp;amp;e = G[v][i]; //继续向下一层，并且还有容量可以增加。 if(e.cap &amp;gt; 0 &amp;amp;&amp;amp; level[v] &amp;lt; level[e.to]){ //从to结点继续向前，最大流量就是现在的流量和残余流量中小的那个 int d = dfs(e.to, t, min(f, e.cap); if(d &amp;gt; 0){ e.cap -= d; G[e.to][e.rev].cap += d; return d; } } } //返回0意味着最后找到的d为0，也就是没有边可以从s-&amp;gt;t了 return 0;}int max_flow(int s,int t){ int flow = 0; for(;;){ bfs(); if(level[t] &amp;lt; 0) return flow; memset(iter,0,sizeof(iter)); int f; while((f = dfs(s,t,INF)) &amp;gt; 0) { flow+=f; } }}最大流问题的一些内容就是这些，典型例题暂缺。下一节将会讲述最大流问题的一个典型应用： 二分图匹配。" }, { "title": "基础算法与数据结构（九） 最短路径问题", "url": "/posts/shortest/", "categories": "技术", "tags": "数据结构, 算法, 图, 最短路径", "date": "2017-05-01 00:03:36 +0800", "snippet": "最短路径问题首先定义最短路径是什么。最短路径就是在有权图中，从顶点s到顶点t的路径中权重最小的那条路。同样，由于可能出现一点到另一点相同权重的路径，所以最短路径并不是唯一的。本章节讨论有向图的最短路径问题，无向图可以转换为有向图进行讨论。加权有向图的数据结构struct DirectedEdge{ int from; int to; int weight; //getter setter省略}利用这样的数据结构存储边，可以利用邻接表来进行图的存储，具体如下列代码：int V;int E;vector&amp;lt;DirectedEgde&amp;gt; adj[V];void addEdge(DirectedEgde e){ adj[e.from()].add(e); E++;}存储S-&amp;gt;V最短路径的一个数据结构，需要有两个元素组成，一个是edgeTo用来记录本点V到本点父节点A(A-&amp;gt;V)的这条路径，也就是S-&amp;gt;V最短路径中的最后一条边。另一个就是distTo用来记录从S-&amp;gt;V最短路径的权重。约定edgeTo[S]的值为null，distTo[S]的值为0，初始定义其余distTo的值为无穷大。边的松弛操作distTo数组在一开始的时候除源节点外均为无穷大。所以定义一个边的松弛操作。简单来说，就是判断S-&amp;gt;W的最短路径是不是需要从第三点V经由可以使路径根更短，如果是，那么更新S-&amp;gt;W最短路径的数据。边的松弛代码：void relax(DirectedEdge e){ int v = e.from(); int w = e.to(); //直接到W的距离比经由V更长 if(distTo[w] &amp;gt; distTo[v] + e.weight()){ distTo[w] = distTo[v] + e.weight(); edgeTo[w] = e; }}对于一个边可以进行边的松弛操作，如果对于一个图，那么可以进行顶点的松弛工作，就是遍历一个顶点所有的边，分别进行边的松弛操作，那么就可以逐渐找到到达每个顶点的最短路径算法。void relax(EdgeWeighteDiagraph G,int v){ for(DirectedEdge e : G.adj(v)){ int w = e.to(); if(distTo[w] &amp;gt; distTo[v] + e.weight()){ distTo[w] = distTo[v] + e.weight(); edgeTo[w] = e; }}通用算法将distTo[s]初始化为0，其他均为无穷大，那么只要放送G中的任意边直到不存在有效边（还没有遍历到的边）为止，这时候distTo中的值即为S到任意点的最短距离。因为这个算法不规定遍历的顺序，所有效率较低。Dijkstra算法(巧记 D + ijk(循环遍历要用的三个字母) + stra ）这个算法可以解决 边权重非负的加权有向图的单起点最短路径问题。语言描述将distTo数组按照之前约定初始化，然后将distTo最小的非树顶点（还没有走到的点中距离起点最近的点）放送并加入树中（连接到最短路径中）。直到所有可以到达的顶点均已经计算出非无穷大的最短路径或者所有无法到达的顶点均为无穷大。数据结构需要在distTo和edgeTo的基础上增加一个优先队列p，用来保存需要放松的顶点以及快速确定下一个要被放松的顶点。复杂度空间O(V)，时间O(ElogV)代码描述//此处或许无法通过编译，优先队列的第一个int为顶点号，第二个为这个顶点的distTo值，根据第二个排序优先。change含义为改变已有值，insert为插入struct Dijkstra{ vector&amp;lt;DirectedEged&amp;gt; edgeTo; vector&amp;lt;int&amp;gt; distTo; priority_queue&amp;lt;pair&amp;lt;int,int&amp;gt;&amp;gt; pq; void DijkstraRun(EdegWeightedDigraph G,int s){ for(int v = 0;v&amp;lt;G.v();v++){ if(v == s) distTo.push_back(0); else distTo.push_back(INT32_MAX); edgeTo.push_back(new DirectedEdge()); } pq.insert(s); while(!pq.empty()){ int v = pq.front(); pq.pop(); relax(G,v); } void relax(EdgeWeighteDiagraph G,int v){ for(DirectedEdge e : G.adj(v)){ int w = e.to(); if(distTo[w] &amp;gt; distTo[v] + e.weight()){ distTo[w] = distTo[v] + e.weight(); edgeTo[w] = e; //如果含有这个顶点w了，那么就更新从起点到这个点的w在优先队列中的优先度。 if(pq.contains(w)) pq.change(w,distTo[w]); else pq.insert(w,distTo[w]); } } }}适用题目 是否存在一条s到v的路径，如果有找出。 给定两点之间的最短路径： 从优先队列取出t之后即可停止继续搜索。 任意顶点对之间的最短路径：遍历所有顶点，对每个顶点做dijkstra算法。拓扑排序的扩展 — 无环加权有向图中的最短路径算法这个算法基于有向图中无环的基础（不适用于无向图），通过拓扑排序的推进顺序更新所有顶点的最短路径值。证明思想为因为某一条边v-&amp;gt;w的松弛只会进行一次，在v被放松的时候，在松弛结束前distTo[w] &amp;lt;= distTo[v]+e.weight这个不等式成立，如果按照拓扑排序顺序进行计算，因为v被放松后不会再处理和v有关的边了，所以distTo[v]的值是不会变化的，而distTo[w]只会不断减小，所以当s可达的顶点全部走一遍之后就可以等到最短路径了。这个算法的时间复杂度为O(E+V)算法代码实现从略，只需要在最开始加一步拓扑排序，得到排序后的结果，将上面D算法中的优先队列换成这个排序结果进行松弛顶点即可。Bellman-Ford算法 — 解决含有负权重边的图的最短路径含有负权重环的图无法计算最短路径。这个算法可以用来找负权重环。实现一个队列来更新下一步需要更新distTo值的顶点，根据这个队列来进行更新操作。时间复杂度为O(EV)，空间为O(V)图中可以找到负权重环的条件：将所有边放送V轮之后，当且仅当队列非空时有向图存在从起点可以到达的负权重环。因为如果含有负权重环的话，更新了W之后，如果在循环之后队列中又出现W，W会重复出现，那么就会发生V轮（边数轮）之后，队列中非空。上代码：(java代码）public class BellmanFord{ private int[] distTo; //起点到某顶点的最短路径 private DirectedEdge[] edgeTo; //起点到某顶点的最后一条边 private boolean[] onQ; //是否在队列中 private Queue&amp;lt;Integer&amp;gt; queue; //预定被放松的顶点 private int cost; //relax调用次数 private Iterable&amp;lt;DirectedEdge&amp;gt; cycle; //edgeTo中是否含有负权重环 public BellmanFord(EdgeWeightedDigraph G,int s){ distTo = new int[G.V()]; //G.V() 边的条数 edgeTo = new DirectedEdge[G.v()]; onQ = new boolean[G.V()]; queue = new Queue&amp;lt;Integer&amp;gt;(); for(int v = 0 ;v&amp;lt;G.V();v++){ distTo[v] = INT32_MAX; } distTo[s] = 0; queue.enqueue(s); onQ[s] = true; while(!queue.empty() &amp;amp;&amp;amp; !hasNegativeCycle()){ int v = queue.dequque(); onQ[v] = false; relax(G,v); } } private void relax(EdgeWeightedDigraph G,int v){ for(DirectedEdge e : G.adj(v)){ int w = e.to(); if(distTo[w] &amp;gt; distTo[v] + e.weight()){ distTo[w] = distTo[v] + e.weight(); edgeTo[w] = e; //如果更新的w不在队列中，那么加入队列，因为和w有关的边需要更改最短路径。 if(!onQ[w] { queue.enqueue(w); onQ[w] = true; } } //对于顶点E，经过V轮后算法还未能结束，那么检测是否含有环,有环就结束。 if(cost++%G.V() == 0){ findNegativeCycle(); if (hasNegativeCycle()) return; } } } private void findNegativeCycle(){ int V = edgeTo.length; EdgeWeightDigraph spt; spt = new EdgeWeightedDigraph(V); //根据现在的V画出现在有的图 for(int v = 0;v&amp;lt;V;v++){ if(edgeTo[v] != null) spt.addEdge(edgeTo[v]); } //cf根据构建出来的图中找出环 EdgeWeightedCycle cf; cf = new EdgeWeightedCycle(spt); cycle = cf.cycle(); } private boolean hasNegativeCycle(){ return cycle != null; }}利用dfs找出环的算法可以参见 EdgeWeightedDirectedCycle.java套汇问题就是一个典型的找负权重环问题。" }, { "title": "基础算法与数据结构（八） 最小生成树与并查集", "url": "/posts/graphtree/", "categories": "技术", "tags": "数据结构, 算法, 图, 最小生成树, 并查集", "date": "2017-04-28 00:03:36 +0800", "snippet": "什么是最小生成树?在图G上，如果一个强连通图上的每条边上都有一个权重值，权重值可以是一个负数或零。那么一定可以找到一个无环边子集能够把这个图上的所有的点能够连接起来。这个五环边子集的权重和如果是所有子集中最小的，那么这个边子集构成的一定是一棵树，所以把它称之为 最小生成树。同样的，最小生成树不一定是唯一的。最小生成树的性质 最小生成树的边数目一定是V-1，V是图的顶点数。如何产生一棵最小生成树？最小生成树有两种算法可以用来生成，Kruskal算法和Prim算法。这两种算法都是一种贪心算法，每一步都得到当前一部的最优选择，虽然贪心算法不能够保证全局最优，但是在最小生成树的算法中可以证明得到一棵全局最优的最小生成树。（在算法导论中可以用“安全边”的概念进行证明，由于需要一些概念，避免篇幅过长，此处从略，可详见算法导论中文版P363-364）这里给出两种算法都通用的一个求出的思想伪代码，也是写在《算法导论》中的伪代码：GENERIC-MST(G,w)1 A = ∅ 2 while A does not form a spanning tree3 find an edge(u,v) that is safe for A4 A = A ∪ {(u,v)}5 return A两种算法的区别就是找到第3行中所写的安全边方法的区别。并查集（Union-Find）在讲述这两个算法之前，先讲述一个数据结构用来高效判断两点是否属于同一集。这个数据结构就是并查集。并查集能够完成的事情就是得到一个并的指令或者查询的指令，从要完成的功能上来看也是非常容易的。并查集是个高效的数据结构，不过可能会产生不高效的情况下，所以多加了一部加权的步骤，把小树的根节点连接到大树的根节点上。并查集的算法代码给出，此处为JAVA代码public class WeightedQuickUnionUF{ private int[] id; //父节点索引 private int[] sz; private int count; //连通分量的数量 public WeightedQuickUnionUF(int n){ count = n; id = new int[n]; //初始化时，所有结点的父节点均为自己 for(int i=0;i&amp;lt;n;i++) id[i] = i; sz = new int[n]; //根节点对应的树的高度为1 for(int i=0;i&amp;lt;n;i++) sz[i] = 1; } public int getCount(){ return count; } public boolean isConneted(int p,int q){ //找到最后的根节点，如果两个根节点是相同的，那么就属于同一个集合 return find(p) == find(q); } public int find(int p){ //由于初始化的原因，只有当父节点是自己的时候，就是最后的根节点 while(p != id[p]) p = id[p]; return p; } //返回是否合并 public bool union(int p,int q){ int i = find(p); int j = find(q); //如果已经属于了同一个根节点，那么不需要合并了 if( i == j ) return false; //小的树合并到大的树上 if(sz[i] &amp;lt; sz[j]){ id[i] = j; sz[j] += sz[i]; }else{ id[j] = i; sz[i] += sz[j]; } count--; //连通分量减少 return true; }}以上就是并查集的JAVA实现代码，其实其他语言的实现方法都差不多。不过上面的这个算法并不是最佳的，最好的算法是 路径压缩的加权并查集算法 才是最优的，均摊成本无限接近O(1)。上面的这个加权算法，union和find的时间复杂度都是lgN。Kruskal算法这个算法找到安全边的方法是，每次在所有的边中找到权值最小的，并且连接的两个顶点不在同一个集合中，那么就将这个边加入生成树中，并且union这两点。Kruskal算法的时间复杂度为O(ElgV) E为边的数目，V为顶点的数目。因为需要对边进行排序，所以在这个中需要新增加一个边的集合，容易进行排序。先上代码：struct edge{ //u,v为边的起点终点，w为权值 int u; int v; int w;}vector&amp;lt;edge&amp;gt; e; //边的集合vector&amp;lt;edge&amp;gt; tree; //答案的最小生成树 bool cmp(edge p,edge q){ return p.w &amp;lt; q.w;}WeightedQuickUnionUF UF;void Kruskal(){ UF = new WeightedQuickUnionUF(e.size()); sort(e.begin(),e.end(),cmp); ans = 0; //权值的答案 for(int i = 0; i &amp;lt;= e.size(); i++){ //合并了，需要加入树，加上权值。 if(UF.union(e[i].u,e[i].v)){ ans += e[i].w; tree.push_back(e[i]); } } }图示：摘自算法导论Prim算法Prim算法找安全边的想法主要是，从一个根节点开始，找这个根节点连接的边中最小权值的边加入最小生成树，一直到这棵树找到所有的节点。在prim算法中，需要一种优先队列的数据结构，这种数据结构在C++中有内置的STL实现，这里省略了具体讲解，总而言之优先队列会根据某种给定的排序算法，每次取出的值都是最大的或者最小的。Prim算法的实现具体代码如下：参考了geeksforgeeks网站，所以注释都是英文（MST - 最小生成树）// STL implementation of Prim&#39;s algorithm for MST#include&amp;lt;bits/stdc++.h&amp;gt;using namespace std;# define INF 0x3f3f3f3f // iPair ==&amp;gt; Integer Pairtypedef pair&amp;lt;int, int&amp;gt; iPair; // This class represents a directed graph using// adjacency list representationclass Graph{ int V; // No. of vertices // In a weighted graph, we need to store vertex // and weight pair for every edge list&amp;lt; pair&amp;lt;int, int&amp;gt; &amp;gt; *adj; public: Graph(int V); // Constructor // function to add an edge to graph void addEdge(int u, int v, int w); // Print MST using Prim&#39;s algorithm void primMST();}; // Allocates memory for adjacency listGraph::Graph(int V){ this-&amp;gt;V = V; adj = new list&amp;lt;iPair&amp;gt; [V];} void Graph::addEdge(int u, int v, int w){ adj[u].push_back(make_pair(v, w)); adj[v].push_back(make_pair(u, w));} // Prints shortest paths from src to all other verticesvoid Graph::primMST(){ // Create a priority queue to store vertices that // are being preinMST. This is weird syntax in C++. // Refer below link for details of this syntax // http://geeksquiz.com/implement-min-heap-using-stl/ priority_queue&amp;lt; iPair, vector &amp;lt;iPair&amp;gt; , greater&amp;lt;iPair&amp;gt; &amp;gt; pq; int src = 0; // Taking vertex 0 as source // Create a vector for keys and initialize all // keys as infinite (INF) vector&amp;lt;int&amp;gt; key(V, INF); // To store parent array which in turn store MST vector&amp;lt;int&amp;gt; parent(V, -1); // To keep track of vertices included in MST vector&amp;lt;bool&amp;gt; inMST(V, false); // Insert source itself in priority queue and initialize // its key as 0. pq.push(make_pair(0, src)); key[src] = 0; /* Looping till priority queue becomes empty */ while (!pq.empty()) { // The first vertex in pair is the minimum key // vertex, extract it from priority queue. // vertex label is stored in second of pair (it // has to be done this way to keep the vertices // sorted key (key must be first item // in pair) int u = pq.top().second; pq.pop(); inMST[u] = true; // Include vertex in MST // &#39;i&#39; is used to get all adjacent vertices of a vertex list&amp;lt; pair&amp;lt;int, int&amp;gt; &amp;gt;::iterator i; for (i = adj[u].begin(); i != adj[u].end(); ++i) { // Get vertex label and weight of current adjacent // of u. int v = (*i).first; int weight = (*i).second; // If v is not in MST and weight of (u,v) is smaller // than current key of v if (inMST[v] == false &amp;amp;&amp;amp; key[v] &amp;gt; weight) { // Updating key of v key[v] = weight; pq.push(make_pair(key[v], v)); parent[v] = u; } } } // Print edges of MST using parent array for (int i = 1; i &amp;lt; V; ++i) printf(&quot;%d - %d\\n&quot;, parent[i], i);}图示：摘自算法导论例题暂缺。" }, { "title": "基础算法与数据结构（七） 拓扑排序", "url": "/posts/tuopu/", "categories": "技术", "tags": "数据结构, 算法, 图, 拓扑排序", "date": "2017-04-27 00:03:36 +0800", "snippet": "什么是拓扑排序？拓扑排序和其他排序算法不同，它主要是给有向无环图中所有结点的一种线性排序。依据什么排序呢？如果有一条从u指向v的边，那么u在排序结果中一定会在v前面。正因如此，所有拓扑排序只对有向无环图有效，如果图中存在任何形式的环路，那么拓扑排序将不会对其产生作用。简而言之，拓扑排序就是一种能把图放在一条水平线上铺开的算法。但是重要一点：拓扑排序算法的结果可能是不同的。图示：某教授早上起床后的动作顺序，a为普通图，b为拓扑排序后的图。（算法导论图22-7）拓扑排序的算法表示拓扑排序可以利用DFS进行，就是DFS的扩展应用，主要思想就是：当一个结点出发的DFS完全完成之后，那么这个结点已经没有任何的后继结点可以遍历，那么这个结点就可以放在拓扑排序的结果中，结果保存在一个栈中。因为放入了栈中，其实就是放在拓扑排序的头部。（已经没有出度了）。代码思想如下：1、 调用dfs_travel()；2、 在dfs_travel()每次调用dfs()的过程中，都记录了顶点s的完成时间，将顶点s按完成顺序保存在存放拓扑排序顺序的栈topoSort中。这样，该数组就存放了按先后顺序访问完成的所有顶点。3、 最后拓扑排序得到的线性序列，即为topoSort。talk is cheap:(代码前提，没有环，可能有环的情况见例题）stack&amp;lt;int&amp;gt; tpsort;vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; graph;bool visited[graph.size()];void TP(){ int size = graph.size(); for(int i = 0;i&amp;lt;size;i++){ if(!visited[i]) dfs(i); }}void dfs(int x){ if(visited[x]) return; for(int i=x+1;i&amp;lt;size;i++){ if(graph[x][i]) dfs(i); } tpsort.push(x); return;}例题LeetCode 207 Course Schedule这道题就是拓扑排序的简化版，其实只要用一次DFS即可，主要考点就是拓扑排序中不能有环存在，检测环要记录这一次DFS走过的路径才可以，所以每次走完DFS后，cycle中其实是空的。只要用DFS检测出环，即可判断为false这道题卡时间，不能用邻接矩阵做，一定要用unordered_set。莫名其妙在时间上卡了好久，思路其实很简单。其实也可以用BFS做，可以参见LeetCode中Solution中的代码，解释的也很详尽。上代码class Solution {public: bool canFinish(int numCourses, vector&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt;&amp;amp; prerequisites) { if(prerequisites.empty()) return true; vector&amp;lt;unordered_set&amp;lt;int&amp;gt;&amp;gt; graph(numCourses); int size = prerequisites.size(); for(int i=0;i&amp;lt;size;i++){ graph[prerequisites[i].second].insert(prerequisites[i].first); } unordered_set&amp;lt;int&amp;gt; visited; vector&amp;lt;bool&amp;gt; flag(numCourses, false); for(int i = 0;i&amp;lt;numCourses;i++){ if(!flag[i]) if(DFS(graph,visited,i,flag)) return false; } return true; } bool DFS(vector&amp;lt;unordered_set&amp;lt;int&amp;gt;&amp;gt; &amp;amp;matrix, unordered_set&amp;lt;int&amp;gt; &amp;amp;visited, int b, vector&amp;lt;bool&amp;gt; &amp;amp;flag){ flag[b] = true; visited.insert(b); for(auto it = matrix[b].begin(); it != matrix[b].end(); ++ it) if(visited.find(*it) != visited.end() || DFS(matrix, visited, *it, flag)) return true; visited.erase(b); return false;}};LeetCode 210 Course Schedule II这道题就是上一道题的强化版，也是正宗的拓扑排序，利用visited判断是否访问过进行排序，cycle判断是否有环存在。每次递归前吧现在位置加入cycle，如果再次回到了之前访问过的地方，那么存在环，就无法拓扑排序了。道理和上一道题是一样的。之所以不能重用visited来判断环的存在，因为visited会表示之前一次DFS所存储下来的走过的路径值，会导致判断错误。这道题卡时间没有上一题紧。上代码class Solution {public: vector&amp;lt;int&amp;gt; findOrder(int numCourses, vector&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt;&amp;amp; prerequisites) { vector&amp;lt;int&amp;gt; ans; vector&amp;lt;unordered_set&amp;lt;int&amp;gt;&amp;gt; graph(numCourses); for(int i=0;i&amp;lt;prerequisites.size();i++){ graph[prerequisites[i].second].insert(prerequisites[i].first); } vector&amp;lt;bool&amp;gt; visited(numCourses); unordered_set&amp;lt;int&amp;gt; cycle; for(int i=0;i&amp;lt;numCourses;i++){ if(!visited[i]){ if(!dfs_sort(ans,i,visited,graph,cycle)){ ans.clear(); return ans; } } } reverse(ans.begin(),ans.end()); return ans; } bool dfs_sort(vector&amp;lt;int&amp;gt;&amp;amp; ans,int x,vector&amp;lt;bool&amp;gt;&amp;amp; visited,vector&amp;lt;unordered_set&amp;lt;int&amp;gt;&amp;gt;&amp;amp;graph,unordered_set&amp;lt;int&amp;gt;&amp;amp; cycle){ if(visited[x]) return true; visited[x] = true; cycle.insert(x); for(auto it = graph[x].begin();it!=graph[x].end();++it ){ if(cycle.find(*it) != cycle.end() || !dfs_sort(ans,*it,visited,graph,cycle)) return false; } cycle.erase(x); ans.push_back(x); return true; }};" }, { "title": "基础算法与数据结构（六） 图与其基础算法", "url": "/posts/graph/", "categories": "技术", "tags": "数据结构, 算法, 图", "date": "2017-04-26 00:03:36 +0800", "snippet": "图的基础概念 图的定义：无向图： 一个图G = (V,E)由顶点（或结点）的非空集V和边的集合E构成，每条边有一个或两个顶点与它相连，这样的顶点称为端点。边连接它的端点。（顶点集为无限的称为无限图，反之称为有限图）有向图：一个有向图(V,E)由一个非空顶点集V和一个有向边集E组成。每条有向边与一个顶点有序对相关联。与有序对（u，v）相关联的有向边开始于u，结束于v 图的离散数学概念速览本文重点不是离散数学，这里只提供一些名词供查漏补缺只用。顶点的度，入度，出度，孤立的顶点，连通性，连通分量，强连通，完全图，二分图 。。。。。。图的数据结构表示一个图可以利用两种方式来表示，一种是邻接矩阵，另一种为邻接链表。邻接矩阵用一个二维数组可以表现一个图，数组中A[i][j]表示从i到j是否有一条连通的边，有则为1，无则为0。 缺点是存储所需要的空间较大，为顶点个数的平方级别，对存储空间要求较大，但查询方便。邻接链表用一个指针数组来表示。A[i]链表表示从i号点能够到达的结点号。这种方式可以节省存储空间，但是查询并不是很方便。图示如下：（本图选自算法导论）两种方法都容易用代码实现，此略。广度优先算法（BFS）虽然把广度优先算法放在图这里，但是也可以用于树，后文给出的一道题就是树上的BFS运用。广度优先算法用语言通俗表述就是，一层一层向外扩展，在距离起点相同距离的点走完之前不想外扩展。广度优先算法可以求出源点到所有点的最短路径。广度优先算法的代码实现：//邻接矩阵版void BFS(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; graph){ int size = graph.size(); bool visited[size]; queue&amp;lt;int&amp;gt; que; que.push(0); //从0开始遍历 while(!que.empty()){ int curPoint = que.front(); que.pop(); visited[curPoint] = true; for(int i = 0;i&amp;lt;size;i++){ if(graph[curPoint][i] &amp;amp;&amp;amp; visited[i]){ que.push(y); //对这条链路的操作，如果求距离，在这里把距离+1等。 } } }}//邻接表版void BFS(vector&amp;lt;GraphNode*&amp;gt; graph,int size){ bool visited[size]; queue&amp;lt;GraphNode*&amp;gt; que; que.push(graph[0]) while(!que.empty()){ GraphNode* cur = que.front(); que.pop(); visited[curPoint] = true; GraphNode* next = cur-&amp;gt;next; while(next){ if(visited[next-&amp;gt;No]){ que.push(next); } } }}深度优先搜索（DFS）深度优先搜索就是一次性走到不能走，再往回走，知道走完所有的路。是回溯法的典型应用，就可以利用递归快速理解和解决。一般可以用来解决一些关于图连通的问题。bool visited[size];vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; graph;int size = graph.size();void DFS(){ visited[x][y] = true; for(int i = 0;i&amp;lt;size;i++){ for(int j = 0;j&amp;lt;size;j++){ if(!visited[i][j]){ DFS(i,j); } } }}典型题DFS和BFS的思想可以利用到很多题目上，题目不胜枚举，LeetCode上也有很多可以训练，择其典型者列出。BFSLeetCode 102 Binary Tree Level Order Traversal据说是面试常考题，也是BFS的典型题，重点就在BFS一层一层向下的思想。上代码：（此处为JAVA代码） List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; ans = new ArrayList&amp;lt;&amp;gt;(); public List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; levelOrder(TreeNode root) { if(root==null) return ans; bfs(root); return ans; } void bfs(TreeNode root){ //Set&amp;lt;TreeNode&amp;gt; visited = new HashSet&amp;lt;&amp;gt;(); //如果是图一定需要visited！！！！(因为这里是树，所以可以省略） Queue&amp;lt;TreeNode&amp;gt; queue = new LinkedList&amp;lt;&amp;gt;(); queue.add(root); //visited.add(root); while(!queue.isEmpty()){ int levelSize = queue.size(); //得到上一层究竟放入了多少结点，因为在退出循环前之前放入的已经完全访问过，并且出队列。 List&amp;lt;Integer&amp;gt; levelNodes = new ArrayList&amp;lt;&amp;gt;(); while(levelSize-- &amp;gt;0){ TreeNode curNode = queue.poll(); levelNodes.add(curNode.val); if(curNode.left != null) queue.add(curNode.left); if(curNode.right != null) queue.add(curNode.right); } ans.add(levelNodes); } }DFSLeetCode 200 Number of Islands图连通性的典型题目，也是可以利用DFS的典型题目。每一次的DFS可以根据四连通走遍所有可以连通的，并且标记visited。退出后就是找到一个岛。然后再在途中照可以连通但并没有访问过的节点在进行DFS操作。如此循环往复，最后全部访问过以后，走过几遍DFS就是有多少岛上代码： //四连通的坐标变化 int[] dx = {-1,0,1,0}; int[] dy = {0,-1,0,1}; int row; int col; boolean[][] visited; char[][] gridx; public int numIslands(char[][] grid) { if(grid.length == 0) return 0; gridx = grid; row = grid.length; col = grid[0].length; visited = new boolean[row][col]; int cnt = 0; for(int i=0;i&amp;lt;row;i++){ for(int j=0;j&amp;lt;col;j++){ if(!visited[i][j] &amp;amp;&amp;amp; gridx[i][j] == &#39;1&#39;){ dfs(i,j); cnt++; } } } return cnt; } void dfs(int i,int j){ if(visited[i][j]) return; visited[i][j] = true; for(int p=0;p&amp;lt;4;p++){ int x = i+dx[p]; int y = j+dy[p]; //防止溢出 if(x&amp;gt;=0 &amp;amp;&amp;amp; x&amp;lt;row &amp;amp;&amp;amp; y&amp;gt;=0 &amp;amp;&amp;amp; y&amp;lt;col &amp;amp;&amp;amp; gridx[x][y] == &#39;1&#39; ) dfs(x,y); } }" }, { "title": "基础算法与数据结构（四） 树（3）平衡二叉树之红黑树", "url": "/posts/red/", "categories": "技术", "tags": "数据结构, 算法, 树, 红黑树, 二叉树, 平衡二叉树", "date": "2017-04-25 00:03:36 +0800", "snippet": "本文中所有与红黑树有关的代码均来自于刘新宇所著《算法新解》中的红黑树章节。平衡二叉树根据之前的表述，因为二叉树可能为退化为链表，所以产生了平衡二叉树这个产物，主要为了避免在插入值的时候产生退化的问题。平衡二叉树主要有两种实现方式，一种是红黑树，一种是AVL树。首先先复习红黑树。2-3树在介绍红黑树之前，先介绍一种理想的平衡二叉树 — 2-3树2-3树有两种节点，分别是2结点和3结点，分别定义如下： * 2结点：含有一个键（和其对应的值）和两条链接，左链接指向2-3树种的键都小于该结点，右链接指向的2-3树中的键都大于该结点。（即一般的二叉树节点） * 3结点：含有两个键（和其对应的值）和三条链接，左链接指向的2-3树种的键都小于该节点，中链接指向的2-3树种的键都位于该结点的两个键之间，右链接指向的2-3树中的键都大于该结点。 * 指向一颗空树的连接称为空链接。一棵完美平衡的2-3查找树中的所有空链接到根节点的距离都是相同的。2-3树的增删改查查询类似于一般二叉树中的查找，根据结点的key值和要查找的key值进行比较，递归相应的子树进行查询。插入由于结点的不同，这里有几种插入的情况： 向一棵只含有一个3结点的树中插入新结点：先创建一个4-结点（定义类似于2结点等），然后将其转换为两个只含有2-结点的子树。中间数成为根节点，另外两个成为对应的左右子树。 向一个父节点为2-结点的3-结点插入新结点：先在3-结点中创建为4-结点，然后将中间值移向作为父节点的2-结点，将父节点改为3-结点，新创建的两个链接，分别指向剩余的两个结点。 向一个父节点为3-结点的3-结点插入新节点：一路向上变为4-结点追溯，只到出现2-结点，利用2进行变换。如果最后将根节点变为了3-结点，那么就要对这个3-结点进行分解，利用1后半段的方法即可。 红黑树在了解2-3树之后，理解红黑树的定义就会稍稍简单一点。。。 利用2-3树延伸出红黑树： 红结点与上一层的黑结点一起组成了一个3结点，所以不可能出现两个红结点连续出现的情形。如图所示： 定义：红黑树是一种自平衡二叉搜索树。通过对节点进行着色和旋转，红黑树很容易保持树的平衡。（有一种版本是对节点之间的连接进行红黑分类，这里使用节点红黑） 性质： 任一节点要么是红色，要么是黑色。 根节点为黑色。 所有的叶节点为黑色。（叶节点为最后的nil节点为黑色，并非传统意义上的最底层结点，一般都满足。） 如果一个节点为红色，那么两个子节点都是黑色。 对任一节点，从他出发到所有叶子节点的路径上包含相同数量的黑色节点。从根节点出发到达叶节点的所有路径中，最长路径不会超过最短路径的2倍。 红黑树的节点数据结构 struct Node { Key key; Color color; Node* left; Node* right; Node* parent; Node(Key k, Color c = Color::RED) : key(k), color(c), left(nullptr), right(nullptr), parent(nullptr) {} virtual ~Node() { delete left; delete right; } void setLeft(Node* x) { left = x; if (x) x-&amp;gt;parent = this; } void setRight(Node* x) { right = x; if (x) x-&amp;gt;parent = this; } void setChildren(Node* x, Node* y) { setLeft(x); setRight(y); } // parent &amp;lt;--&amp;gt; this ==&amp;gt; parent &amp;lt;--&amp;gt; y void replaceWith(Node* y) { if (!parent) { if (y) y-&amp;gt;parent = nullptr; } else if (parent-&amp;gt;left == this) { parent-&amp;gt;setLeft(y); } else { parent-&amp;gt;setRight(y); } parent = nullptr; } Node* sibling() { return parent-&amp;gt;left == this ? parent-&amp;gt;right : parent-&amp;gt;left; } Node* uncle() { return parent-&amp;gt;sibling(); } Node* grandparent() { return parent-&amp;gt;parent; }}; 树的旋转操作即在保持树的中序遍历结果不变的情况下，改变树的结构。树的左右旋操作的C++代码：//left rotation: (a, x, (b, y, c)) ==&amp;gt; ((a, x, b), y, c)Node* leftRotate(Node* t, Node* x) { Node* parent = x-&amp;gt;parent; Node* y = x-&amp;gt;right; Node* a = x-&amp;gt;left; Node* b = y-&amp;gt;left; Node* c = y-&amp;gt;right; x-&amp;gt;replaceWith(y); x-&amp;gt;setChildren(a, b); y-&amp;gt;setChildren(x, c); if (!parent) t = y; return t;}// right rotation: (a, x, (b, y, c)) &amp;lt;== ((a, x, b), y, c)Node* rightRotate(Node* t, Node* y) { Node* parent = y-&amp;gt;parent; Node* x = y-&amp;gt;left; Node* a = x-&amp;gt;left; Node* b = x-&amp;gt;right; Node* c = y-&amp;gt;right; y-&amp;gt;replaceWith(x); y-&amp;gt;setChildren(b, c); x-&amp;gt;setChildren(a, y); if (!parent) t = x; return t;}红黑树中的增删查操作查询操作可以类似于一般的二叉树进行递归的查询操作，时间复杂度在O(lgn)Node* search(Node* t, Key x) { while (t &amp;amp;&amp;amp; t-&amp;gt;key != x) t = x &amp;lt; t-&amp;gt;key ? t-&amp;gt;left : t-&amp;gt;right; return t;}插入操作插入操作是红黑树中最复杂的实现之一，需要在一般二叉树的插入操作基础上进行红黑变换以及树的旋转才能够正确插入，需要调整的情况主要会有2种（基本2种，考虑左右对称有4种）。插入操作的前半部分就是一般的二叉树插入操作，找到应该插入的位置，并且声明一个红色结点。由于红结点不能相邻，所以会有需要调整的情况。（为什么初始化为红色结点？ 因为性质中规定从根节点到所有叶子节点上需要有相同数量的黑色节点，所以要有节点变黑，就要两边都变黑，否则不可。（这一点很重要）如果初始化为黑色节点会破坏这个性质。）情况一： 插入节点的父节点和父节点的兄弟结点均为红色。 此时的解决方案就是把父节点和父节点的兄弟结点变为黑色，同时将祖父结点变为红色，此时并不会改变这棵红黑树所展现的平衡性质。 如果此时祖父节点变为红色之后又产生了两个相邻的红色结点，那么只需要在进行一次相同操作即可，直到这棵树最后平衡。情况二：插入节点的父节点为红色，而父节点的兄弟结点为黑色这个情况比之前复杂，因为不能直接将父节点染黑了，所以要对整棵树进行旋转操作才能够满足红黑树的5条性质。如果插入的是在左边位置，那么就将整棵树以祖父节点右旋，将原先的红结点变为“大家长”，可以进行染黑操作了，消除了两个红结点相邻，并且不会增加黑结点数目。那么原先的祖父节点变为了右子树，由于原先祖父节点为黑结点，需要转为红结点才能保持平衡。上图：最后只需要进行根节点的判断进行红黑转换即可。上代码：// returns the new root,normal insertNode* insert(Node* t, Key key) { Node* root = t; Node* x = new Node(key); Node* parent = nullptr; while (t) { parent = t; t = key &amp;lt; t-&amp;gt;key ? t-&amp;gt;left : t-&amp;gt;right; } if (!parent) { //insert key to the empty tree root = x; } else if (key &amp;lt; parent -&amp;gt; key) { parent-&amp;gt;setLeft(x); } else { parent-&amp;gt;setRight(x); } return insertFix(root, x);}// fix the red-&amp;gt;red violationNode* insertFix(Node* t, Node* x) { while (x-&amp;gt;parent &amp;amp;&amp;amp; x-&amp;gt;parent-&amp;gt;color == Color::RED) { if (x-&amp;gt;uncle()-&amp;gt;color == Color::RED) { // case 1: ((a:R, x:R, b), y:B, c:R) ==&amp;gt; ((a:R, x:B, b), y:R, c:B) setColors(x-&amp;gt;parent, Color::BLACK, x-&amp;gt;grandparent(), Color::RED, x-&amp;gt;uncle(), Color::BLACK); x = x-&amp;gt;grandparent(); } else { if (x-&amp;gt;parent == x-&amp;gt;grandparent()-&amp;gt;left) { if (x == x-&amp;gt;parent-&amp;gt;right) { // case 2: ((a, x:R, b:R), y:B, c) ==&amp;gt; case 3 x = x-&amp;gt;parent; t = leftRotate(t, x); } // case 3: ((a:R, x:R, b), y:B, c) ==&amp;gt; (a:R, x:B, (b, y:R, c)) setColors(x-&amp;gt;parent, Color::BLACK, x-&amp;gt;grandparent(), Color::RED); t = rightRotate(t, x-&amp;gt;grandparent()); } else { if (x == x-&amp;gt;parent-&amp;gt;left) { // case 2&#39;: (a, x:B, (b:R, y:R, c)) ==&amp;gt; case 3&#39; x = x-&amp;gt;parent; t = rightRotate(t, x); } // case 3&#39;: (a, x:B, (b, y:R, c:R)) ==&amp;gt; ((a, x:R, b), y:B, c:R) setColors(x-&amp;gt;parent, Color::BLACK, x-&amp;gt;grandparent(), Color::RED); t = leftRotate(t, x-&amp;gt;grandparent()); } } } t-&amp;gt;color = Color::BLACK; return t;}删除操作我手边的所有资料基本都将最复杂的删除操作作为了练习。确实，删除操作复杂点就在删除黑结点的同时会产生破坏性质5的结果，需要进行调整。不过由于二叉搜索树在实际应用中，如果需要删除超过一半的节点，不如重新建树罢了。删除操作可以参考https://juejin.im/entry/58371f13a22b9d006882902d 里的讲解。平衡树的典型例题LeetCode 108利用排完序的数组重建二叉树。两种解法： 1. 利用分治法分别建左右树 2.利用平衡树的旋转等操作进行平衡，如果直接插入会导致退化。待补充。" }, { "title": "基础算法与数据结构（五） 树（4）平衡二叉树之AVL树", "url": "/posts/AVL/", "categories": "技术", "tags": "数据结构, 算法, 树, AVL, 二叉树, 平衡二叉树", "date": "2017-04-25 00:03:36 +0800", "snippet": "AVL树的定义 平衡因子：δ(T) = R - L 若δ(T) = 0 那么这棵树是平衡的，其绝对值越小，说明树越平衡。 AVL树的定义： δ(T) ≤ 1 AVL树的性质 一棵n个结点的AVL树的其高度保持在O(log2(n)),不会超过(3/2)*log2(n+1) 一棵n个结点的AVL树的平均搜索长度保持在O(log2(n)). 一棵n个结点的AVL树删除一个结点做平衡化旋转所需要的时间为O(log2(n)).AVL的数据结构基本同红黑树，把其中结点的染色编程了左右结点的高度差。struct Node { Key key; int delta; Node *left, *right, *parent; Node(Key k) : key(k), delta(0), left(nullptr), right(nullptr), parent(nullptr) {} virtual ~Node() { delete left; delete right; } void setLeft(Node* x) { left = x; if (x) x-&amp;gt;parent = this; } void setRight(Node* x) { right = x; if (x) x-&amp;gt;parent = this; } void setChildren(Node* x, Node* y) { setLeft(x); setRight(y); } // parent &amp;lt;--&amp;gt; this ==&amp;gt; parent &amp;lt;--&amp;gt; y void replaceWith(Node* y) { if (!parent) { if (y) y-&amp;gt;parent = nullptr; } else if (parent-&amp;gt;left == this) { parent-&amp;gt;setLeft(y); } else { parent-&amp;gt;setRight(y); } parent = nullptr; }};AVL树的插入AVL树的插入主要难点同样在处理高度差大于1之后的问题。要处理这个问题就要进行树的旋转来的满足高度差小于1。分为几种情况，转换如下：LL偏： 导致最上方结点需要旋转的原因是左子树比右子树高度大1，且左子树的左子树比右子树大1，此时成为左-左偏 剩余的三种偏法看图容易理解。偏的处理方法主要靠树的旋转，思想见代码。Node* insertFix(Node* t, Node* x) { /* * denote d = delta(t), d&#39; = delta(t&#39;), * where t&#39; is the new tree after insertion. * * case 1: |d| == 0, |d&#39;| == 1, height increase, * we need go on bottom-up updating. * * case 2: |d| == 1, |d&#39;| == 0, height doesn&#39;t change, * program terminate * * case 3: |d| == 1, |d&#39;| == 2, AVL violation, * we need fixing by rotation. */ int d1, d2, dy; Node *p, *l, *r; while (x-&amp;gt;parent) { d2 = d1 = x-&amp;gt;parent-&amp;gt;delta; d2 += x == x-&amp;gt;parent-&amp;gt;left ? -1 : 1; x-&amp;gt;parent-&amp;gt;delta = d2; p = x-&amp;gt;parent; l = x-&amp;gt;parent-&amp;gt;left; r = x-&amp;gt;parent-&amp;gt;right; if (abs(d1) == 1 &amp;amp;&amp;amp; abs(d2) == 0) { return t; } else if (abs(d1) == 0 &amp;amp;&amp;amp; abs(d2) == 1) { x = x-&amp;gt;parent; } else if (abs(d1) == 1 &amp;amp;&amp;amp; abs(d2) == 2) { if (d2 == 2) { if (r-&amp;gt;delta == 1) { // right-right case p-&amp;gt;delta = 0; r-&amp;gt;delta = 0; t = leftRotate(t, p); } else if (r-&amp;gt;delta == -1) { // right-left case dy = r-&amp;gt;left-&amp;gt;delta; p-&amp;gt;delta = dy == 1 ? -1 : 0; r-&amp;gt;left-&amp;gt;delta = 0; r-&amp;gt;delta = dy == -1 ? 1 : 0; t = rightRotate(t, r); t = leftRotate(t, p); } } else if (d2 == -2) { if (l-&amp;gt;delta == -1) { // left-left case p-&amp;gt;delta = 0; l-&amp;gt;delta = 0; t = rightRotate(t, p); } else if (l-&amp;gt;delta == 1) { // left-right case dy = l-&amp;gt;right-&amp;gt;delta; l-&amp;gt;delta = dy == 1 ? -1 : 0; l-&amp;gt;right-&amp;gt;delta = 0; p-&amp;gt;delta = dy == -1 ? 1 : 0; t = leftRotate(t, l); t = rightRotate(t, p); } } break; } else { printf(&quot;shouldn&#39;t be here. d1=%d, d2=%d\\n&quot;, d1, d2); assert(false); } } return t;}" }, { "title": "基础算法与数据结构（三） 树（2）二叉搜索树", "url": "/posts/searchTree/", "categories": "技术", "tags": "数据结构, 算法, 树, 二叉搜索树", "date": "2017-04-23 00:03:36 +0800", "snippet": "二叉搜索树的定义二叉搜索树（BST）每个结点均含有一个可比较的key和对应的value，左侧子树所有的key都比根节点小，右侧子树的所有key均比根节点大。struct TreeNode{ int key; int value; TreeNode* left; TreeNode* right; TreeNode(int key,int value) { this.key = key; this.value = value; }}二叉搜索树的性质 二叉搜索树的中序遍历是有序的。（可以用于判断一个树是否为二叉搜索树）二叉搜索树的操作查找操作用二叉搜索树为的就是搜索（有点废话的意思），利用二叉树可以将有序内容的查找的平均时间复杂度从O(n)降到O(lgn)，当然在最坏情况下如果树退化成了一个链表（均只有左子树或者右子树），那么就完全没有体现出树的作用。此时就要通过另一种在构造树时候进行平衡的方法来简化了。废话不多说，上代码int getValue(TreeNode* root,int key){ if(!root) return null; if(key &amp;lt; root-&amp;gt;key) return getValue(root-&amp;gt;left,key); else if (key &amp;gt; root-&amp;gt;key) return getValue(root-&amp;gt;right,key) else return root-&amp;gt;value;}插入操作和查找操作类似，根据大小关系向下寻找，找到第一个符合条件的位置即可插入操作，返回一个新的结点的地址。如果已经有key和要插入的key相同，那么默认更新这个值。TreeNode* insert(TreeNode* root,int key,int value){ if(!root) return new TreeNode(key,value); if(key &amp;lt; root-&amp;gt;key) return insert(root-&amp;gt;left,key,value); else if (key &amp;gt; root-&amp;gt;key) return getValue(root-&amp;gt;right,key,value) else{ root-&amp;gt;value = value; return root; };}删除操作删除操作只要需要克服的问题就是再删除一个结点之后如何保持这个树的继续有序，即如何处理只能有一个接口但有两棵原先结点存在的子树。1962年T.Hibbard提出了一个方法，就是从删除结点的右子树中寻找最小值作为这个删除结点的替代者。原因也很好理解，因为左子树一定比这个要替代的结点的key小，所以要在右子树中找出最小的，才能满足大于左子树，小于右子树。同理，其实往左子树中寻找最大结点也是可以的，这两者应该随机的选用，这里展示前者的代码实现。TreeNode* getMin(TreeNode* root){ if(!root-&amp;gt;left) return root; return getMin(root-&amp;gt;left);}TreeNode* deleteMin(TreeNode* root){ if(!root-&amp;gt;left) return root-&amp;gt;right; root-&amp;gt;left = deleteMin(root-&amp;gt;left); return root;}TreeNode* deleteNode(TreeNode* root,int key){ if(!root) return NULL; if(key &amp;lt; root-&amp;gt;key) root-&amp;gt;left = deleteNode(root-&amp;gt;left,key); else if (key &amp;gt; root-&amp;gt;key) root-&amp;gt;right = deleteNode(root-&amp;gt;right,key); else{ //要删除的节点只有一个子树，直接返回。 if(!root-&amp;gt;right) return root-&amp;gt;left; if(!root-&amp;gt;left) return root-&amp;gt;right; //有两个子树，那么找到右子树中最小的,然后删除这个最小的值 TreeNode* t = root; root = getMin(t-&amp;gt;right); root-&amp;gt;right = deleteMin(t-&amp;gt;right); root-&amp;gt;left = t-&amp;gt;right; } return root;}典型问题更新至2017.4.23（v1.0)LeetCode 98判断一棵树是否为有效的二叉搜索树。利用之前的性质，进行中序遍历，如果遍历结果有序，那么就合法，否则不合法。代码略。LeetCode 108利用同样的思想可以重建树。" }, { "title": "基础算法与数据结构（二） 树（1）基础二叉树", "url": "/posts/algotree/", "categories": "技术", "tags": "数据结构, 算法, 二叉树", "date": "2017-04-22 00:03:36 +0800", "snippet": "树的基本数据结构//tree struct normalTreeNode { int val; TreeNode* sons[]; };//binary tree struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) {} };树的基本概念 根、子树、叶结点 节点的度、分支节点、孩子、双亲、子孙、深度 二叉树：每个节点至多只有两棵子树（度不大于2）二叉树的典型架构二叉树的性质二叉树可以使用数组存储。 在二叉树的第i层上最多只有2^(i-1)个结点 深度为k的二叉树至多有2^k - 1 个结点 对任何一棵二叉树T，如果其终端结点数为n0，度为2的节点数为n2，则n0=n2+1 具有n个结点的完全二叉树的深度为[log2n]+1二叉树的遍历二叉树的遍历分为三种： 前序(root-left-right)、中序(left-root-right)、后序(left-right-root) （以root所在的位置为基准）三种遍历均可用递归和非递归的方式进行，前序中序的非递归主要用一个栈来模拟递归的出入顺序，代码分别如下所有结果都存在vector中返回括号内数字为对应leetCode题目编号 前序（144） //递归 vector&amp;lt;int&amp;gt; route; void PreOrderTraversal(TreeNode* root){ if(!root){ route.push_back(root-&amp;gt;val); PreOrderTraversal(root-&amp;gt;left); PreOrderTraversal(root-&amp;gt;right); } } //非递归 vector&amp;lt;int&amp;gt; PreOrderTraversal(TreeNode* root){ vector&amp;lt;int&amp;gt; route; stack&amp;lt;TreeNode*&amp;gt; s; TreeNode* cur = root; while(cur || s.empty()){ while(cur){ route.push_back(cur-&amp;gt;val); s.push(cur); //go to the most left cur = cur-&amp;gt;left; } if(!s.empty()){ cur = s.top(); s.pop(); //back to right cur = cur-&amp;gt;right; } } return route; } 中序（94） //递归 vector&amp;lt;int&amp;gt; route; void InOrderTraversal(TreeNode* root){ if(!root){ InOrderTraversal(root-&amp;gt;left); route.push_back(root-&amp;gt;val); InOrderTraversal(root-&amp;gt;right); } } //非递归 vector&amp;lt;int&amp;gt; InOrderTraversal(TreeNode* root){ vector&amp;lt;int&amp;gt; route; stack&amp;lt;TreeNode*&amp;gt; s; TreeNode* cur = root; while(cur || s.empty()){ while(cur){ s.push(cur); //go to the most left cur = cur-&amp;gt;left; } if(!s.empty()){ cur = s.top(); s.pop(); route.push_back(cur-&amp;gt;val); //back to right cur = cur-&amp;gt;right; } } return route; } 后序（145） //递归 vector&amp;lt;int&amp;gt; route; void PostOrderTraversal(TreeNode* root){ if(!root){ PostOrderTraversal(root-&amp;gt;left); PostOrderTraversal(root-&amp;gt;right); route.push_back(root-&amp;gt;val); } } //非递归 vector&amp;lt;int&amp;gt; PostOrderTraversal(TreeNode* root){ stack&amp;lt;TreeNode&amp;gt; s; vector&amp;lt;int&amp;gt; ans; TreeNode* pre,cur; pre = NULL; if(root == NULL) return ans; s.push(root); while(!s.empty()){ cur = s.top(); //要么左右均为空，那么就是叶子节点放入route，或者前一个是左结点或者右结点回溯回来的，此时也是已经访问过左右放入父节点 if((!cur-&amp;gt;left&amp;amp;&amp;amp;!cur-&amp;gt;right) || (pre &amp;amp;&amp;amp; (pre == cur-&amp;gt;left || pre == cur-&amp;gt;right))){ s.pop(); ans.push_back(cur.val); pre = cur; }else{ //向栈内先放右，再放左，先进后出 if(cur-&amp;gt;right) s.push(cur-&amp;gt;right); if(cur-&amp;gt;left) s.push(cur-&amp;gt;left); } } return ans; } 二叉树典型题一般二叉树的题目都可以用递归的方法解决。（例如 求树的深度，树的最浅深度以及最深度等问题）翻转二叉树 （leetCode 226）这道题有一句名言那。。。 Google: 90% of our engineers use the software you wrote (Homebrew), but you can’t invert a binary tree on a whiteboard so fuck off.！分别翻转左右即可。。TreeNode* invertTree(TreeNode* root) { if(root==NULL) return NULL; root-&amp;gt;left = invertTree(root-&amp;gt;left); root-&amp;gt;right = invertTree(root-&amp;gt;right); TreeNode* tmp = root-&amp;gt;left; root-&amp;gt;left = root-&amp;gt;right; root-&amp;gt;right = tmp; return root; }利用前序/中序构造二叉树根据前序中序的特征可以来模拟写出程序。先找到前序中的第一个，然后利用这个在中序中找到这个值，然后这个值之前的在左子树中，之后的在右子树中，然后分别递归再次利用这个方法继续建树。同样的可以利用中序/后序构建二叉树。TreeNode *buildTree(vector&amp;lt;int&amp;gt; &amp;amp;preorder, vector&amp;lt;int&amp;gt; &amp;amp;inorder){ if(preorder.empty() || inorder.empty()) return NULL; TreeNode* root = new TreeNode(preorder[0]); if(preorder.size()==1 &amp;amp;&amp;amp; inorder.size()==1) return root; int inOrderNum = FindNode(inorder,preorder[0]); vector&amp;lt;int&amp;gt; a(preorder.begin()+1,preorder.begin()+inOrderNum+1); vector&amp;lt;int&amp;gt; b(inorder.begin(),inorder.begin()+inOrderNum+1); vector&amp;lt;int&amp;gt; c(preorder.begin()+inOrderNum+1,preorder.end()); vector&amp;lt;int&amp;gt; d(inorder.begin()+inOrderNum+1,inorder.end()); root-&amp;gt;left = buildTree(a,b); root-&amp;gt;right = buildTree(c,d); return root; } int FindNode(vector&amp;lt;int&amp;gt; &amp;amp;v,int target){ int size = v.size(); for(int i=0;i&amp;lt;size;i++){ if(v[i] == target) return i; } return -1; }" }, { "title": "基础算法与数据结构（一） 链表", "url": "/posts/link/", "categories": "技术", "tags": "数据结构, 算法, 链表", "date": "2017-04-22 00:01:36 +0800", "snippet": "本部分内容一般选用C++，如有Java代码，将有明确标注。链表的基础数据结构 struct ListNode{ int val; //may be the other data type ListNode* next; ListNode(int val){ this.val = val; this.next = null; } }链表的基本性质 链表克服了数组增删改操作需要移动大量元素的缺点，它不要求逻辑上相邻的两个元素在物理实现上相邻（数组要求）。但失去了数组可以随机存取的优点。 链表的存取必须从第一个结点开始。所以对链表进行增删改操作时的最坏时间复杂度应为O(n) 静态链表：用数组模仿链表，数组的第二个数据存下一个结点的位置链表的基础增删以及逆转操作 新增元素： //pos is the number which count from the 0 and don&#39;t have the dommy node void addNodes(ListNode* head,int val,int pos){ ListNode* cur = head; while(pos-- &amp;amp;&amp;amp; cur){ cur = cur-&amp;gt;next; } if(cur){ ListNode* next = cur-&amp;gt;next; cur-&amp;gt;next = new ListNode(val); cur-&amp;gt;next-&amp;gt;next = next; } } 删除元素 //pos is the number which count from the 0 and don&#39;t have the dommy node void deleteNodes(ListNode* head,int pos){ ListNode* cur = head; int nowPos = j; while(cur &amp;amp;&amp;amp; j&amp;lt;i-1){ cur = cur-&amp;gt;next; j++; } ListNode *del = cur-&amp;gt;next; cur-next = del-&amp;gt;next; } 逆转操作 // the head node is the node which is the fist node of the sublist which will be reversed.//no recursion ListNode* Reverse(ListNode* head){ ListNode* pre = null; ListNode* next = null; while(head){ next = head-&amp;gt;next; head-&amp;gt;next = next; pre = head; head = next; } return pre; }//recursion ListNode* Reverse(ListNode* head){ if(!head || !head-&amp;gt;next) return head; ListNode* thead = Reverse(head-&amp;gt;next); head-&amp;gt;next-&amp;gt;next = head; head-&amp;gt;next = NULL; return thead; } 链表题 — 快慢指针基本思想为 快指针一次走两步，慢指针一次走一步，根据产生的效果判断一些问题。注意点即指针的有效性问题。判断单链表是否为循环链表 * 基本理念：如果存在循环，总有fast和slow相遇的时候，如果相遇则退出。如果是因为这个退出循环的，那么总存在fast或者fast的next节点不为空，即返回真值。如果是因为fast节点指向空才跳出的循环，那么就不存在循环。 ```c++bool isExistLoop(ListNode* head){ ListNode* fast,slow; fast = slow = head; while(fast &amp;amp;&amp;amp; fast-&amp;gt;next){ slow = slow-&amp;gt;next; fast = fast-&amp;gt;next-&amp;gt;next; if(slow == fast) break; } return (!fast || !fast-&amp;gt;next) } ```在有序列表中寻找中位数（在链表中找到中间） int findMid(ListNode* head){ ListNode* slow,fast; slow = fast = head; while(fast-&amp;gt;next &amp;amp;&amp;amp; fast-&amp;gt;next-&amp;gt;next){ slow = slow-&amp;gt;next; fast = fast-&amp;gt;next-&amp;gt;next; } if(!fast-&amp;gt;next) return slow-&amp;gt;val; else return ((slow-&amp;gt;val)+(slow-&amp;gt;next-&amp;gt;val))/2; }有环链表寻找入口点 原理： fast和slow的相遇点和起点分别设为两个指针，每次各走一步，则这两个指针的相遇点即为入口点。 证明： 设 起点到环的入口的长度为a，入口处到快慢指针相遇处的长度为b 那么慢指针从开始到相遇处走了(a+b)步，那么快指针走了2(a+b)步 设快指针此时绕着环走了n圈，环的长度为r 那么有 2(a+b) = (a+b) + n * r → a+b = nr → a = (n-1) * r + r - b相遇点开始的走了n-1圈和r-b的长度回到起点的同时，起点开始的来到了环的起点。代码略双指针问题基础思想： 慢指针从头开始，快指针从k开始，当快指针走到结束时，慢指针走到倒数第k个的位置。例题： LEETCode 234 Palindrome Linked List * 一般链表解法： 用双指针找到中点位置 → 中点的下一个结点开始到末尾逆转链表 → 从头尾开始向中间，如果出现不同的点则不为回文 * 巧解： 转为字符串，并且reverse，如果为相同字符串那么为回文串链表相交问题首先明确，如果两个链表有相交，一定出现Y字形的相交，相交点之后的两个链表相同，不可能出现X型的相交。分类讨论链表是否有环。 两个无环链表 ： 判断末尾是否相同，如果为同一个节点那么相交（判断地址）求交点： 遍历两个链表得到两个链表的长度len1,len2，从长的链表先走|len2-len1|的长度，在让另一指针从短的头开始走，两个指针相等的那个结点即为交点 可能有环 判断有无环 * 两个均无环： 划归为1 * 一个有环一个无环 ： 根据首先明确的，两个不可能相交 * 两个有环 ： 从一个链表上得到快慢指针的第一个相交点，判断这个相交点是否在第二个链表上，如果在第二个链表的环上那么一定相交。然后划归为1（链表长度为链表起点到环的入口处） 链表题 — 归并有序链表两个链表的归并 ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) { ListNode* start = new ListNode(0); ListNode* pre = start; if(!l1 ||!l2 ) return l1?l1:l2; while(l1 != NULL &amp;amp;&amp;amp; l2 != NULL){ if(l1-&amp;gt;val &amp;lt; l2-&amp;gt;val){ pre-&amp;gt;next = l1; l1 = l1-&amp;gt;next; }else{ pre-&amp;gt;next = l2; l2 = l2-&amp;gt;next; } pre = pre-&amp;gt;next; } pre-&amp;gt;next = l1?l1:l2; return start-&amp;gt;next; }k个链表的归并 两两归并 O(kn^2) 通过优先队列每次取出最小值节点归并 分治法归并分治法归并代码： ListNode* mergeKLists(vector&amp;lt;ListNode*&amp;gt;&amp;amp; lists) { if(lists.empty()) return NULL; return divideAndConquer(lists,0,lists.size()-1); } ListNode* divideAndConquer(vector&amp;lt;ListNode*&amp;gt; &amp;amp;lists,int left,int right){ if(left == right) return lists[right]; int mid = (left+right)/2; ListNode* left_merge = divideAndConquer(lists,left,mid); ListNode* right_merge = divideAndConquer(lists,mid+1,right); return mergeTwoLists(left_merge,right_merge); }" }, { "title": "独树一帜的「民主」", "url": "/posts/People/", "categories": "个人杂记", "tags": "民主, 人大, 杂记", "date": "2016-11-18 00:50:00 +0800", "snippet": "有众多理由来抨击这篇文章，看完了可以看完后安慰自己我们是「中国特色」。不想有无意义的争辩，毕竟这是我的个人言论，你也可以完全不赞同，但愿这个社会有着一定程度的言论自由。 要让那些反民主的人，那些认为民主就是毁坏、混乱、谋杀和贪污的人知道：民主有着其高贵之处，只不过民主的高贵，和他们的理解不一样。民主的高贵，是让每一个人身上都有一点高贵、有一点尊严，而不是让极少数人拥有尊严跟高贵。 –托克维尔今天的各区县人大选举貌似在大学生这里引起了很大的讨论。倾向建制（中共）的学生会认为在选票上写上无谓的姓名是对这个是选举的「不尊重」，而也有人认为在选票上写什么是自己的自由。人大这个遮羞布存在了这么久，千疮百孔，在改变的时代中，会不会走向历史的垃圾堆？人大的直接选举就是民主？如果简单的认为选票就是民主，似乎犯了“选举民主”的错误。选票是民主的一个维度，但是绝不是民主的全部。 更何况在中国现在的政治高压环境下选举能够如实反映民意？抛开之后要讲的人大“虚级化”的问题，连一个自由参选的机会都没有选举能够称得上民主？一个连竞选活动和海报都没有的选举能够称得上民主？一个必须坚持「党的领导」的选举能够称得上民主？如果这样都能算民主，我想全世界都已经进入了民主社会。人大选举三大「特色」没有自由参选的选举这样通过黑箱的「三上三下」的方式来产生候选人的，估计也是全世界的唯一。整个候选人产生过程名义上有着广泛征求意见，但是，所谓的选举委员会是根据什么来淘汰「下」的候选人完全没有说明，每一次讨论结果之后，有的只是一纸公告，从一大部分选出一小部分。既然都有着三次征询，还挂以广泛讨论的名义之后，为什么还要通过一次选举？这样的选举不是名义上的，那什么选举才是名义上的？既然能这样产生建制体系内的候选人，为什么不能通过这样的方式直接产生人大代表呢？你们不是宣称这样的方式很民主吗？既然那么民主，何必需要最后的选票？？通过这一系列的程序，只能看到所谓的候选人推举过程只能够表现出当政者对自己的无信心，害怕有独立参选人来打扰建制的所有安排。只有通过这样的黑箱程序才能够找到一个或多个体制内人员满意的人，才能够更好的做“橡皮图章”。没有竞选活动和政策宣传的选举全世界的选举能够办成这样悄无声息，也是全世界罕见。没有候选人宣传拉票，没有候选人面对所有人的政策宣导，更加不要说有实质竞争的选举。让我们看到候选人无关紧要的信息，这些人以前做了什么，是什么职称，有什么研究成果真的能够作为选民判断的依据？拜托这是选的人大代表，不是中科院院士。在完全不知道人大代表在选上之后可以为自己做什么，不知道人大代表到底之于自己的意义是什么。我们又要根据什么做出决定，大多数人不想投出决定性的一票吗？这样鸡肋的选举，大多数人都能够知道这只是一个形式化的选举，因为建制内的人喜欢的人都已经是候选人中，不喜欢的已经在初选中被淘汰。这样的选举完全没有任何意义，只是作为我们有民主的宣传花瓶。一场什么都没有的无声选举，只是一次大型走秀罢了。那些洗脑彻底的人只会无谓批评那些在选票上写无关紧要信息的人。但从另一个角度看，一场基本和我无关的选举，我们为什么要认真完成？试想如果曾经有过自己班级的班委班长选举，那一票一票那些人真的会写上“希拉里”、“黄焖鸡”？因为这是一场和自己有强烈联系的选举，选出的是为自己服务的班委和班长，而不是选上之后就隐身，选上之后就和自己无关的选举。这也足够表现出大部分大学生的有一定的民主素养，不会盲目投下赞同票。这也无情打脸那些挥舞着正义的大旗指责不赞同候选人就是没有民主素养的一小部分人。总而言之，选举组织者对于选民的态度就是选民最终回馈选举组织者的态度。坚持党的领导下的选举简直滑天下之大稽。看全世界的民主选举，有哪一个需要一个政党的领导，选举选出的是为未来几年人民权力的代行使者。一场有特定立场的选举，能够称得上民主选举，也是让人笑掉大牙。所谓的选举大会也是党领导的一个体现，为了体现领导和领导下的投票率，要强迫所有人来开大会投票，而不是设立投开票所来选举，也是很有意思。不知是不是投票率也是政绩之一？民主？自由！无论如何，在当政者的眼中，因为我们有形式上的选举，所以我们国家民主。无论如何，选票是否就是民主放在一边，我想说的是 没有自由的民主就是在扯淡。上面列举的三个原因，无论哪一条都和自由有关。在现在的政治高压下，我们有没有自由发表自己的意见，参加选举。如果A希望独立参加选举，会被当政者贴上「扰乱社会秩序」的标签，就算没有也会被暗地里做掉，因为在敌我之间，所有人都会选择亲我这一边，这三上山下的原则就是做掉候选人，剥夺参选自由的原则，而不是广泛讨论候选人的原则。政治高压下，谈论政治似乎是一个禁忌，这个禁忌导致了人民对政治活动的无感，导致了人民对人大代表选举的轻视。既然没有言论政治的自由，又怎么会有真正民主的投票选举？自由，是民主的前提。中华民国自由地区解严之前所进行的地方选举国民党的政治高压，导致的就是国民党肆无忌惮的做票当选，这一切都在自由地区真正贯彻自由之后公之于众。不过被压抑了太久，人们早已习惯了自我设限。不会主动讨论政治，不敢评论当政者，不敢批评当前制度，大家都这样认命噤声，一味的跟着中国共产党所谓的政治正确走，好像给出反对的声音就是不好的事情。（这或许和中国人不喜欢变化这个深层文化有关。）人们缺少了独立的思考和判断，令人不寒而栗。人大制度的特色我国的人大制度被宣传成民主典范。当政者也喜欢批评和引导舆论说自由民主投票会导致混乱。但是，毋庸讳言，人大就是一部傀儡机器，幕后的操控者就是实质上以党领政（名义上某党当然不会承认，我们有八个民主花瓶呢）。人大特色之一 ：橡皮图章在中国共产党的实质专政下，人大总是无条件通过所有中共在其全会上通过的政策，通过其推荐的地方首长人选，通过其建议的立法。我国实质权力核心从全国人大常委会和地方各级人大常委会到了中共中央政治局常委会和中共地方常委会，甚至可能是一人核心。这样的架构是畸形的，这样的机制不是一党专政什么是专政？人大特色之二：没有对政府的实质监督所有的政府成员都是人大代表，永远不要指望这个世界会出现自己监督自己的事情出现。人大委员由于自我设限以及整个当政者定出的程序，基本没有对政府工作和政府预算的严肃审核。在其他国家国会或代议制最高殿堂中为执政党的官员进行“穷凶极恶”的质询时，我们为人民行使代议制权力的人大代表们在政府报告中睡觉。他们在为政府提请的预算进行严格的审核克扣每一分公帑之时，我们的人大代表在无脑的投下赞成票。这样一团和气的最高民主会场，真是独树一帜，民主标杆。人大特色之三：选举制度上级的人大代表竟然是由下级选出的，这意味着更上一级的人大代表只需要进行对下级代表进行负责，而不需要直接联系选民。就算是直接选举的最下级选举，选完之后人大代表也对选民没有任何的基础联系，甚至在大学，选完之后1-4年后离开这座学校，而人大一届5年，也就意味着基本上就是流水的选民，铁打的代表。这样的制度根本不能维系选民和代表的关系，人民的权力根本无法通过人大表现。只有最基层的选举，而没有中央级别的直接选举，就是导致了中央层面完全没有人民的直接监督。没有地方公职人员的直接选举，而是中共的任意调动，市长省长完全不是地方的父母官，而是为了进一步晋升的阶梯。人大只是象征性的投下赞同，无论这位中共唯一推荐的候选人是从哪里来，将会到哪里去。人大制度的问题不胜枚举，也不用指望现在执行权力很爽的执政党会交出和放弃管控人民自由的能力。人大就是一个花瓶和图章。这样的无能制度，还能够说选民的态度轻佻吗？因为只要有常识的人都知道这个制度只是中国共产党为了有更好掌权而不会被推翻的遮羞布。不要说中共党员只占三分之一，因为前面已经说过，不亲中共的人从开始就没有可能进入这个体制中。最后，人大选举只是一时，毕竟整体人民中关注政治的只是一部分，但是要知道政治关系着所有人的生活，虽然现在没有可能改善这个制度，但不能自我设限，生怕踩到红线。要知道，现在这个时代正在改变，时代的潮流不是被一个执政党只能够抵抗的。几千年前，就知道防民之口，甚于防川。莫散了团体，休灰了志气！以上。" }, { "title": "诀别", "url": "/posts/saygoodbye/", "categories": "个人杂记", "tags": "其他", "date": "2016-07-20 02:21:09 +0800", "snippet": "想了很久，还是写点什么来记录一下两年来的一些微小的事情。 世路如今已慣，此心到處悠然。最近，还是做出了一个算是重要的决定吧，和ACM-ICPC说再见。怎么说，或许还是感觉自己天赋不够，努力不足。尤其是在这次期末考试现场结果和最后结果因为一些无谓的原因相差那么大之后，这种无力感越来越深厚。最后我想，还是默默地做一个安静的旁观者或许是个更好的选择。两年多来，感觉还是花了蛮多时间在这一个方面。对两年多的时间做一个全面的否定也是一个艰难的决定。虽然不能说这完全都是无用功，但是也希望这样的努力可以在其他技术上发挥一点微薄的作用。一切的一切，或许都开始于高中毕业暑假翁恺老师C语言MOOC课程在PAT上的配套作业，让一个无知少年走进了这一片广阔天地。在这个天地中，我也尝试了各种各样的平台，OJ。大二这一年在朱国进老师的课上也让我充分锻炼了思考的能力和编码的水平。但我始终看不到在这一片广阔天地中有着自己的一片小世界。两年了，我想我这个到现在尚未走向进阶的少年应该走出这一片不适合自己的领域了。离开过去，永远是人类最难做出的决定，未来虽然遥不可及但总会到达，过去的就永远变成了过去。这种对于我来说可能是”大投入，小产出“的工程。弱肉强食是这个自然世界亘古不变的永恒真理，与其在一个自己花了近两年多还没有进展可预见被”弱食“的领域继续浪费一个暑假甚至整个4年的时间，还不如尽早结束开创出另一片天地来给我的未来一个更好的交代。或许是我努力不够，无法跟上大神们飞速旋转的大脑，无法理解一个个从口中蹦出的术语。或许是未战先惧，做了一个站在暑假集训前的逃兵。或许是我利益驱使，想要尽快体验这个残酷的社会所赋予的工作属性。当代人总是现实的，趋利的。在大学生活中，也不应该只有象牙塔中的刻苦钻研，应该还是要增加一些具体的社会内容，毕竟人总是要走向这个残酷的社会。从今天开始，向过去再道一声再见。但我会关注我校集训队在ACM比赛上的表现，衷心祝愿我的同届同学们在属于你们的广阔舞台上展现出自己的完美才华，在来年6月的World Final直播中看到你们的身影。也会偶尔去尝试一下Codeforces的比赛，毕竟这或许是一个对于不太会玩游戏的我一个愉快的活动。但无论如何，这不再会是我主要关注的项目了，希望在新的天地中不再像这样半途而废，无疾而终。改变总是困难的，但这艰难的最后一里路终将到达，改变的第一里路就要从脚下出发。祝福集训队的伙伴们暑假一切顺利，秋季金牌高挂。此心可鑑，真情不變。以上。 2016年7月1日" }, { "title": "计算几何专题练习", "url": "/posts/Calc/", "categories": "技术", "tags": "计算几何, 算法", "date": "2016-05-26 00:50:00 +0800", "snippet": "计算几何专题练习P.S：含有数学公式。。。如没有显示麻烦刷新，谢谢。Contents： 1.基础题目 ​ 1.1 uva11437 ​ 1.2 uva11800 ​ 1.3 uva11646 2.二维几何计算 2.1 uva11178 (EX.) 2.2 uva1342(EX.) 2.3 uva11796(EX.) 3.二维几何算法 3.1 uva10652(EX.) 3.2 uva11168(EX.) ​ ​ ​ 1 基础题目 UVA 11437 1 本题主要运用到两个公式求三等分点的时候需要 定比分点公式已知三条边求三角形面积用海伦公式。。。。。（全是初高中数学- -）附上两个公式：定比分点：O为原点，就可以求得D的坐标\\(若 \\overrightarrow{BD} = \\lambda \\overrightarrow{DC}，有\\overrightarrow{OD} = \\frac{\\overrightarrow{OB}+\\lambda \\overrightarrow{OC} }{1+\\lambda}\\)海伦公式：\\(S = \\sqrt{p(p-a)(p-b)(p-c)} \\quad 其中 p = \\frac{1}{2} (a+b+c) \\quad a/b/c为三边边长\\)2 主要思路a 已知三点求出三个三等分点的坐标b 利用三等分点的坐标求出之间连线的向量c 利用向量求交点（模板）d 交点求长度e 求三角形面积（注意四舍五入）3 模板（利用一点和一个向量所得的直线的参数方程求，cross为叉积）Point crosspoint(Vector a,Vector b,Point af,Point bf){ Vector u; u.make(bf,af); //求BF-AF的向量 double t = cross(b,u)/cross(a,b); //求交点的参数 Point k; //交点 k.x = af.x + t * a.x; k.y = af.y + t * a.y; return k;}4 代码#include &amp;lt;iostream&amp;gt;#include &amp;lt;cmath&amp;gt;using namespace std;struct Point{ double x,y;};struct Vector{ double x,y; void make(Point a,Point b){ x = b.x - a.x; y = b.y - a.y; }};double cross(Vector a,Vector b){ return a.x*b.y - a.y*b.x;}Point crosspoint(Vector a,Vector b,Point af,Point bf){ Vector u; u.make(bf,af); double t = cross(b,u)/cross(a,b); Point k; k.x = af.x + t * a.x; k.y = af.y + t * a.y; return k;}double distance(Point a,Point b){ return sqrt((b.x-a.x)*(b.x-a.x)+(b.y-a.y)*(b.y-a.y));}int main(void){ int t; cin&amp;gt;&amp;gt;t; Point a,b,c,d,e,f,p,q,r; while(t--){ cin&amp;gt;&amp;gt;a.x&amp;gt;&amp;gt;a.y&amp;gt;&amp;gt;b.x&amp;gt;&amp;gt;b.y&amp;gt;&amp;gt;c.x&amp;gt;&amp;gt;c.y; d.x = (2*b.x+c.x)/3.0; d.y = (2*b.y+c.y)/3.0; e.x = (a.x+2*c.x)/3.0; e.y = (a.y+2*c.y)/3.0; f.x = (2*a.x+b.x)/3.0; f.y = (2*a.y+b.y)/3.0; Vector AD,CF,BE; AD.make(a,d); CF.make(c,f); BE.make(b,e); p = crosspoint(AD,BE,a,b); q = crosspoint(BE,CF,b,c); r = crosspoint(AD,CF,a,c); double RP,RQ,QP; RP = distance(r,p); RQ = distance(r,q); QP = distance(q,p); double S,pi; pi = (RP+RQ+QP)/2; S = sqrt(pi*(pi-QP)*(pi-RQ)*(pi-RP)); long long Sans = ((int)(S+0.5)*10)/10; cout&amp;lt;&amp;lt;Sans&amp;lt;&amp;lt;endl; }} UVA 11800 1 题意：就是给4个点判断这个四边形是什么四边形。。。。2 陷阱四个点不一定按照逆时针或者顺时针可以ABCD标号的顺序来。。所以一开始就极角排序排定一下逆时针，排完序就可以ABCD的进行计算判断。3 主要计算的数据四条边和四个角。。。主要还是四个边的向量和长度。。因为浮点数的原因如果用角判断会有误差。所以用边才是坠吼的4 几个形状判断先判断90度。。有一个90度就进入矩形和正方形的判断。。。四条边都相等就是正方，否则是矩形。排除了正方之后，四条边相等就是菱形。。菱形排除完如果对边相等就是平行四边形。。。最后的坑就是梯形。。一开始陷入了同旁内角180度。。然后高相等。。。最后才想到直接判只要有一对平行（叉乘等于零）就好了。。。真是犯蠢了。。5 代码#include &amp;lt;iostream&amp;gt;#include &amp;lt;cmath&amp;gt;#include &amp;lt;algorithm&amp;gt;#include &amp;lt;vector&amp;gt;using namespace std;struct Point{ double x,y;};struct Vector{ double x,y; void make(Point a,Point b){ x = b.x - a.x; y = b.y - a.y; }};double cross(Vector a,Vector b){ return a.x*b.y - a.y*b.x;}double intimes(Vector a,Vector b){ return a.x*b.x + a.y*b.y;}double length(Vector a){ return sqrt(a.x*a.x + a.y*a.y);}Point crosspoint(Vector a,Vector b,Point af,Point bf){ Vector u; u.make(bf,af); double t = cross(b,u)/cross(a,b); Point k; k.x = af.x + t * a.x; k.y = af.y + t * a.y; return k;}double distance(Point a,Point b){ return sqrt((b.x-a.x)*(b.x-a.x)+(b.y-a.y)*(b.y-a.y));}double cosangle(Vector a,Vector b){ return intimes(a,b)/length(a)*length(b);}Point origin;bool cmp(Point a,Point b){ Vector A,B; A.make(origin, a); B.make(origin, b); return cross(A,B)&amp;lt;0;}double PTOL(Point p,Point a,Point b){ Vector v1,v2; v1.make(a,b); v2.make(a,p); return fabs(cross(v1,v2)/length(v1));}int main(void){ int t; cin&amp;gt;&amp;gt;t; int cnt = 0; while(t--){ vector&amp;lt;Point&amp;gt; ref; ref.clear(); cnt++; Point A,B,C,D; cin&amp;gt;&amp;gt;A.x&amp;gt;&amp;gt;A.y&amp;gt;&amp;gt;B.x&amp;gt;&amp;gt;B.y&amp;gt;&amp;gt;C.x&amp;gt;&amp;gt;C.y&amp;gt;&amp;gt;D.x&amp;gt;&amp;gt;D.y; ref.push_back(A); ref.push_back(B); ref.push_back(C); ref.push_back(D); int miny = 10000000; int minx = 10000000; int flag = 0; for(int j=0;j&amp;lt;4;j++){ if(ref[j].y&amp;lt;miny){ miny = ref[j].y; minx = ref[j].x; flag = j; }else if (ref[j].y == miny &amp;amp;&amp;amp; ref[j].x &amp;lt; minx){ miny = ref[j].y; minx = ref[j].x; flag = j; } } origin = ref[flag]; swap(ref[0],ref[flag]); sort(ref.begin()+1,ref.end(),cmp); A = ref[0]; B = ref[1]; C = ref[2]; D = ref[3]; //判断90 Vector AB,BC,CD,DA; AB.make(A,B); BC.make(B,C); CD.make(C,D); DA.make(D,A); double JA,JB,JC,JD; JA = cosangle(AB,DA); JB = cosangle(AB,BC); JC = cosangle(BC,CD); JD = cosangle(CD,DA); double LA,LB,LC,LD; LA = length(AB); LB = length(BC); LC = length(CD); LD = length(DA); cout&amp;lt;&amp;lt;&quot;Case &quot;&amp;lt;&amp;lt;cnt&amp;lt;&amp;lt;&quot;: &quot;; if(JA==0 &amp;amp;&amp;amp; JB==0 &amp;amp;&amp;amp; JC==0 &amp;amp;&amp;amp; JD==0){ if(LA==LB &amp;amp;&amp;amp; LB==LC &amp;amp;&amp;amp; LC==LD &amp;amp;&amp;amp; LD==LA){ cout&amp;lt;&amp;lt;&quot;Square&quot;&amp;lt;&amp;lt;endl; }else{ cout&amp;lt;&amp;lt;&quot;Rectangle&quot;&amp;lt;&amp;lt;endl; } }else if(LA == LB &amp;amp;&amp;amp; LB==LC &amp;amp;&amp;amp; LC==LD &amp;amp;&amp;amp; LD==LA){ cout&amp;lt;&amp;lt;&quot;Rhombus&quot;&amp;lt;&amp;lt;endl; }else if(LA==LC &amp;amp;&amp;amp; LB == LD){ cout&amp;lt;&amp;lt;&quot;Parallelogram&quot;&amp;lt;&amp;lt;endl; }else if(cross(AB,CD) == 0 || cross(DA,BC) == 0){ cout&amp;lt;&amp;lt;&quot;Trapezium&quot;&amp;lt;&amp;lt;endl; }else{ cout&amp;lt;&amp;lt;&quot;Ordinary Quadrilateral&quot;&amp;lt;&amp;lt;endl; } } return 0;} UVA 11646 1 题意：造体育场，给定比例求长宽。。2 解法：还是缺乏高中数学知识 - -。。已知弦长a，半径R，求弧长l的公式：\\(l = 2Rarcsin(\\frac{a}{2R})\\)3 坑：一如既往地只要题目简单就会卡在输入输出上。。。搞了好久。。4 代码：#include &amp;lt;iostream&amp;gt;#include &amp;lt;cmath&amp;gt;#include &amp;lt;algorithm&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;string&amp;gt;#include &amp;lt;sstream&amp;gt;using namespace std;int main(void){ double a,b; int cnt = 0; string c; while(getline(cin,c)){ stringstream ss(c); ss&amp;gt;&amp;gt;a; cnt++; char t; ss&amp;gt;&amp;gt;t; ss&amp;gt;&amp;gt;b; double x = 400.0/(2.0*sqrt(a*a+b*b)*atan(b/a)+2.0*a); printf(&quot;Case %d: %.10lf %.10lf\\n&quot;,cnt,a*x,b*x); } return 0;} 2 二维几何计算 UVA11178 1 题意有一个数学定理。。。角的三等分线相交出来的一个三角形是一个等边三角形。。。其实这道题和这个等边三角形并没有什么关系。。2 题解因为点来的方法都一样，所以只要写出来一个函数就ok。。。怎么求这个点呢？先求出一个大三角形的角，然后求三分之一角度用底边旋转出来，就可以等到这条边然后再用另一边同样的方法转出来另一条线，两个相交的交点就是小三角形的一个点。。3 模板前面没有出现的就是怎么样旋转一个向量一定的角度得到另一个向量。。又是高中数学问题公式就不写了。。直接给函数吧。。Vector Rotate(Vector a,double rad){ return (Vector){a.x*cos(rad)-a.y*sin(rad),a.x*sin(rad)+a.y*cos(rad)};}4 代码因为和前面几题并在一起写了。。。所以应该会有很多冗余的函数。。#include &amp;lt;iostream&amp;gt;#include &amp;lt;cmath&amp;gt;#include &amp;lt;algorithm&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;string&amp;gt;#include &amp;lt;sstream&amp;gt;using namespace std;struct Point{ double x,y;};struct Vector{ double x,y; void make(Point a,Point b){ x = b.x - a.x; y = b.y - a.y; }};double cross(Vector a,Vector b){ return a.x*b.y - a.y*b.x;}double intimes(Vector a,Vector b){ return a.x*b.x + a.y*b.y;}double length(Vector a){ return sqrt(a.x*a.x + a.y*a.y);}Point crosspoint(Vector a,Vector b,Point af,Point bf){ Vector u; u.make(bf,af); double t = cross(b,u)/cross(a,b); Point k; k.x = af.x + t * a.x; k.y = af.y + t * a.y; return k;}double distance(Point a,Point b){ return sqrt((b.x-a.x)*(b.x-a.x)+(b.y-a.y)*(b.y-a.y));}double cosangle(Vector a,Vector b){ return intimes(a,b)/(length(a)*length(b));}Point origin;bool cmp(Point a,Point b){ Vector A,B; A.make(origin, a); B.make(origin, b); return cross(A,B)&amp;lt;0;}double PTOL(Point p,Point a,Point b){ Vector v1,v2; v1.make(a,b); v2.make(a,p); return fabs(cross(v1,v2)/length(v1));}//将向量逆时针旋转弧度为a的角度Vector Rotate(Vector a,double rad){ return (Vector){a.x*cos(rad)-a.y*sin(rad),a.x*sin(rad)+a.y*cos(rad)};}Point GETCROSS(Point A,Point B,Point C){ Vector v1,tmp; v1.make(B,C); tmp.make(B,A); double rad = acos(cosangle(tmp,v1)); v1 = Rotate(v1,rad/3.0); Vector v2; v2.make(C,B); tmp.make(C,A); double rad2 = acos(cosangle(tmp,v2)); v2 = Rotate(v2,-rad2/3.0); return crosspoint(v1,v2,B,C);}int main(void){ int T; cin&amp;gt;&amp;gt;T; while(T--){ Point A,B,C; cin&amp;gt;&amp;gt;A.x&amp;gt;&amp;gt;A.y&amp;gt;&amp;gt;B.x&amp;gt;&amp;gt;B.y&amp;gt;&amp;gt;C.x&amp;gt;&amp;gt;C.y; Point D,E,F; D = GETCROSS(A,B,C); E = GETCROSS(B,C,A); F = GETCROSS(C,A,B); printf(&quot;%.6lf %.6lf %.6lf %.6lf %.6lf %.6lf\\n&quot;,D.x,D.y,E.x,E.y,F.x,F.y); } return 0;} UVA1342 1 题意：第一个端点和最后一个端点永远是一样重合的，一笔画划回来，问应该把这个平面变成了几块？2 思路：正如书上所言，要直接用死方法做算一块块会很麻烦，所以。。。又要知道一些『高级的』定理才能完成了。。。这里是欧拉定理： 设平面图的顶点数、边数和面数分别为V,E,F，那么V+F-E=2一条边的定义是指顶点到顶点，顶点就是所有线的交点，就算共线也算。所以题例中给出那个图，最长的那条边其实贡献了5个顶点和4条边。。。这个定理的证明么。。。网上找吧，这里地方太小写不下~然后应该就容易解决了。。。还有需要注意的就是三线共点的情况出现的话，可能会在一个集合内出现两次一样的点，就需要去重。。3 奇技淫巧这个版块就用来介绍STL里一些奇怪的函数（轮子们）。。。unique函数。。。能够在数组或者STL容器中去重，给出的和sort差不多，不过最后一个判别函数需要给出的就是怎么判别相等。。。（书上这里缺省了这个cmp函数。。。因为他在point这个类里定义了『==』操作符，这里就可以省。。前面的sort函数也是，定义了『&amp;lt;』。。如果前面没定义一定要加cmp函数。。否则交上去会出现乱七八糟的CE。。。（别问我为什么知道。。。））4 代码（和前面一样。。。。因为有很多轮子可以用，所以可能会有很多冗余函数。。）#include &amp;lt;iostream&amp;gt;#include &amp;lt;cmath&amp;gt;#include &amp;lt;algorithm&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;string&amp;gt;#include &amp;lt;sstream&amp;gt;#include &amp;lt;cstring&amp;gt;using namespace std;const int maxn = 300+10;struct Point{ double x,y;};Point P[maxn],V[maxn*maxn];const double eps = 1e-10;//判断符号int dcmp(double x){ if(fabs(x)&amp;lt;eps) return 0; else return x&amp;lt;0?-1:1;}struct Vector{ double x,y; void make(Point a,Point b){ x = b.x - a.x; y = b.y - a.y; }};double cross(Vector a,Vector b){ return a.x*b.y - a.y*b.x;}double intimes(Vector a,Vector b){ return a.x*b.x + a.y*b.y;}double length(Vector a){ return sqrt(a.x*a.x + a.y*a.y);}Point crosspoint(Vector a,Vector b,Point af,Point bf){ Vector u; u.make(bf,af); double t = cross(b,u)/cross(a,b); Point k; k.x = af.x + t * a.x; k.y = af.y + t * a.y; return k;}double distance(Point a,Point b){ return sqrt((b.x-a.x)*(b.x-a.x)+(b.y-a.y)*(b.y-a.y));}double cosangle(Vector a,Vector b){ return intimes(a,b)/(length(a)*length(b));}Point origin;bool cmp(Point a,Point b){ Vector A,B; A.make(origin, a); B.make(origin, b); return cross(A,B)&amp;lt;0;}double PTOL(Point p,Point a,Point b){ Vector v1,v2; v1.make(a,b); v2.make(a,p); return fabs(cross(v1,v2)/length(v1));}//将向量逆时针旋转弧度为a的角度Vector Rotate(Vector a,double rad){ return (Vector){a.x*cos(rad)-a.y*sin(rad),a.x*sin(rad)+a.y*cos(rad)};}//判断是否正规相交（不在端点初相交）bool SegmentProperIntersection(Point A,Point B,Point C,Point D){ Vector AB,AC,AD,CA,CD,CB; AB.make(A, B); AC.make(A, C); AD.make(A, D); CA.make(C, A); CD.make(C, D); CB.make(C, B); double c1 = cross(AB, AC),c2 = cross(AB, AD); double c3 = cross(CD, CA),c4 = cross(CD, CB); return dcmp(c1)*dcmp(c2)&amp;lt;0 &amp;amp;&amp;amp; dcmp(c3)*dcmp(c4)&amp;lt;0;}//判断是否第一个点是否在后两个点的线段上bool Onsegment(Point a,Point b,Point c){ Vector BA,CA; BA.make(a, b); CA.make(a, c); return dcmp(cross(BA, CA)) == 0 &amp;amp;&amp;amp; dcmp(intimes(BA, CA))&amp;lt;0;}int main(void){ int n,kase = 0; while(scanf(&quot;%d&quot;,&amp;amp;n)!=EOF){ memset(V, 0,sizeof(V)); memset(P, 0, sizeof(P)); if(n==0) break; for(int i=0;i&amp;lt;n;i++){ scanf(&quot;%lf%lf&quot;,&amp;amp;P[i].x,&amp;amp;P[i].y); V[i] = P[i]; } n--; //去掉最后一个点不计算 int c = n,e = n; for(int i = 0;i&amp;lt;n;i++){ for(int j=i+1;j&amp;lt;n;j++){ //求每条边之间的交点 if(SegmentProperIntersection(P[i],P[i+1],P[j],P[j+1])){ Vector a,b; a.make(P[i],P[i+1]); b.make(P[j],P[j+1]); V[c++] = crosspoint(a, b, P[i], P[j]); } } } sort(V,V+c,[](Point a, Point b){ return a.x &amp;lt; b.x || (a.x==b.x &amp;amp;&amp;amp; a.y&amp;lt;b.y); }); c = (int)(unique(V,V+c,[](Point a, Point b){ return dcmp(a.x-b.x)==0 &amp;amp;&amp;amp; dcmp(a.y-b.y)==0; })-V); //去重 //求边数 for(int i=0;i&amp;lt;c;i++){ for(int j=0;j&amp;lt;n;j++){ if(Onsegment(V[i],P[j], P[j+1])) e++; } } printf(&quot;Case %d: There are %d pieces.\\n&quot;,++kase,e+2-c); } return 0;} UVA11796 1 题意这道题蛮复杂的。。。就是两只狗赛跑，同时出发同时到达，每只狗呢经过的点不一样。。（起点终点可能不同，在后面的数据中可以看出来）。问的是他们在跑的时候最长和最短距离是多少。2 思路把狗简化成A,B两个点。。首先考虑一个『简化版』的，如果A,B均各自在一条直线上移动，那么可以想到的就是如果A一开始不动，B开始动，那么整道题就可以被简化成A点到B点移动直线上的最短最长距离。然后再来看如果是在折线上的话，就模拟整个过程，A,B开始走，在各自经过第一个转折点之前，所有的情况都和简化版是一样的，只要根据谁先到各自的下一个转折点的时间和距离来计算最大最小距离，然后以此类推，都各自去计算在同一个时段内，大家距离下一个转折点的时候的情况。时间取出到下一个转折点快的那个，然后比较取最大最小。3 奇技淫巧double数的话，用printf(“%.0f”)可以四舍五入 （这道题是可以，其他地方是否可以待考）。4 注意点点到线段距离要考虑各种各样的情况，不能直接取垂线。计算几何的代码很长。。注意细节5 代码#include &amp;lt;iostream&amp;gt;#include &amp;lt;cmath&amp;gt;#include &amp;lt;algorithm&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;string&amp;gt;#include &amp;lt;sstream&amp;gt;#include &amp;lt;cstring&amp;gt;using namespace std;struct Point{ double x,y;};const double eps = 1e-10;//判断符号int dcmp(double x){ if(fabs(x)&amp;lt;eps) return 0; else return x&amp;lt;0?-1:1;}struct Vector{ double x,y; Vector make(Point a,Point b){ x = b.x - a.x; y = b.y - a.y; return (Vector){x,y}; }};double cross(Vector a,Vector b){ return a.x*b.y - a.y*b.x;}double intimes(Vector a,Vector b){ return a.x*b.x + a.y*b.y;}double length(Vector a){ return sqrt(a.x*a.x + a.y*a.y);}Point crosspoint(Vector a,Vector b,Point af,Point bf){ Vector u; u.make(bf,af); double t = cross(b,u)/cross(a,b); Point k; k.x = af.x + t * a.x; k.y = af.y + t * a.y; return k;}double distance(Point a,Point b){ return sqrt((b.x-a.x)*(b.x-a.x)+(b.y-a.y)*(b.y-a.y));}double cosangle(Vector a,Vector b){ return intimes(a,b)/(length(a)*length(b));}Point origin;bool cmp(Point a,Point b){ Vector A,B; A.make(origin, a); B.make(origin, b); return cross(A,B)&amp;lt;0;}double PTOL(Point p,Point a,Point b){ Vector v1,v2,v3; v1.make(a,b); if(dcmp(v1.x-0) == 0&amp;amp;&amp;amp; dcmp(v1.y-0) == 0) return fabs(distance(p,a)); v2.make(a,p); v3.make(b,p); if(dcmp(intimes(v1, v2))&amp;lt;0) return length(v2); else if(dcmp(intimes(v1, v3))&amp;gt;0) return length(v3); return fabs(cross(v1,v2)/length(v1));}//将向量逆时针旋转弧度为a的角度Vector Rotate(Vector a,double rad){ return (Vector){a.x*cos(rad)-a.y*sin(rad),a.x*sin(rad)+a.y*cos(rad)};}//判断是否正规相交（不在端点初相交）bool SegmentProperIntersection(Point A,Point B,Point C,Point D){ Vector AB,AC,AD,CA,CD,CB; AB.make(A, B); AC.make(A, C); AD.make(A, D); CA.make(C, A); CD.make(C, D); CB.make(C, B); double c1 = cross(AB, AC),c2 = cross(AB, AD); double c3 = cross(CD, CA),c4 = cross(CD, CB); return dcmp(c1)*dcmp(c2)&amp;lt;0 &amp;amp;&amp;amp; dcmp(c3)*dcmp(c4)&amp;lt;0;}//判断是否第一个点是否在后两个点的线段上bool Onsegment(Point a,Point b,Point c){ Vector BA,CA; BA.make(a, b); CA.make(a, c); return dcmp(cross(BA, CA)) == 0 &amp;amp;&amp;amp; dcmp(intimes(BA, CA))&amp;lt;0;}const int maxn = 60;int T,A,B;Point P[maxn],Q[maxn];double Min,Max;void update(Point P,Point A,Point B){ Vector AB,PA,PB; AB.make(A, B); PA.make(A, P); PB.make(B, P); Min = min(Min,PTOL(P,A,B)); Max = max(Max,length(PA)); Max = max(Max,length(PB));}int main(void){ scanf(&quot;%d&quot;,&amp;amp;T); for(int kase = 1;kase&amp;lt;=T;kase++){ scanf(&quot;%d%d&quot;,&amp;amp;A,&amp;amp;B); for(int i=0;i&amp;lt;A;i++) scanf(&quot;%lf%lf&quot;,&amp;amp;P[i].x,&amp;amp;P[i].y); for(int i=0;i&amp;lt;B;i++) scanf(&quot;%lf%lf&quot;,&amp;amp;Q[i].x,&amp;amp;Q[i].y); double LenA = 0,LenB = 0; Vector tmp; for(int i=0;i&amp;lt;A-1;i++){tmp.make(P[i], P[i+1]);LenA+=length(tmp);} for(int i=0;i&amp;lt;B-1;i++){tmp.make(Q[i], Q[i+1]);LenB+=length(tmp);} int SA=0,SB=0; Point Pa = P[0],PB = Q[0]; Min = 1e9,Max = -1e9; while(SA&amp;lt;A-1 &amp;amp;&amp;amp; SB&amp;lt;B-1){ Vector tmp; double LA = length(tmp.make(Pa, P[SA+1])); double LB = length(tmp.make(PB, Q[SB+1])); double T = min(LA/LenA,LB/LenB); tmp.make(Pa, P[SA+1]); Vector Va = (Vector){tmp.x/LA*(T*LenA),tmp.y/LA*(T*LenA)}; tmp.make(PB, Q[SB+1]); Vector Vb = (Vector){tmp.x/LB*(T*LenB),tmp.y/LB*(T*LenB)}; update(Pa, PB, (Point){PB.x+Vb.x-Va.x,PB.y+Vb.y-Va.y}); //A不动，B动 Pa = (Point){Pa.x+Va.x,Pa.y+Va.y}; PB = (Point){PB.x+Vb.x,PB.y+Vb.y}; if(dcmp(Pa.x-P[SA+1].x) == 0 &amp;amp;&amp;amp; dcmp(Pa.y-P[SA+1].y)==0) SA++; if(dcmp(PB.x-Q[SB+1].x) == 0 &amp;amp;&amp;amp; dcmp(PB.y-Q[SB+1].y)==0) SB++; } printf(&quot;Case %d: %.0f\\n&quot;,kase,Max-Min); } return 0;} 3 二维几何算法 UVA 10652 1 题意纯粹的求凸包，最后加一个求面积就ok。。。2 坑告诉你的旋转角度是角度制，要换成弧度制。。。注意要加个负号，否则会错。。。3 代码凸包的求法和一般的G算法不一样。。。感觉用起来比那个方便，不过他直接省略了共线的凸包点有冗余函数#include &amp;lt;iostream&amp;gt;#include &amp;lt;cmath&amp;gt;#include &amp;lt;algorithm&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;string&amp;gt;#include &amp;lt;sstream&amp;gt;#include &amp;lt;cstring&amp;gt;using namespace std;struct Point{ double x,y; };const double eps = 1e-5;//判断符号int dcmp(double x){ if(fabs(x)&amp;lt;eps) return 0; else return x&amp;lt;0?-1:1;}struct Vector{ double x,y; Vector make(Point a,Point b){ x = b.x - a.x; y = b.y - a.y; return (Vector){x,y}; }};Point operator + (Point A,Vector B){ return (Point){A.x+B.x,A.y+B.y};}struct Circle{ Point c; double r;// Circle();// Circle(Point c,double r):c(c),r(r){} Point point(double a){ return (Point){c.x+cos(a)*r,c.y+sin(a)*r}; }};double cross(Vector a,Vector b){ return a.x*b.y - a.y*b.x;}double intimes(Vector a,Vector b){ return a.x*b.x + a.y*b.y;}double length(Vector a){ return sqrt(a.x*a.x + a.y*a.y);}Point crosspoint(Vector a,Vector b,Point af,Point bf){ Vector u; u.make(bf,af); double t = cross(b,u)/cross(a,b); Point k; k.x = af.x + t * a.x; k.y = af.y + t * a.y; return k;}double distance(Point a,Point b){ return sqrt((b.x-a.x)*(b.x-a.x)+(b.y-a.y)*(b.y-a.y));}double cosangle(Vector a,Vector b){ return intimes(a,b)/(length(a)*length(b));}Point origin;bool cmp(Point a,Point b){ Vector A,B; A.make(origin, a); B.make(origin, b); return cross(A,B)&amp;lt;0;}double PTOL(Point p,Point a,Point b){ Vector v1,v2,v3; v1.make(a,b); if(dcmp(v1.x-0) == 0&amp;amp;&amp;amp; dcmp(v1.y-0) == 0) return fabs(distance(p,a)); v2.make(a,p); v3.make(b,p); if(dcmp(intimes(v1, v2))&amp;lt;0) return length(v2); else if(dcmp(intimes(v1, v3))&amp;gt;0) return length(v3); return fabs(cross(v1,v2)/length(v1));}//将向量逆时针旋转弧度为a的角度Vector Rotate(Vector a,double rad){ return (Vector){a.x*cos(rad)-a.y*sin(rad),a.x*sin(rad)+a.y*cos(rad)};}//判断是否正规相交（不在端点初相交）bool SegmentProperIntersection(Point A,Point B,Point C,Point D){ Vector AB,AC,AD,CA,CD,CB; AB.make(A, B); AC.make(A, C); AD.make(A, D); CA.make(C, A); CD.make(C, D); CB.make(C, B); double c1 = cross(AB, AC),c2 = cross(AB, AD); double c3 = cross(CD, CA),c4 = cross(CD, CB); return dcmp(c1)*dcmp(c2)&amp;lt;0 &amp;amp;&amp;amp; dcmp(c3)*dcmp(c4)&amp;lt;0;}//判断是否第一个点是否在后两个点的线段上bool Onsegment(Point a,Point b,Point c){ Vector BA,CA; BA.make(a, b); CA.make(a, c); return dcmp(cross(BA, CA)) == 0 &amp;amp;&amp;amp; dcmp(intimes(BA, CA))&amp;lt;0;}bool compare(Point p1,Point p2){ return p1.x&amp;lt;p2.x || (dcmp(p1.x-p2.x)==0 &amp;amp;&amp;amp; p1.y&amp;lt;p2.y);}Point ToConvexHull[10000];Point CH[10000];void cle(){ memset(ToConvexHull,0, sizeof(ToConvexHull)); memset(CH,0, sizeof(CH));}// 凸包去除了共線上的點int ConvexHull(int n){ sort(ToConvexHull,ToConvexHull+n,compare); int m = 0; Vector v1,v2; for(int i = 0;i&amp;lt;n;i++){ while(m&amp;gt;1 &amp;amp;&amp;amp; cross(v1.make(CH[m-2],CH[m-1]), v2.make(CH[m-2], ToConvexHull[i]))&amp;lt;=0) m--; CH[m++] = ToConvexHull[i]; } int k = m; for(int i = n-2;i&amp;gt;=0;i--){ while(m&amp;gt;k &amp;amp;&amp;amp; cross(v1.make(CH[m-2], CH[m-1]), v2.make(CH[m-2], ToConvexHull[i]))&amp;lt;=0) m--; CH[m++] = ToConvexHull[i]; } if(n&amp;gt;1) m--; return m;}double PolygonArea(Point *p,int n){ double area = 0; Vector v1,v2; for(int i = 1;i&amp;lt;n-1;i++){ area += cross(v1.make(p[0], p[i]), v2.make(p[0], p[i+1])); } return fabs(area/2);}int main(void){ //freopen(&quot;/Users/mouizumi/Desktop/TEXT.txt&quot;, &quot;r&quot;, stdin); int T; scanf(&quot;%d&quot;,&amp;amp;T); while(T--){ int n,pc = 0; double areal = 0; scanf(&quot;%d&quot;,&amp;amp;n); for(int i=0;i&amp;lt;n;i++){ double x,y,w,h,j,ang; scanf(&quot;%lf%lf%lf%lf%lf&quot;,&amp;amp;x,&amp;amp;y,&amp;amp;w,&amp;amp;h,&amp;amp;j); Point o; o.x = x; o.y = y; ang = -j/180*M_PI; ToConvexHull[pc++] = o + Rotate((Vector){-w/2,-h/2}, ang); ToConvexHull[pc++] = o + Rotate((Vector){w/2,-h/2}, ang); ToConvexHull[pc++] = o + Rotate((Vector){-w/2,h/2}, ang); ToConvexHull[pc++] = o + Rotate((Vector){w/2,h/2}, ang); areal += w*h; } int m = ConvexHull(pc); double area2 = PolygonArea(CH,m); printf(&quot;%.1lf %%\\n&quot;,areal*100/area2); } return 0;} UVA 11168 1 题意抛开现象看本质就是有一些点，求一条直线，让所有的点在这一条直线的一侧，然后所有点到这条线的距离之和最小，输出的数据是平均距离。2 解法用所给的点求一个凸包，然后可以得到凸包，要求这条直线，为了让直线在这个凸包的一侧距离又最小，不妨就让这条直线就是凸包的一条边。枚举所有的边，并且去求所有点距离这条边的距离，取小的。如果只有2个点，那么他们的最小距离直接就是0，因为无法求凸包！3 技巧利用点到线的距离公式，可以巧妙的解决所有点到直线距离。\\(Ax+By+C = 0 点(x_0,y_0),d= \\frac{|Ax_0+By_0+c|}{\\sqrt{A^2+B^2}}\\)因为这里所有的点都在这条直线的一侧，所以可以直接用之前就在输入的时候就预算好的x，y的和值就可以得到距离和。两点构成的直线，化成一般式\\(\\frac{x-x_1}{x_2-x_1}= \\frac{y-y_1}{y_2-y_1} \\Rightarrow (y_2-y_1)x+(x_1-x2)y+(x_2y_1-x_1y_2) = 0\\)不妨设x的所有和为X,y的所有和为Y，n为点的个数，那么式子就可以有：\\(\\frac{|A(X-x_1-x_2)+B(Y-y_1-y_2)+(n-2)C|}{\\sqrt{A^2+B^2}}\\)4 代码好吧好吧。。我删掉了冗余函数#include &amp;lt;iostream&amp;gt;#include &amp;lt;cmath&amp;gt;#include &amp;lt;algorithm&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;string&amp;gt;#include &amp;lt;sstream&amp;gt;#include &amp;lt;cstring&amp;gt;using namespace std;struct Point{ double x,y; };const double eps = 1e-5;//判断符号int dcmp(double x){ if(fabs(x)&amp;lt;eps) return 0; else return x&amp;lt;0?-1:1;}struct Vector{ double x,y; Vector make(Point a,Point b){ x = b.x - a.x; y = b.y - a.y; return (Vector){x,y}; }};Point operator + (Point A,Vector B){ return (Point){A.x+B.x,A.y+B.y};}double cross(Vector a,Vector b){ return a.x*b.y - a.y*b.x;}double intimes(Vector a,Vector b){ return a.x*b.x + a.y*b.y;}bool compare(Point p1,Point p2){ return p1.x&amp;lt;p2.x || (dcmp(p1.x-p2.x)==0 &amp;amp;&amp;amp; p1.y&amp;lt;p2.y);}Point ToConvexHull[10000];Point CH[10000];void cle(){ memset(ToConvexHull,0, sizeof(ToConvexHull)); memset(CH,0, sizeof(CH));}// 去除了共線上的點int ConvexHull(int n){ sort(ToConvexHull,ToConvexHull+n,compare); int m = 0; Vector v1,v2; for(int i = 0;i&amp;lt;n;i++){ while(m&amp;gt;1 &amp;amp;&amp;amp; cross(v1.make(CH[m-2],CH[m-1]), v2.make(CH[m-2], ToConvexHull[i]))&amp;lt;=0) m--; CH[m++] = ToConvexHull[i]; } int k = m; for(int i = n-2;i&amp;gt;=0;i--){ while(m&amp;gt;k &amp;amp;&amp;amp; cross(v1.make(CH[m-2], CH[m-1]), v2.make(CH[m-2], ToConvexHull[i]))&amp;lt;=0) m--; CH[m++] = ToConvexHull[i]; } if(n&amp;gt;1) m--; return m;}int main(void){ freopen(&quot;/Users/mouizumi/Desktop/TEXT.txt&quot;, &quot;r&quot;, stdin); int T; scanf(&quot;%d&quot;,&amp;amp;T); int kase = 0; while(T--){ cle(); int n; scanf(&quot;%d&quot;,&amp;amp;n); long long allx=0,ally=0; for(int j=0;j&amp;lt;n;j++){ cin&amp;gt;&amp;gt;ToConvexHull[j].x&amp;gt;&amp;gt;ToConvexHull[j].y; allx+=ToConvexHull[j].x; ally+=ToConvexHull[j].y; } double mini = 10000000000; if(n&amp;gt;2){ int m = ConvexHull(n); for(int j=0;j&amp;lt;m;j++){ Point e,f; e = CH[j]; f = CH[(j+1)%m]; double A,B,C; A = f.y - e.y; B = e.x - f.x; C = f.x * e.y - e.x * f.y; double Q = sqrt(A*A+B*B); double dis = fabs((A*(allx - e.x - f.x)+B*(ally - e.y - f.y)+ (n-2)*C))/Q; if(dcmp(dis - mini)&amp;lt;0) mini = dis; } } else{ mini = 0.00; } printf(&quot;Case #%d: %.3lf\\n&quot;,++kase,mini/n); } return 0;}" }, { "title": "算法导论", "url": "/posts/algorithm/", "categories": "技术", "tags": "算法, 数学", "date": "2016-02-15 04:21:36 +0800", "snippet": "本文中含有数学公式，若无法显示请刷新重试，谢谢~Lesson 1插入排序1 插入排序的基本原理（递增排序）取当前元素往前序寻找。依序比较，若前一元素比当前大，则被比较元素往后移动一位；以此类推，直至找到第一个比其小的元素，则停止寻找，这个位置的后一个就是应该放的位置。2 插入排序的C++实现void insertionsort(vector&amp;lt;int&amp;gt;sorted){ int size = (int)sorted.size(); //从第2项开始取为目标元素 for(int j=1;j&amp;lt;size;j++){ int key = sorted[j]; //需要比较的是目标元素的前一项开始 int k = j-1; //向后移动的必要条件 while(k&amp;gt;=0 &amp;amp;&amp;amp; sorted[k]&amp;gt;key){ sorted[k+1] = sorted[k]; k--; } //跳出循环，找到了应该在的位置 sorted[k+1] = key; }}3 插入排序算法的分析 时间复杂度上界 \\[O(n^2)\\]几个标记符号的数学定义 几个注意点： 渐进符号只关心两个函数在极限位置的大小状况。 所有的渐进符号都代表着一种函数，为集合概念，『=』仅为方便记载，对应于集合论中『∈』符号，理论上前后不调换。 性质：传递，自反，对称，转置对称 若在等式或不等式中出现的时候，则表示这一类的匿名函数，若出现在等式右边，可以另设一个函数f(x)来替代这个符号所表示的位置。若出现在左边，则可用以下规则解释：无论怎样选择等号左边的匿名函数，总有一种方法来选择等号右边的匿名函数使等号成立。Ex.\\[2n^2+3n+1=2n^2+\\Theta(n)=\\Theta(n^2)\\]第一个等式：[表明存在某个函数f(n) \\in \\Theta(n),使得对所有的n，有2n^2+3n+1=2n+f(n)。]第二个等式：[表明对于任意函数g(n)\\in\\Theta(n),存在h(x)\\in\\Theta(n^2),使得对所有的n，有2n^2+g(n)=h(n)。]整体也蕴含着前项直接可以属于最后项（这个法则仅对有限项有效） 渐进上界\\[O(g(n)) = \\{f(n) ：\\exists c&amp;gt;0,n_0&amp;gt;0 ;对于\\forall n\\ge n_0 都有0\\le f(n) \\le c·g(n) \\}\\] 渐进上界的计算方式：忽略所有低阶项和最高阶前之前的常数系数。 渐进下界\\[\\Omega (g(n)) = \\{f(n) ：\\exists c&amp;gt;0,n_0&amp;gt;0 ;对于\\forall n\\ge n_0 都有0\\le c·g(n) \\le f(n) \\}\\] 渐进紧确界\\[\\Theta(g(n))=\\{f(n):\\exists 正常数 c_1,c_2,n_0;使得对\\forall n\\ge n_0,都有0\\le c_1·g(n)\\le f(n) \\le c2·g(n) \\}\\] o记号基本同O符号，但需要对所有c&amp;gt;0成立。 ω记号基本同Ω符号，但需要对所有c&amp;gt;0成立归并排序1 归并排序的基本思想：分治法(Divide and Conquer)2 归并排序的C++实现：vector&amp;lt;int&amp;gt; sorted;//归并操作void merge(int left,int mid,int right){ //将左右两边分别放入新建的数组当中，方便进行归并操作 int n1 = mid-left+1; int n2 = right-mid; vector&amp;lt;int&amp;gt;L,R; L.clear(); R.clear(); for(int i=1;i&amp;lt;=n1;i++){ L.push_back(sorted[left+i-1]); } for(int i=1;i&amp;lt;=n2;i++){ R.push_back(sorted[mid+i]); } //归并排序，利用子序列已经排完序的性质，只需要比较首元素即可 int i=0,j=0; for(int k=left;k&amp;lt;=right;k++){ if(L[i]&amp;lt;=R[j]){ sorted[k] = L[i]; i++; }else{ sorted[k] = R[j]; j++; } //不使用哨兵，利用下标到达界限判断 if(i==L.size()){ k++; for(int u=j;u&amp;lt;R.size();u++){ sorted[k] = R[u]; k++; } break; } if(j==R.size()){ k++; for(int u=i;u&amp;lt;L.size();u++){ sorted[k] = L[u]; k++; } break; } }}//执行归并函数所需要调用的入口void mergesort(int leftlim,int rightlim){ //若大于等于则表示已经只有一个元素，不需要进行递归进入下一步 if(leftlim&amp;lt;rightlim){ int mid = (leftlim+rightlim)/2; //左侧递归进行归并 mergesort(leftlim,mid); //右侧递归进行归并 mergesort(mid+1,rightlim); //合并 merge(leftlim,mid,rightlim); }}3 归并排序的递归式[T(n) = 2T(n/2)+\\Theta(n) (n &amp;gt; 1)][T(n) = \\Theta(1) (n=1)]4 递归式的时间复杂度分析这里利用递归树的方法。具体在L2中解释，利用这个方法可以得到归并排序的时间复杂度为[O(nlgn)]可知归并排序在更大规模时比插入排序更优。" }, { "title": "2016年的几项重点任务", "url": "/posts/2016point/", "categories": "个人杂记", "tags": "其他", "date": "2016-02-15 04:21:36 +0800", "snippet": "虽然新年已经开始好几天了，但是新年任务列表任然不能少，尽量完成吧。。Listed by importanceiOS开发学习算法导论以及数据结构的复习学习六级考试二刷复习+词汇量积累Algorithm Contest （Codeforce &amp;amp; ACM）校内重点课程：编译原理/操作系统/算法分析与设计/概率论多读书！！（文史哲等）以上列表应该会及时在blog有follow up….继续努力，加油骚年~MADE BY ME2016.2.16 （农历正月初九）" }, { "title": "New Year Again", "url": "/posts/newyearagain/", "categories": "NEWYEAR", "tags": "新年, 年终", "date": "2015-12-31 10:21:36 +0800", "snippet": "2015又将成为一个历史。回顾这一年，就像最后收官的证券市场一样，从宏观看似平淡无奇，但细看内部却是波澜壮阔，起起伏伏的一年。年终总结这种事情也不是第一年做了，但是今年貌似有点不一样的感觉，有很多东西可以写，但是却是无从下笔，不知从哪里开始。后方虽然是年终总结，但掺杂鸡汤以及各种人生感悟，不想看可以关掉了：)又是一年过去，人生10年代的最后一年突然感觉时间过得越来越快，一天一天的度过，但感觉今年每天的满足感却越来越少，尤其接近年底，心情却是越来越失落。大学生活的第一个一整年，步入了大二，却在学习上越来越松懈，似乎目标越来越迷茫，什么东西都想要涉及，但是任何方面似乎都是浅尝辄止，没有深究的心思。人生的目标十分重要，如果没有了这样的目标，感觉所有的东西都没有地方开始组织，都那样的凌乱无序。不过人生的意义是否就是为了自己的成长呢？这个问题似乎难以回答，但我感觉在人生的前部分就应该充实自己，让自己在一个擅长的领域十足的优秀。俗话说，三百六十行，行行出状元。如果能在一个方面足够优秀，就能够用这样的光芒来遮挡那些有点不足的地方。而在人生的后半段却可以用这个闪光点去帮助其他人，律师用自己的知识帮助他人赢得官司（Legal High！），医生用自己的双手和知识为病人延续生命（没错，就是续命），程序员可以用自己的键盘和面前的电脑让全世界人的生活过得更好（Write the code，change the world.）。这或许就是人生，无论有意无意的在心中栽种下一个种子，一颗善良的种子。这个世界的人类如果失去了这样的善良，这个社会就会失去了最重要的人情味。人生需要改变，无论是物质还是思想。正所谓旧的不去新的不来。更换了自己房间中7年的家具，处理了去年不愿意处理的高三的种种书籍，似乎变得敞亮了不少。扔掉了所谓的思想的枷锁，追求自由民主，追求这个世界的主流价值观（抵制什么就不说了），似乎上了一个台阶就能够感受到以前的自己是那么的愚钝，其实有些事情不一定要顺从，follow your heart才是最重要的选择底线，一个成长到19岁的成年人应该有着自己最基本的处事准则，判断一件事情是否值得去花时间顺从，花时间解决应该并不是困难的事情，so follow your heart。没有尝试过自由民主滋味的人，怎么知道这样是什么感觉，生活在上个世纪的人们，坚守着迂腐思想的人永远不会接受这个可以充分发挥所有人动力的制度。2015年，或许是偶然，也或许是必然。在特殊的机遇巧合中了解到了我们一衣带水的邻邦—日本。疯狂的刷着日本的综艺节目，那只有10集左右的精巧日剧，曲风悠扬的日本旋律。也了解到很多来自日本的地名。虽然没有机会明年的1月中旬去到这个国家，但是我相信2016年也应该会踏上这片土地（这应该不算是flag把。。。）。日剧似乎最擅长的就是无形鸡汤，这样的鸡汤令人欲罢不能。。。来年，学好日语，踏平日本东西南北。。。😏今年的两次出行都去往了同一个目的地—香港。这里并不想把这篇文写成游记（香港游记似乎以后也不会补。。。），不过香港这几座小岛确实能让人魂牵梦绕。（貌似我对岛都有一点情结。。）从繁华的香港岛到古早味的九龙半岛，从遥远的大屿山到充满山脊的南丫岛。湾仔中环天后石澳尖沙咀油麻地等等这些地名都从原来的遥远变成了深深的印在脑中。香港不仅仅是只有市景，更有无敌海景以及山景。无论和谁一起都能够一起游览这些景色，未来希望还能够和朋友们再一次前往。这一年全程关注的中华民国明年的中央公职人员选举，一年来风风雨雨似乎都在中国国民党上，从洪秀柱的惊奇决定到连署过关，民调高调跨过，但是却无奈被换，这一切都看出了洪秀柱柱柱姐身为一介女子心中的胸怀和勇气，这些都是国民党那些外斗外行，内斗内行的大男人所无法比拟的。回顾这一年，虽然没有全程记录自己的运转记录，但是却把自己的足迹踏遍了除崇明县以外的上海市全境。从松江到青浦，从川沙到南桥，从宝山到嘉定用上海发达的公共交通看到了这座充满着荣光的城市所不为人知的一面，看到了上海市的农村，上海市的农村之景中并没有看到这座城市的迹象。不过城市总不能只有高楼大厦，无论是在市中心还是在农村郊区，都应该有着其他的别致景色，才有正常的城市气息。这一年里，用双脚丈量这座城市的点点滴滴。市中心的点滴之景，市井气息都亲自感受，这样的感觉是从车辆中，地铁中匆匆划过所无法感受的，虽然慢行，但是却可以更好的了解这座城市，明白这里的过去和将来。不过我也希望如果能有一辆自行车或许可以去到更远的地方，更好的看看这座充满着沧桑的城市。人生就是如此，一年又一年的过。又一个365天匆匆而过，回望这一年有过欢笑，同样也有过迷茫和失落，有过千里远足，也有过所住城市的趴趴走。每一年的纷纷扰扰都希望留在当年，但是人的记忆却不容许这样的行为，人总是会念旧的。未来的种种没有人会知道，人所能了解的只有当下和过去，人的一生其实是线性向前的没有回头路，如果没有认为的把每365天边做一个轮回，每一天都是新的一天，每一天都和过去毫无关系。历法的存在让过去和未来有着可比性，也把这个世界的所有人放在了同一天中，无论您的人生从哪一天开始，我们所生活的都是同样的这一天，这或许也是另一种意义上的平等吧。未来的一年总会有着种种的期望，这一年没有完成的总会想在未来完成。人生的第一个20年已经这样的匆匆而过，来年的20岁，希望能过更像一位能够独当一面的男子，挥手告别这前20年的童真青年时代，20s年代，你好！能够看到这里的同学们都是勇士，看完我的种种鸡汤和吐槽。どうぞ　ありがとうございます！每一年的今天都有着同样的心情，每一年的今天都怀着美好的期望。但是每一天似乎都能够成为新年的开始，改变又何须等到12月31日，改变和改革都需要勇气，大刀阔斧的向前，改变自己才能够让未来的那个你感谢现在的自己。改变就可以从现在开始，从当下开始，从现在的这一秒开始。祝全天下的所有人在2016年都能够生活得更好，也能够友谊地久天长。未来的一切，Que Sara Sara。顺颂时祺。敬上2015年12月31日17:55" }, { "title": "2015年年終回顧", "url": "/posts/hongxiuzhu/", "categories": "NEWYEAR", "tags": "洪秀柱, 中国国民党, 演讲稿", "date": "2015-12-30 08:21:09 +0800", "snippet": "洪秀柱在中國國民黨臨時全代會上的演講這篇演講感染力極強，令人念念不忘，特此作為今年年終總結的第一部份馬總統、吳副總統、連前主席、蕭前副總統、吳前主席、朱主席、敬愛的黨代表先進、以及場內外所有關心秀柱的好朋友，大家午安：今天勞駕諸位再度前來討論總統提名人選的存廢，秀柱實在心中難安，想想719全代會上的齊心歡呼，如今場景和人物依舊，但心思可能不同了。或許白雲蒼狗，世事難料，但秀柱此刻的心情可說是「世路如今已慣，此心到處悠然」。不知道幾分鐘後我的身分會不會改變，但不變的是，我對黨的熱愛，以及我對中華民國的期盼。我說過我會尊重臨全會的決定，黨可以不要我，但我不會放棄黨！中國國民黨，從兩個甲子以前的興中會、同盟會一路蛻變成長，她曾經是由大地上一群感受人民痛苦最深切的青年組合而成，創黨的先輩認為『吾輩處今日之中國，無時無地不可以死』，因此發誓以鮮血衝出國族的生路。今天，我們在紀念總理的殿堂中集會，誰能不感受先烈們『我死，國生』的無私情懷？世俗利害的種種考慮，到這裡，都不應該出現。去年九合一敗選後，黨內四顧茫茫，支持者灰心喪志，在低迷的氛圍中，本黨幾乎喪失了為2016大選奮戰的勇氣。今年年初，無論外界如何催促，黨內天王再三婉拒參選，秀柱和多數黨員同志一樣憂心如焚，為了避免外界譏笑泱泱大黨竟無一人應戰，秀柱責無旁貸的投入初選，希望藉此喚醒大家共赴黨難，力挽狂瀾。因此，從4月20日登記領表開始，秀柱循黨內機制一步一腳印，上山下海尋求連署，衝破連署門檻和防磚民調的嚴格考驗，完成所有程序，成為本黨創黨以來第一位經由民主初選機制所產生的總統候選人。一路走來，雖然秀柱嚐盡苦頭、歷盡磨難，但看到冷漠的人心被喚回，看到支持者槁木般的心志重新被點燃，終於我們的努力可以讓群眾相信:改變是可能的！坦白說，過去十幾年的兩次政黨輪替，輪替的只是人民彼此間的仇恨和嘲弄，既未撫平社會的裂痕，更未替這片曾經美麗的土地、淳樸的人民、潛力無窮的國家建立共同的願景。各位先進，我們的國家今天出了問題，本黨當然有責任。本黨在是非價值、國家道路上的模糊、姑息、妥協、放棄，讓本黨在面對挑戰時，已經沒有勇氣再說真話，說對的話，沒有信心再捍衛我們的原則，捍衛我們的價值。總理遺囑說我們要「喚醒民眾」，但是現在本黨還有幾個人有勇氣去喚醒民眾，來認識到我們國家險峻的處境呢？容我沈重指出，我們的國家已經陷入被邊緣化的處境，外在的局勢日趨不利，而我們卻沈溺於政治惡鬥、爭權奪利的無窮內耗中，誰曾經仔細考量該如何為此困局解套？我們原已窘迫的政經情勢，在學運之後，更陷入動彈不得的困境，誰又真正用心探求出路在哪裡？當政治人物都以贏得選舉作為從政的最高原則，以保持權位作為唯一目的時，還有誰會思考國家的前途？還有誰會關心年輕人的未來？一個政黨可以失去一次選舉，但是不可以失去她的靈魂；可以失去她的版圖，但不可以失掉她對價值的堅持。成敗勝負本是常態，但是失去黨魂、黨德與路線，這個黨必將淪亡。而我們國家和本黨是息息相關的，我們的黨淪亡了，我們的國家又將何去何從？這三個月來，如同參加初選開始，我從來沒有一絲懈怠；一路走來，選民的熱烈支持讓我無比振奮，國人的殷切寄望更令我充滿信心！我深知，要人民重拾對本黨的信心多麼不易，為國家確定一條正確的道路更是何其艱難。但這正是我的參選初衷，也是本黨當前的重責大任！而今儘管遭遇種種橫逆，我心如初，無怨無悔！本黨目前的兩岸論述是「九二共識、一中各表」。我完全了解這個主張為兩岸交流做出了卓越的歷史貢獻，但是它僅維持兩岸關係脆弱地穩定。做為本黨的總統參選人，我希望再進一步，為兩岸創造和平，這是中華民國總統責無旁貸的使命，因此我提出在五個前提下簽署兩岸和平協定，這不是投降，更不是賣臺，而是我們與人民同命共生的願力！和平是人民的共識，和平協定當然符合主流民意！如果本黨的總統參選人不敢堅持這點，這才是違反黨章，背離民意！秀柱是50年的資深黨員，從政以來奉獻黨國，無怨無悔，幾次黨最艱困的時候，從未離她而去。這段期間，秀柱陷入有生以來最痛苦的長考，我要不要為了捍衛我的價值理念，與我深愛的黨對簿公堂？我要不要回應廣大的支持者，而讓黨的同志們為了秀柱一人的參選資格而針鋒相對？我不忍亦不願看黨走向分裂的歧途，但更痛心我所愛的黨走向沉淪，讓民眾對這個黨的信任消失殆盡！我一再指出，我對程序正義的憂心。孔子說為政之道：「民無信不立」。國不可無信，黨可不可以沒有誠信呢？有人說，今天是個換柱的全代會，我不同意，在我心裡，今天是個讓秀柱取得黨代表同志支持的全代會。我知道，待會，將決定秀柱提名資格的存廢，此時不禁讓我想起先父在他受難記中所講的一段話：「將來有機會為國家做事，仍當盡忠職守，切勿為名利參與政治，合則留，不合則去，切勿戀棧」。所以，我要懇請各位同志，不要為洪秀柱著想，請為國民黨在未來的台灣，應該扮演何種角色著想。中華民國，是華人民主的標竿，本黨今天的決議，不只黨員在看，全台灣人民在看，所有關心華人民主進程者，也都在看！然而，我真的不希望變成「台灣第一次，世界都在看」！在這次選舉過後，未來當我們談到民主制度的建立，以及程序正當性的捍衛時，本黨今日所為，究竟會如何載入輝煌的黨史呢？ 「天下為公」是我國政治的理想境界，也是我們總理中山先生最愛書寫以明志的理念。天下，為天下人所共有，同樣的，我們的黨也不是只屬於全體黨員，她也是台灣人民所共有，今天我們的選擇，是否也要向人民負責、也要向歷史交代呢？我們是否要依社會的觀感、人民的認知來決定我們相信什麼，還是要因選舉考量而犧牲制度，反而讓本黨陷於喪失誠信、黨格與黨魂的險境？我堅定的宣告，我是永遠的中國國民黨黨員，本黨必須成為一個讓支持者驕傲的選項，必須作為穩定兩岸和平的一股力量，必須去制衡民粹的氛圍，必須讓中道理性的人，有一個投射的希望。而這也是我參選以來一直努力的方向！我重申，臨全會如果廢止我的提名，在合理性、正當性和程序合法性是有高度爭議的，秀柱無法認同，但身為黨員，只有被迫接受。最後請容許我揮揮衣袖，先行離開會場，留給大家冷靜思考的空間。此心可鑑，真情不變。「孤臣可棄，但絕不折節」！黨可以不要我，秀柱絕不會放棄黨！天佑本黨！天佑台灣！天佑中華民國！謝謝大家！" }, { "title": "这个时代，我们需不需要一把野火", "url": "/posts/yehuo/", "categories": "读书记", "tags": "历史, 杂记, 龙应台, 野火集", "date": "2015-08-15 02:21:09 +0800", "snippet": "今天晚上，站在这里说话，我心里怀着深深的恐惧，害怕今晚的言辞带来什么「后果」。我的梦想是：希望中国人的下一代，可以在任何一个晚上，站在任何一个地方，说出心里想说的话而心中没有任何恐惧。我们这一代人所做的种种努力，也不过是寄望我们的下一代将有「免于恐惧的自由」。​——龙应台三十年前的台湾，作家龙应台点燃了针砭时政的野火。三十年后的台湾，正在为了新一届的总统立委选举而大肆宣传。﻿三十年前的大陆，正在对外开放对内改革，抛弃过去迎向未来的新时代步伐中。三十年后的大陆，似乎看出了三十年前台湾的影子。﻿﻿这似乎是一个有趣的轮回，一个时隔三十年两岸的时空互动。﻿不过我们需要的并不是激进的反对，不是温柔的顺从，而是有序的批评，宁静的抗争。﻿﻿整整一年前，香港爆发了激烈的社会民主运动，为的是身为香港公民的基本权利，为的是港人治港的终极目标，一年后香港激进的减少，但是这个目标并没有改变。﻿﻿一年前，我们对香港冷眼旁观甚至嘲笑。一年后，国人似乎一样的沉默。例如，一方面想要更加开放自由的互联网，一方面又希望可以在沉默中获得这样的权利和利益。不可否认，我们是千千万万沉默者中的一员，我们沉默着希望专制的当权者开放影响其统治的互联网。但是，事实证明，一个没有以人民为基本出发点的政府，并不会自己自觉的完成对人民有益的种种事件。﻿﻿几流的人民有着几流的政府，几流的环境。我们并不愿意有序的发出自己的声音，因为我们害怕，害怕自己的声音被当政者反对，打压甚至批判，所以我们沉默，寄希望于这个并不为我们而是为自己前途利益考虑的政府。﻿﻿「升官发财，请走他路。」这是黄埔军校门口的警讯，更是对所有从政者的告诫，为官不能为了自己的利益，而是要为了人民。政府是什么？政府是人民选择出来为自己服务的机构，并不是一个充满着算计权斗升官的利益场。这既是民主政治追求的目标，更是民主政治的一个重要作用，如果一个官员没有为了一方百姓的利益而作出实事，那么人民就有手中的选票来把这个只为自己考虑的官员从位置上赶下来，并且永远地驱逐出政治这片圣洁之地。相反的，如果仅仅只靠「永远的执政党」来所谓的自我净化，那么就会像自然界的河流一样，因为垃圾过多而使得净化功能失去了原有的作用，那么我们所寄希望的政府也就没有了存在的价值，人民的利益也就没有人来维护，所谓的政府官员又和封建时代从上至下的管束有什么区别？无论是社会还是政治，都需要有着反对的声音，如果全社会都是一个声音，没有他声，这个社会会是一个没有活力的社会，一个即将走向晚期的社会。作为一个生物世界要有生物物种的多样性，同样的一个人类社会也要有着声音的多样性，消灭多样性等于自取灭亡。在整个社会的经济发展的过程中，需要有着多元化的声音取舍，一言堂的发展模式会使得经济的发展遇到瓶颈，最终走向崩溃。民主政治就是一个可以让反对者有权利发声，畅快，理直气壮地发出自己反对声音的东西，就是一个可以让执政者更加有底气作出自己决定的事情，他的基础是民意，他的后盾也是广大人民。执政者需要有了反对者的制约，因为如果不是为了反对而反对，而是顺从了大多数反对的民意，那么执政者就会被民意所抛弃，成为所谓的反对者，国家的发展就是在执政和反对之中发展起来的。民主？只是一个可以理直气壮的工具罢了，并不是所谓的洪水猛兽。当然也有人说，民主政治会带来混乱，不安，最终会导致人民生活的更不安定，经济更快走向崩溃。当然毋庸讳言，民主政治需要一段学习和培养的过程，两千三百万人的台湾用了近十年。妄加猜测，如果有生之年大陆能够实行民主政治，估计需要几倍于台湾的时间。民主政治的学习是否一定会带来人民生活的混乱？答案明显是否定的，台湾民主政治的建立过程也见证了台湾经济的腾飞，使台湾跻身「亚洲四小龙」的行列，当然改变人的思考方式是需要有着经济基础作为支撑的，如果有了经济的支持，那么民主政治就会是一蹴而就的事情。如果我们仅仅一味的只要求平静安宁，只为了自己的一点安宁生活而小确幸的话，这个社会就是在温水煮青蛙，最后的结果就是死亡。社会的安宁可以分为两种，一种是真正的安宁，人民生活在碧水蓝天绿地中，有着稳定的收入，自由的言论，获得一手，不加处理的信息。另一种是当局一手创造的安宁，掩盖着丑陋的事实，在对外宣传上狠下功夫，粉饰太平，营造出安居乐业，人民生活水平很高的舆论氛围，打压了与政府之间的冲突。人民与政府之间能不能有冲突？当然能。为什么不能？冲突并不代表着不安定。如果我们所追求的安宁就是没有冲突，那我们为什么需要政府这个组织来帮助我们管理？存在就会产生冲突。人与人的意见不尽相同，如果这个社会的基本机能和基本的诉求通道已经封闭，那么唯一的宣泄口或许就是冲突。冲突是被逼上绝路的人所发泄的唯一管道。毋庸讳言，发展中国家的稳定确实重要，但是稳定并不意味着人们要对政府言听计从，如果一个还在标榜所有权力属于人民的国家还在用政府政党的威权和一句&amp;quot;稳定大于一切”的屁话来封住人民的嘴和行动，追求表面的安定和稳定，那这个国家也就只能是一个经济大国，而不会成为一个全世界都称赞的强国。我们生活的环境不可以谓之好，但是我们都选择了沉默。沉默不言，只要和自己的切身利益没有冲突，那就不会去表达自己的看法。路上的黑车，晚上夜排档夜夜笙歌留下一摊污渍，住处对面的霓虹灯闪耀一夜，我们没有去联系政府的有关部门来解决，因为我们知道联系也不会解决问题，因为他们根本没有为我们解决问题的想法，他们的回复一定是这不是我们的管理范围，请再联系XXXXX部门来解决，亦或是这个不可能解决，这已经很长时间了。这个社会诸多问题的解决不能够只靠着一个人的声音，而是要靠千千万万团结起来的声音。正如前文，如果打电话联系不是一家人家，而是整栋楼，整个小区，那么这件事件一定会引起政府的关注，在艰难的问题也会解决，因为他们感受到了来自人民的压力。我们的人民缺乏的就是对政府的压力，几千年封建社会的残留给我们的影响就是官老爷就是官老爷，不能够沟通，而现代社会的政府并不是封建社会的衙门，政府是为人民服务的，如果不行，我们就有权利把他换掉，而不是靠着更上层的管理，官官相护，无法根治。现在这个时代，我们似乎都不会去思考问题，因为小时候的教育把我们培养成为了一个只会追求正确答案的人，何为正确答案？就是老师就是大家所说的，主流判断标准所认为的。我们只会随大流。这样的特质给我们的社会宣传带来了很大的便利性，因为只要执政党在高处登高一呼，万千民众就为之疯狂，如果没有顺从就会被认为是异类，就会被这个病态的社会所抛弃，甚至是被执政者当做宣传工具，反面教材来继续强化自己的威权。我们有没有冷静的想过，我们为什么要参加政治组织？政治组织应该是有着明确的政治目的人，希望有从政的人，或者是强烈认同其政治理念的人所加入，但是为什么现实社会就会有着许多的青年，根本没有基本的政治观念，没有政治素养的人，甚至是十岁都没有的小朋友争先恐后的加入这些政治组织。难道不就是因为年少无知的小朋友被一群玩弄社会意识形态建设的执政者们所操控的结果吗？他们登高一呼说加入他们就是优秀的表现，果然，这么多年下来我们也就形成了思维定势，如果那个时候我们有着独立思考的能力，或者说在这个流言传开之前有着民主社会，那么我相信，这样一个组织就不会存在着这样庞大的市场。一个国家需要主流意识形态，但是不能够由执政者强加。我们需要的是一个能够给我们脚踏实地未来愿景的执政者，不是一个成天只会宣传假大空的意识形态以及虚无缥缈的梦，乌托邦迷魂药一般宣传的政党。民主政治的选举能够让我们辨别执政者，我们要选择执政者，选择一个适合自己的未来生活，脚踏实地的政党一定会得到大多数民众的支持，而另一个则会被扫进历史的垃圾堆。当然这样的想法或许有点天真，因为现在国民以及全世界人民的思维仍然停留在「选党不选人，选人不选未来」的水准上，但是民主政治的一次又一次选举教育会教会人民如何选举，如何监督，教会执政者如何执政，如何从人民的角度来思考问题。如果不去实践又如何知道民主的成果会是什么样子呢？民主政治是一味良药，但不是灵丹妙药，并不是所有的东西有了他都会根除，但是没了他有些东西永远也不会好。人们的意识需要时间去慢慢的培养，因为在一代又一代的人之后，在世界联系越来越紧密，思想的交流越来越频繁之后，我坚信威权政治会瓦解，会被扫进历史的垃圾堆。现在这个「宁静」的时代，我们需不需要一把不再沉默的野火，一群不再沉默的人民？需要。" }, { "title": "从“三妇”看晚清中国", "url": "/posts/lateqingdynsty/", "categories": "读书记", "tags": "历史, 近代中国", "date": "2015-07-20 02:21:09 +0800", "snippet": "本文为近代史纲要课程的结课作业，现发于此。近代中国的历史是我国一段可谓是不堪回首的历史，也是我国历史的一个惨痛的教训，对于这段历史，也有着许多值得我们当今社会的现代大学生去了解，学习和感悟的地方。张鸣教授提出现代中国人看待这段历史的典型的“三妇”心态，第一种是怨妇心态，凡事以哭闹为主，就是觉得外国列强欺负我们，我们苦大仇深。不仅哭闹，还时不时要掀起衣襟给人看： 我这伤疤当初就是你弄的。第二种是泼妇心态，凡事讲打，打不过我挠，我要反抗，把整个近代史写成仅仅是反抗的历史。这个反抗的过程虽然可歌可泣，但毕竟没打过什么胜仗，充其量就是挠人一把，还挠不到脸上。但是我们觉得很好，还很推崇，因而创造出很多神话。如果当时斗争真有这么波澜壮阔，那英国人根本进不来，我们也就根本不会有这段被称为半殖民地的历史。第三种是情妇心态。它跟前面两种心态正相反，在它看来，殖民历史也是好历史，不殖民我们怎么进步？但是被殖民的过程实际上是很屈辱的，不论在哪个国家都是如此，尤其对这个民族的上层精英来说。如果这些上层精英曾受过本民族悠久文化传统的熏陶，他们就会感到更悲哀。自晚清以来，我们国家走过了一百多年的近代史，对于这段历史的正确认识对于我们国家未来的发展起着至关重要的作用，首先需要了解的就是晚清政府对于外来事物认知的转变过程，并去改变中国人根深蒂固的“三妇”心态。在1840年，英国军队打开了中国这一古老国度的大门，时道光二十年，而远在1795年之前的乾隆年间，这场战争的源头—鸦片就已经在中国泛滥开来，对于这场的起源在这里也没有必要再次赘述，值得肯定的是在第一次鸦片战争结束之时，清政府对于外部世界还是没有正确的认识，对于这场战争，清政府认为区区洋夷，不足畏惧，签订《南京条约》认为是“万年和约”，因为根深蒂固的天朝上国的心态让清政府上层高管没有正确的视角来看待外部世界的变化，仍然坚守“天朝物产丰盈无所不有，原不籍外夷货物以通有无”的心态，认为这仅仅是小打小闹，只要不涉及天朝上国的根本礼数尊严就不足为奇。但是少部分官员，例如“开眼看世界”的第一人林则徐和提出“师夷长技以制夷”的魏源等等，他们并没有被几千年的思想所束缚，他们着实为了中国的进一步发展贡献了一定的作用。在地方官上，那些官员同时也有着小农经济自我封闭的心态，不战不和不守，不死不降不走也成为了成为了两广总督叶名琛的标签，想必有着这种思想不仅仅只有叶名琛一个，但是他确实成为了这种思潮的“代言人”，当然最终他并没有什么好下场，凄凉的客死他乡。1840年国门被打开的中国没有对其有着反应和针对的改革措施，直到1860年，英法两国拿着无足挂齿的小事发动了让皇帝出逃的第二次世界大战之后，清政府的上层开始了解到洋枪洋炮的威力。可见在国门初被轰开的年代，中国从上到下都对着外部世界没有系统和正确的了解。而当今中国人在看待那一次又一次外来侵略，屡战屡败，让有着“怨妇”的心态，还要时不时拿出这段历史来给别人没必要的展示，圆明园的兽首在专家眼中并没有什么文物价值，但是在媒体大众的眼中就好像是至宝，在“怨妇”心态的驱使下一次又一次的掀开自己的伤疤展现给世界，虽然外来侵略的历史着实需要被批评，但是并不应该让自己在自己历史沉痛的伤疤上撒盐。在19世纪中叶开始了洋务运动，自强求富的目标成为了清政府的第一要务，花重金采办洋务，以求改变，毋庸置疑，洋务运动在一定程度上改变了中国的面貌，将资本主义的生产方式带进了有着几千年小农经济基础泱泱大国，将热兵器带进了悠久冷兵器传统的中国。洋务运动着实将中国的军队硬实力上升了几个档次，但是，只有硬件没有软件的军队仅仅只是外表，在沾沾自喜有着世界前列军舰的清政府开始懈怠，完全忽视了邻国在明治维新之后的快速发展。中日甲午之战彻底打破了清政府妄图仅仅引进外来的表面食物继续延迟天朝上国的美梦以及开办二十年的洋务的彻底破产，也让外国列强开始抛弃对中国的一切神话，让中国的半殖民地半封建社会的大大加深。1894年的甲午战争之时，清政府也经历了咸丰，同治两朝，正值青年的光绪帝当政，他着实想改变中国的面貌，就有了变法以图强的维新策略。19世纪的末期，中国在光绪帝的规划下开始了“改变祖宗之法”的道路，但是这场从《明定国是诏》开始戊戌变法仅仅百天就走进了尾声。很多人会把这场变法的终结归结到当朝皇太后慈禧太后的手上，当年的慈禧太后已经在实际上掌握了中国这个大国的管理权几十年，老练的政治手腕着实令人叹为观止，但在我看来，这场变法的失败和慈禧太后的关系不大。不用否认的是，变法失败的直接原因是太后的政治手段，试问，慈禧太后若是不支持变法又为什么要在百天之后才把这场变法扼杀呢，难道不是老太后认为这场变法的无章法也会让变法和中国走向失败吗？在“泼妇”心态的驱使下我们很容易将民间反抗看的很重，三元里抗英，太平天国等等往事统统被宣扬的十分深化，甚至还有“官怕洋人，洋人怕百姓”的言论，要是三元里抗英作用真的有如此神奇，那为什么向来以团结自称的中华民族会有这如此惨烈的近代历史呢？20世纪的第一道阳光，中国是在八国联军侵华的状态下迎来的，戊戌变法的同时，中国的民间开始了义和团运动，这场轰轰烈烈的运动直接导致了八国联军的来到中国，义和团盲目的反对洋人，妄图把所有洋人的东西赶出中国，但是正如中山先生所言“世界潮流，浩浩汤汤，顺之者昌，逆之者亡”，义和团这种带有明显宗教迷信性质的运动也最终会自掘坟墓自取灭亡，但是义和团的思想却根深蒂固的留在了当时人们的心中，上到慈禧皇太后，下到普通老百姓都认为练义和拳可以让洋鬼子落荒而逃，这种思想无疑是荒谬的，在八国联军侵华期间，慈禧太后也竟然相信在庙堂中念经就可以杀死洋鬼子，可见这场运动的影响程度之大。八国联军的铁骑直捣北京城下，中国的皇帝皇后再一次落荒而逃，这一次的目的地不再是有避暑山庄之称的承德，而是遥远的古都西安，这次战争也带来了最丧权辱国的《辛丑条约》，慈禧太后事后的《罪己诏》中也表示了对外国势力的妥协，“今兹和约，不侵我土地，念友邦之见谅，疾愚暴之无知，量中华之物力，结与国之欢心。”，着实“友邦”的不侵土地是为了让清政府成为其统治中国的傀儡，因为当时洋人也了解到了分解中国并且自己统治这个国家是不可能完成的任务，与其自己花费心力来建立国家，不如就利用这个虽然已经腐朽不堪但是仍然可以被自己所利用的清政府。当然当时的政府也开始了最后一次对外来列强的反应，当然也是最彻底的一次，在慈禧太后的一手操办下，清政府1904年开始了清末新政运动，颁布了中国历史上第一部具有资产阶级性质的宪法—《钦定宪法大纲》，确立了君主立宪的体制。就在清末新政，清政府意图变祖宗之法以自救开展之时，慈禧太后和光绪皇帝相隔一天离世，让中国的上层陷入了一片混乱之中，年仅3岁的小皇帝继位，摄政王载沣也是涉世未深的亲王，他继承了老太后的遗志继续着新政步伐，原定近十年的预备仿行立宪，在地方的强烈要求下提前，推出的皇族内阁，让清政府的真实嘴脸暴露了出来，无疑加剧了清廷的覆亡，武昌的一声炮响，结束了中国2200多年的君主专制政体，中国历史翻开了崭新的一页。纵观晚清历史，除了第一次鸦片战争以外，其他重要战争之后都有着清政府的反应动作，但是这些反应不是有着局限性就是目光短浅不敢放开步子去走，最终导致了这些变革和革命的相继流产和覆亡，也使得清廷妄图“大清皇帝统治大清帝国，万世一系，永永尊戴。”的美梦破灭。历史的潮流是不可能改变的，在全世界都在废除君主专制的大背景之下，清廷作为这个世界中的一员是不可能有着特别之处的，世界潮流的变化或许也是除了清政府内部原因以外导致其走向死亡另一个重要因素。在经济变革和政治变革的同时，中国民众也在和洋人的交道中认识到了外国的科技，洋人所带来的市场经济模式基本冲垮了中国几千年封闭小农经济的传统，当中国的经济基础发生了大方向的变化之时，上层建筑当然也需要与之相适应和匹配。毋庸置疑就要去改变这封建专制这种不利于资本主义市场经济发展的政治体制，在近代中国的变革之中这或许也成为了一个及其重要的作用。近代中国的社会形态是畸形的，当殖民主义和封建主义相互碰撞之时，就会产生超乎常规的结果，近代中国旧民俗和新文化相互碰撞，在民族资本主义发展的同时，中国人整体的思想意识储备还是不够的，一些旧民俗阻碍了新事物的向前发展，火车的初入中国就很好的表现了这个例子，还有义和团运动盲目的排外也是中国文化和外国文化碰撞之时中国人所产生的不适应所导致的造成的。这样的资本主义发展同时滋生了一少部分人的“情妇”思想，认为如果没有洋人轰开中国人的大门，中国仍然将处于封闭的状态之中，但是他们忽视了世界的大环境和大背景，一切个体脱离了整体就会造成片面的看待问题，这明显和历史唯物主义正确的史观有这巨大的反差，所以“情妇”的心态毋庸置疑也是畸形的。晚清资本主义发展疲软的另一重要原因或许是外国的资本主义发展都是有着思想的基础，而中国这种畸形的发展模式无疑也导致了中国在道路的选择上出现了反复，从最初的坚持君主专制，到后来的仿日实行君主立宪，孙中山带回来的仿美三权分立，这些无疑都是有着西方启蒙运动给西方民众有着实行这些民主政体的土壤和基础，在没有进行过轰轰烈烈全民的思想解放运动的中国想要在一夜之间建立起这种有着较高民众基础的政体难度是无疑的。“冰冻三尺非一日之寒”，另外一个国家在较长时间和思想发展基础上所产生的政治体制能够轻易的在几年之内复制完整并得到成功这似乎是一件不可能的事情，这也是为什么的现在中国共产党要探索一条适应自己国情的道路来发展有着特殊历史发展背景的中国的原因。历史的发展是不可逆的，中国的近代史也永远只会是个过去式，而不会成为进行式，但是历史的发展是有着重大的建设借鉴意义的，只有有着正确对待历史的史观才可以让我们的事业朝着正确的方向向前发展。" }, { "title": "精诚团结，人民做主", "url": "/posts/KMT/", "categories": "个人杂记", "tags": "历史, 中国, 中国国民党", "date": "2015-05-17 02:21:09 +0800", "snippet": " 找回創黨精神，讓國民黨重新團結。這是我一再強調的，國民黨可以輸掉一場選舉，但不可以輸掉整個世代；國民黨可以失去選票，但不可以失去中心思想。國民黨要團結，要真心團結，要從「心」團結。不是團結在某個個人之下，而是團結在黨的中心思想與大家共同理念之下。以上这段话是中国国民党主席朱立伦在去年党主席选举时所说的，国民党当时输了九合一大选，一下子跌落了谷底，遭受了可以说是1949退败台湾以后对大的失败，但是国民党并不能够就此而沦落成台湾的泡沫政党，在立法院现在还占有多数席次的中国国民党如何重新站起，如何在2016甚至是2020年赢回台湾，应该是摆在国民党人以及全体泛蓝支持者面前棘手的问题。中国国民党的创党精神就是为了全民，蒋经国总统开启了台湾（中华民国）的民主政治先河，让华人享受到了民主这个当代社会的先进成果。中国国民党现在遇到的困局是从去年1129败选以来所留下的，九合一选举的大失败导致的后果就是现在国民党内部的分裂和不团结，这也是朱立伦主席在其讲话说所提到的国民党要从新团结，找回创党精神，更好的为中华民国，为台湾人民所服务。中国国民党从1895年孙中山改制迄今已经走过了120年的道路，期间也经历了许多的风风雨雨，从两次的国共合作到败走台湾，一直沦落到可以称为台湾最不受欢迎的政党之一。虽然历经风风雨雨，但中国国民党这面大旗并没有就此倒下，而是迎着困难迎风向前。中国国民党是一家百年老党，在这一百多年的发展历程中，也遗留下来了诸多的问题，纵横在全台湾的派系和黑金，以及国民党数额庞大的党产也都成了台湾人民所唾弃和讨厌的对象。如果国民党没有妥善的处理好各派系之间的整合团结，党产的清退和整理以及大佬和老人政治的问题，国民党也可能就此沉沦下去，走上了穷途末路，让民进党成为代表台湾主流民意的政党，我相信这并不是全中华民国人民的期盼也更不会是大陆人民的期待。当然，民主政治的可贵之处就在于有着频繁的政党轮替和领导权力交接，只有有了这样的政治体系，才可以保证国家可以处理各种各样的事情，并且不断解决之前所遗留下来的问题，并且检查出前朝到底有着哪些做得不对并且需要改正的地方，这样才能够明白前朝的弊病所在，来使得未来的发展可以更好，更快，更加健康。1129的县市长改选之后，台北市长柯文哲的种种做法就是敢于挑战国民党16年执政所留下的种种弊病，从马英九市长的大巨蛋到郝龙斌市长的松烟文创案，这一系列弊案的揭发，暂且不论是否有着政治斗争的味道，但是我们也可以看出只有一个政党的下台才能够看到这个政党在任上到底有没有认真的贯彻对人民赋予的职责和对人民负责的态度。如果现在的台北市长是连胜文，那么我相信现在的台北市也就没有这么多火药味，总统府和台北市政府将会是一切歌舞升平，毫无关系。政党政治的唯一目标就是期望自己的党派可以永远赢得选民的认可和支持，来继续自己的执政思路，延续当前的做法，当然这样的想法也是无可厚非，但是我们要清醒的看到只有政党轮替才能够改善一个国家的廉政程度，常年盘踞在领导之位会使得思想麻痹，把人民的诉求放到了后面，最终导致的结果就是选民不会把手中的票投给你。民主政治是人民当家做主的最好方式，如果没有了民主的投票权，那么人民当家做主也就没有了关键的决定方式，一个国家如果并不依靠人民的选票来维系来平衡这国家的发展，那么这个现代国家一定会受到人民的唾弃。如果一个国家的民众对于改变自己生活的政治漠不关心，尤其是青年一代，那么这个国家将不会有着未来。如果国家从根本上限制了参加政治活动的人群，只有特定身份以及特定派别的人才能够参加政治活动，那么即使现在有着歌舞升平的盛世表象，那么在盛世的背后潜藏的将会是衰败的起点，因为就读生物学中的基本规律，如果一种生物限制了其基因多样性，那么这种生物最终会走向灭亡，那么一个国家也将会如此。&amp;lt;/p&amp;gt;这一次的总统初选，是中国国民党从参加中华民国总统选举以来第一次举办总统初选，这是中国国民党所跨出的重要一步，因为他用初选的机制来召集了或许比台面上这些A咖们更好的选择，来选出代表蓝色的最佳候选人来赢得选举。初选看似影响党内团结，但是其本质是向好的，他更加促进了一个党的团结，这个机制可以让输的一方输的心悦诚服，让一个政党举全党之力来支持胜出的候选人。当然这样的前提是初选的机制公平公正，能够代表最广大的民意。党内初选如此，全国选举更应如此。假使民主进步党蔡英文主席赢得了大选，那么即使是泛蓝民众也要支持，尊重物竞天择的民主选举结果，这样才可以举全国之力来建设。号召全国人民，仅仅用一党的口号式宣传，洗脑式灌输是毫无作用的，这样做的结果只有表面功夫，这样的后果将会比人心不齐更加严重，会使国家走向上层认为发展光明良好，下层阳奉阴违的恶性循环。民心不齐无以成大事业，只有让人民来决定领导者，通过正常正当的选举方式来决定自己国家的未来方向，这样才能够永续。一个国家的发展方向应该是自下而上决定的，所有历史的经验告诉我们，自上而下的改革和决定的发展道路都是不稳定的，需要最终改进的。面对面前的2016，中国国民党及其支持者要更加精诚团结，只有团结才能够赢得台湾，赢得中华民国。对于一个国家只有走上了人民真正当家作主的路途才能更好地发展，更永续的发展。治大国如烹小鲜，这样的前提就是提高国民素质，将权力真正的还给人民。民主，不能仅仅是喊喊口号而已。中华民国的民主政治被一次又一次的选举证明是成功的可借鉴的，也向世界宣告华人也能够有民主政治，有当家作主的权力和能力，也但愿民主政治的朝阳长照我土，但愿中华民族的团结永存。 毋自暴自弃，毋故步自封。光我民族，促进大同。守成不易，莫徒务近功。民国一百零四年五月一十八日" }, { "title": "赫逊河畔徜徉的中国史(1)", "url": "/posts/chinese/", "categories": "读书记", "tags": "历史, 中国", "date": "2015-04-14 02:21:09 +0800", "snippet": "赫逊河畔徜徉的中国史(1)2015.4.14最近几日拜读了黄仁宇先生所作的《赫逊河畔谈中国历史》，也捡回了高三以后就基本没怎么读过的历史方面的书籍，拜读之后，深有感触，也对之前对中国历史基本脉络进行了新形式的梳理。黄仁宇先生的历史著作以其特有的“大历史”著称，在整本书中贯穿其中的是对中国历史从宏观上面的把控，虽说每一篇小的文章的题目都是从细节的史实或者具体的人物来取得，但是文章中的内容却从这一点引申出去，从更高的层面上来令人感受到这段历史，这样的史观可谓是自成一家。##第一帝国前的序曲根据黄仁宇先生的划分，这篇读后感也根据书中对中国历史的具体划分来铺陈开去。在秦汉的“第一帝国”之前，中华民族其实也经历了近千年的发展和演变，这样的变革最为突出的就是春秋战国时代，在这个时代，中华民族的思想交融达到了空前的规模。从孔孟的儒家到老庄的道家，从韩非的法家到其他的三教九流，都在这个时代来到了鼎盛时期。除了这些思想上的交融，春秋战国时期虽然“礼崩乐坏”，但是在以小农经济为主的基本经济层面上并没有发生重大的转折变化，反倒是因为技术的革新和变化使得耕作的效率变得更高，每年可以获得的收成也变得更多。这些其实都是先人开始学会铸铁之后所产生的。气候和土地条件的适宜再加上技术的革新与进步，中国的人口数量也快速的增加。但是有一个问题始终没有解决，其实这个问题一直困扰着中国几千年的传统封建社会，这就是治理黄河之水的问题。在战国时期，诸侯分裂割据，黄河问题各自为政，但这样只顾自己的防卫，必然会导致其他诸侯国的不满和不便，这样的循此往复，再加上前面的各种客观因素，最终必然会产生一个中央集权的政府来统一协调整个国家的治理，无论是水务还是各种技术和思想上。这些因素的水乳交融，最终促成了中国的第一个帝制国家–秦，也从此拉开了“第一帝国”的序幕。第一帝国中华民族的第一帝国从公元前221年秦始皇统一全国开始一直基本持续到了公元后的220年曹丕篡汉自立，其中虽然有着王莽篡汉以及新汉之间的交替，但整个政治架构并没有发生根本性的转变。在秦始皇统一六国之后，首先做的就是统一国家所必须要做的–“书同文，车同轨”的同化工作。在几百年的分裂之下，中国重新开始进入了一个同一时代。这个时代用官僚主义代替了之前分封世袭制，用一系列的政治体系的架构来代替了之前王即共主的模式。在中华民族水患不绝的地理因素的驱使下，使秦国成为了诸侯国中统一中国的那一个，这样的统一，根据黄仁宇先生在书中所提到的一样： 中国初期早熟的政治统一，造成“书同文，车同轨”的局面，是一种有历史地理性的组织和一种带群众性质的活动。中国的第一帝国的统一是政治早熟的，因为在自然因素的驱使之下令中华民族不得不产生一个由中央集权性质的国家来统一领导战胜自然因素，这也导致了在这样的一个政治模式之下，很多政策和架构都只能是在中央一级层面有着完美的作用。并且中国这种依赖于间架性设计的政治模式，有着天然的制约和牵绊，政治家用着自己的聪明智慧认为可以这些政策可以统一管理和领导这个国家走向繁荣富强，但是下层的民众并没有这样的政治意识来贯彻这样的上层决策，这样的上层智慧无法传达就从客观上促成当时中国社会就必须有着一个统一的全国首领来领导这一切，这个任务就是皇帝。当时中国的发展因为其政治早熟，从一定程度上就必须依赖于皇帝的贤明，如果皇帝的政治头脑足够智慧，就可以带领这国家走向发展（这样的皇帝基本都会在一个朝代的初期才会有），如果皇帝的政治头脑里只有如何享乐，那么基本着整个国家体系就无法运转，这时候就会在两汉大规模的出现外戚，宦官的专权，因为这整个国家都必须有一个足够聪慧的人来带领走向前方，没有皇帝的制约，整个文官体系也没有足够的政治土壤来令其生根发芽以限制外戚宦官，那么最终的后果就是自取灭亡。 一般政令上面冠冕堂皇，下面有名无实，官僚间的逻辑被重视，其程度超过实际行政效能，又仪礼也可以代替行政，种种流弊，到二十世纪不止。而最大的毛病，则是西欧和日本都以以商业组织的精神一切按事情主持国政的时候，中国仍然是亿万军民不能再数目字上管理。在经过汉初的休养生息之后，中国的国力已经达到了一个鼎盛的阶段。但是这一段文景之治，其本质还是专权政治，就像前文所述，因为有着开明的皇帝，用了正确的方法（无为而治，休养生息），才使得中国的国力来到了第一个高峰期。但是这样的政治模式也只是适用于当时的中国环境，若放在现在，就算有这这样的人民幸福生活，很多人也会批评政府专制。这一切都可以归结到当时中国的政治早熟上来，在西方还没有统一帝国形成之时，中国已经有了庞大的官僚体系。这也正如黄先生在书中所提到的 文景之治表面上人民受惠，然则其施政不出于“开明专制”的典型。我们也知道：在一个广大的领域之上行专制，必自命开明。因为它执掌绝对的黄泉，除了以“受天命”和“替百姓服务”之外，找不出一个更好支持他本身存及其作为的逻辑。其真伪不论，即算它做的最好，顶多亦不过“民享”，而不是“民治”，长期如此，其权利必凝固为官僚政治。这一段精辟的概括，从根本上分析了中国的政治体系在官僚这个问题上的成因，这样的问题也最终导致了整个第一帝国从基本的底层根基上出现了根本的动摇，一旦统领整个官僚体制的首领没有做好它应该做的事情，使得人民既没有民治也没有民享，就会产生民怨，从而推翻整个帝国的的大一统统治。中华民族的第一帝国就是一个在自然因素下促使其产生的政治早熟的帝国。因为政治早熟的根本原因，导致了必须要有一个明君作为首领，而且人民的政治头脑并没有开化，等到这人民开始有了民治的意识之后，第一帝国的根基就开始动摇，从而促使了帝国的覆亡，走向分裂。在东汉灭亡之后，中华民族走向了第一次大分裂，但也正是这次大分裂，促成了中华民族的第一次民族融合，也使得第一帝国和第二帝国之间有着政治思维和政治体系上的过度，政治早熟已经成了历史中的历史名词，中国的历史从国家的政治上已经开始逐渐建立起一套有着基本运转机制的文官体系。未完待续" }, { "title": "无题杂谈", "url": "/posts/birthday/", "categories": "个人杂记", "tags": "其他", "date": "2015-04-04 02:21:09 +0800", "snippet": "生日之时，随便写写，不正以及逻辑不通之处，敬请批评指教。不喜勿喷~。 开篇 高考 兴趣 股市 世界和未来##开篇 本次列车终点站松江南站,下一站 松江大学城。开左边门。每个周一都是在漫漫2小时的长路中开启了新的一周的学习。从上海市区到松江大学城的距离应该是在9号线开通以后显得并不那么漫长，十几站地铁代替了以前可能坐2小时公交车的路程。地铁的便捷或许也让人们感受到空间的距离似乎并不一定需要时间才能够挽回，但是，这样的机械式的一站站的停靠，着实让我们缺少了一些可以展望窗外风景的机会。每个周五，特意选择松梅专线的路途并不仅仅因为想要避开松江大学城地铁的汹涌人流(在松江大学城学习的孩子都知道周五下午18路每一站的汹涌人潮)，公交车在高速公路上飞驰着，越来越多的车流在提醒着自己一周的学习生活又一次结束了，又重新回到了市区。28.4公里的路途不可谓遥远，但是为了跨越这28.4公里的人生却着实需要花费巨大的时间和决心。##高考 天道酬勤高考，每个中国人都无法回避的问题。高考在中国的地位无可撼动，相比在祖国的其他地方，窃以为生活在上海还算是幸福，没有“衡中般”的痛苦教育，也没有老少边穷地区的窘迫环境。高中的三年，在华东师大一附中这样一个在全上海市重点里管理最松弛之一的学校度过，其实感觉生活并没有外界宣传的那样的恐怖和恐惧。3年的时间，被一次分班生生的隔了开来，当时间来到了高二下学期，我们重新踏入了高中的第二个阶段，进入了有一个崭新的班级，开始了准高三的生活。高三苦吗？每个人都会有着不一样的答案，但是有一个主轴或许是不变的，每一位学生都会为了自己力所能及的最高目标在前进，在前进路上或许充满着艰难困苦，但是大家都会相信自己的努力会得到应有的回报。当你花费了十倍甚至百倍的精力来攻克学习这道难关，用尽每一分每一秒来思考一道数理化的难题，每天一张试卷的进度在向前行进的时候，总会自我安慰道在下一次的考试中能够获得更好的成绩，得到更好的名次。但是当发现现实就是花了这点时间下去，一点成效都没有，原来是90分的数学在因为均分上涨的情况下考到了100，这样的打击我也不是没有经历过，高中的三年里，每个人应该都会遇到这样的挫折。在生活的道路上，不可能没有挫折，有的人会自暴自弃，既然这样做没有效果，但何不回到原来懒散的生活中去呢。有的人会思考，去找到错误的原因，去找到症结所在，然后想想这样做是否值得，并且修正原先的一些做法。每个人的选择都有着对未来的考量，永远不要批判第一种人，因为他们或许也对自己的未来和目标有着自己的考量，因为你也无法肯定第一种人是否是在这个社会的上层人士，家庭中有着万贯家财可以等着挥霍。天道酬勤，最近越发感觉这句话是真理。花费的时间和精力总会得到回报，或许命运会和你开个玩笑，回报并没有及时的在应该出现的时候出现，但是以后的日子里一定会发现这样的勤奋努力会有着其用武之地。勤奋努力的读书可能没有在高考中换取到好的成绩，但是他可以帮助你养成一个好的习惯，在日后的学习之中受益无穷。高考重要吗？“当然重要”，家长们或许会这样回答。但是静下心来仔细想想，好学校着实如此重要吗？一些不知名的学校也会出现人才，是金子总会发光。无论在什么样的学校，考进清北复交也无需骄傲，因为山外有山，你只不过比别人拥有了更好的环境来学习，如果整天只是我在寝室打游戏，其实好学校之于他们也毫无意义。考进二本末流也无需气馁，只不过失去了好的环境，但是在现在一切都有互联网的时代，又有什么不能够弥补的呢？看看好大学的MOOC和公开课，隔绝不好的环境，多去图书馆跑跑，这样也会干出一番成绩。高考仅仅是一道坎，当跨过这道坎后，回头一望心中或许也会有这样的感慨： 回首向来萧瑟处，归去，也无风雨也无晴。##兴趣每个人都会有着自己的兴趣所在，在中国的教育体系中，要真正发扬自己的兴趣所在或需要等到高中以后。在“学术自由”的大学中，每个人都能够选择自己喜欢的专业，当然是理想的状态。但是有些人因为种种原因并没有考上自己所中意的专业，在另一个自己毫无感觉的专业中渡过。你会说，我对这个专业毫无兴趣，无法学习。但是仔细想想有没有付出时间来接受这样的现实，永远不要想着转专业，每个专业都会有着自己的难处，在一个不感兴趣的专业中遇到的困难，不要老拿我不感兴趣，所以学不好的理由来搪塞自己，因为如果真的换到了自己喜欢的专业，那时候同样也会遇到这样的困难，这时候或许会发现，还不如在原来的专业来的轻松自在。每个专业的存在都有着其缘由，存在即合理，这个社会需要这样的人才就会有这样的专业。不要用薪资高低来衡量专业，时代永远在变化，四年之前因为薪资水平而做出的决定可能到了四年以后完全变成了另一个模样。所以，选择专业的第一准则仍然是自己的兴趣爱好所在。兴趣的培养是需要时间积累的，进入了不喜欢的专业去尝试着接受它，或许几年之后发现其实自己还是蛮喜欢这样的内容的。##股市 股市有风险，入市须谨慎。2014年底以来，中国股市开始一波波澜壮阔的大牛市，牛市不言顶，我也无意在这里预测这波牛市什么时候会结束，会到什么点位结束，因为这样作出的预测往往会被现实无情的打脸。股市中的起起伏伏，会让人感受到金钱来的如此之快，也会让人提升对数字的敏感性，看着自己账户里每天跳动的数字，这些数字挑动着无数人的神经。涨涨跌跌，股市中的定律。永远不存在只涨不跌的股票，所以入市之前，就要做好血本无归的准备。盈利我幸，亏损我命。不要因为投资的股票飞涨了几十个点就认为自己是股神，做什么都能够赚钱，也不要因为亏损了几十个点就要死要活，因为这样并不值得。我始终不太喜欢将进入这个市场称之为“炒股”，因为我始终相信股市并不是需要靠炒。但是这样的搭配或许也让我们看到在社会主义中国对这个资本主义产物的不了解。一波题材来袭总可以带动一大批股票的股价闻风而动，在这样的炒作并不需要基本面的支撑，当市盈率已经高的离谱的时候，总有人还是无脑的带着辛苦钱冲进去，但很不幸自己没有主力那样的实力带动股价，一冲进去就成为了那最后一棒，为前面所有人买单。我认为，选股仍然需要坚持价值，始终坚信大蓝筹有着应有的价值，当股价在承受范围之内，着实可以拿着银行等波动不大的股票，等着每年固定的高分红，也比存定期强，或许也比频繁进出强。股市并不是一个零和游戏，但是始终需要资金的强力支撑。何谓资本市场，就是需要有着资本，没了资本，就像脱水之鱼，无从生存。每个人都可以哄抬股价让自己高抛低吸从中收益，但是这样的操作是需要有着几亿甚至几十亿的资金的，没有金刚钻别揽瓷器活，没有跟着股价的波动进出的话还是对这个市场保持敬畏，就算赚了几倍于本金的盈利，如果没有对市场的敬畏之心也会让这些利润一夜之间化为乌有。现在的市场，并不简简单单是低价买高价卖的简单游戏，金融衍生产品层出不穷，股指期货，股票期权，融资融券，分级基金等等这样的专有名词的出现，无不冲击着普通散户股民简单的大脑，大多数人并没有这样的能力和时间去学习这些专业术语，把这些工具玩弄于鼓掌之间。我们仅有的武器就是小米加步枪，但是当主力和大户已经有着如此之多堪比坦克飞机大炮盈利工具之时，不免唏嘘，资本市场就是这样的不公平，有钱人永远只为越来越有钱，而想要赚点吃饭钱的普通人却只能把钱拱手送出，最后“净身出市”。市场有着其独有的运作规律，但是这样的运作规律也会满足一些人预测未来的想法。在牛市中，就连路边卖菜的阿姨都认为自己有着炒股的天赋，全民炒股的炒股的时代就在牛市中发生，但这样带来的也或许是危险的信号，因为范围有限的市场就可能变成杀人不见血的吸钱市场，把所有人都套在高位，然后理性的人拿着头脑发昏人交出来的钱，给了他们高位的筹码，快乐的离开了这个市场。用英强的看法来说就是 股市就是一家自助餐厅，每个人都可以进来拿走自己想要的，无论多少。吃完以后不用结账买单就能够离开，但是千万别在营业时间截止的时候出去，那时候出去的就要为前面所有人的任意挥霍买单。##认识世界和未来 决心，努力，创意。不能成为第一，至少成为唯一。看完胡志强市长的课程之后，印象最深或许就是这两句，胡志强市长虽然在去年的九合一大选中没有成功，但是他的思想确实值得我们去学习，去聆听。这一节课给人的收益匪浅，花出2小时听听，或许得到的好处将会受益终身。每个人的专业或许不一样，但是未来是一样的，我们需要有着对这个世界的认识，因为只有认识这个世界，才能够对人生和未来有着更加全面的认识，才会能把自己未来明晰化。未来或许是未知的。但是借用胡志强市长的一句话，不要用现在决定未来，而要用未来决定现在。想想自己想要什么，在冲着这个目标去努力，去奋斗。否则就会像飘浮在海上的玻璃瓶随波逐流，最后一无所获。世界在年轻的胸怀。*以前从来没有在生日的前后码字，但是人不就是在一次次的改变中前进的吗？Change是人生的必须，不是吗？ ####无论你愿不愿意，人必须往前走，向前看。火已燃起，你的位置，自己决定好了吗？" } ]
